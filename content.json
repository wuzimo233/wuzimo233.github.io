{"meta":{"title":"zimo","subtitle":"zimoの博客","description":"人要接受自己的有限性，人的逻辑、理性、阅读都是有限的，整个人就是在偏见之中。人这一生就是在走出偏见。","author":"Zimo","url":"https://wuzimo233.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-04-14T05:28:56.000Z","updated":"2022-04-16T01:46:42.290Z","comments":false,"path":"about/index.html","permalink":"https://wuzimo233.github.io/about/index.html","excerpt":"","text":"普通人埼玉“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：普通人琦玉（萌新up） QQ：2772459092 座右铭：昨日之深渊,今日之浅谈"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wuzimo233.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-15T09:12:19.000Z","updated":"2022-04-15T09:30:45.183Z","comments":false,"path":"categories/index.html","permalink":"https://wuzimo233.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-04-15T09:38:28.000Z","updated":"2022-04-15T09:38:20.951Z","comments":false,"path":"comments/index.html","permalink":"https://wuzimo233.github.io/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-15T09:33:49.000Z","updated":"2022-04-15T09:34:52.986Z","comments":true,"path":"link/index.html","permalink":"https://wuzimo233.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://wuzimo233.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-15T09:09:39.000Z","updated":"2022-04-15T09:29:33.704Z","comments":false,"path":"tags/index.html","permalink":"https://wuzimo233.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-13T13:05:50.468Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wuzimo233.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-16T02:11:08.265Z","comments":false,"path":"List/movies/index.html","permalink":"https://wuzimo233.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-15T18:40:45.848Z","updated":"2022-04-15T18:40:33.275Z","comments":true,"path":"bangumis/index.html","permalink":"https://wuzimo233.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-16T02:11:10.000Z","updated":"2022-04-16T02:18:08.424Z","comments":false,"path":"List/videos/index.html","permalink":"https://wuzimo233.github.io/List/videos/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-04-13T16:19:21.819Z","comments":false,"path":"List/music/index.html","permalink":"https://wuzimo233.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wuzimo233.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wuzimo233.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"git基本操作","slug":"17-git基本操作","date":"2022-09-25T03:21:15.000Z","updated":"2022-09-25T03:21:51.634Z","comments":true,"path":"posts/18.html","link":"","permalink":"https://wuzimo233.github.io/posts/18.html","excerpt":"","text":"git基本操作学习来源：https://doc.houdunren.com/git/1%20%E6%8E%8C%E6%8F%A1GIT.html#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE 安装git官网：https://git-scm.com/ 、https://gitforwindows.org/ 安装过程略过，百度一堆 安装后通过以下命令查看，如果显示版本号那就是安装成功了 git --version 配置作者信息桌面单击右键选择 Git Bash Here， cd回车到根目录cd //回到根目录 新建 git文件夹mkdir git 使用cd 切换到git目录 cd git 配置自己的信息邮箱和名称 git config --global user.email \"12345678@qq.com\" git config --global user.name \"zimo\" 接着回到根目录（Ctrl+L键是清理屏幕） cd 查看配置成功与否（前提是已经安装Sublime Text软件，且配置了系统变量） subl .gitconfig 回到git目录，新建一个edu文件夹，并且进入 mkdir edu cd edu 查看当前路径pwd 查看目录下文件ls仅罗列出当前目录下的文件名或目录名 ls ls -a列出目录下的所有文件，包括以 . 开头的隐含文件。 ls -a ls -l （等价于ll）列出文件的详细信息。 ls -al (等价于ll -a)显示当前目录下的所有文件及文件夹包括隐藏的.和…等的详细信息 回退指令返回上一层目录 cd .. cd -返回到上一次的工作目录。 基础流程创建仓库git init //在任意目录下创建仓库 克隆仓库在git目录下 git clone xxxxxxxx.xxx （github地址） git流水线分析git就是一个仓库，例如现实中一个服装厂仓库，我们把做好的服装放到仓库里。 现实中：【做好的服装】 =====&gt; 【工人用手放到推车】 ====&gt; 【 用推车放到 】 ====&gt;【服装仓库】 程序员：【写好的代码】 =====&gt; 【 git add 】 ====&gt; 【 git commit】 ====&gt;【git仓库】 有时候需要改动服装（文件），那么就需要查看生产车间的状态是怎么样的 ===&gt; 使用git status 查看状态 ps：小推车在git中也叫做暂存区 练习git流水线git目录下新建一个文件夹hd mkdir hd // 创建hd文件夹 cd hd // 切换目录到cd git init // 初始化空的仓库 使用touch命令新建空白文件 touch a.php // 新建空白文件 git status // 查看状态，发现 a.php文件是未跟踪状态，即没有被版本库提交过 git add // 放到小推车里 git commit -m 'xxx' // 推送到本地仓库并且添加描述 此时 git status没有异常， 生产车间状态和仓库的文件是一摸一样的，不需要再把车间文件放到仓库 多个文件一并提交git add . // 会将未跟踪的所有文件提交到暂存区（推车里） .gitignore详解控制版本库文件管理git下新建目录 shop mkdir shop cd shop subl .gitignore // 使用subl 新建.gitignore文件并打开，这里面能够配置哪些文件需要提交 touch a.txt // 使用touch 新建文件 git status // 此时可以看到 .gitignore 和 a.txt文件未提交到暂存区 在.gitignore文件中 写入 *.txt // 此时看不到 a.txt文件未提交到暂存区 mkdir vendor git status // 发现未跟踪列表没有vendor文件夹（因为不会跟踪空白文件） .gitignore 文件如下 # 该文件是存放不提交到仓库的文件 # 所有txt文件都检测不到 除了a.txt *.txt !a.txt # 提交时检测不到vendor文件夹及子文件夹所有的php文件 /vendor/**/*.php # 提交时检测不到该文件夹下所有内容 # /vendor 从版本库中删除资源的技巧git下新建目录 bbs mkdir bbs cd bbs git init touch a.txt git status git add . git commit -m '版本1' git rm a.txt // 会同时删除版本库和本地的文件 touch readme.txt git add . git commit -m '版本2' 有时候有很多文件放到版本库，其实没有必要，也就是本地需要保留，版本库不需要放入 git rm --cached readme.txt // 移除的是版本库的文件，本地该文件依然保留着 从版本库中修改资料名称touch c.php git add . git commit -m '版本1' git mv c.php zimo.php // 改名 git status git commit -m 'c.php 改名为 zimo.php' git status git log --name-only 使用log日志查看历史操作行为git下新建目录 hd mkdir hd cd hd git init touch a.php git add . git commit -m '提交a.php版本1' touch b.php vim a.php // 打开vim编辑器 按i 输入文字 输入zimo.com 文字 cat a.php // 查看编辑的内容 git add . git commit -m '将新增b文件和更新后a文件提交' git log // 查看日志 （包含每次提交的唯一哈希值、作者、时间、描述等） git log -p // 查看详细日志（包含更新的内容） git log -p -1 // 查看最近的一次提交 git log --oneline // 查看简短日志 (git log --oneline -p等同于git log -p) git log --name-only // 查看文件发生的变化 git log --name-status //查看文件具体发生了什么类型（新增，删除等）变化 使用amend修改最新一次提交事件git下新建目录 zz mkdir zz cd zz git init git log touch a.php git add . git commit -m '第一次提交a.php' git log // 发现描述不具体 git commit --amend // 打开vim编辑器，修改刚才的描述 zimo的第一次提交a.php git log touch b.php // 有时候想将另一个文件也放到这次提交里面 git add . git status git commit --amend // 添加一行描述 增加b.php a.php git status git log --name-only // 看到新提交了两个文件 管理暂存区中的文件git下新建目录 xj mkdir xj cd xj git init ls -a touch a.php // 文件放入暂存区 git add . git rm --cached a.php // 撤销文件放入暂存区 vim a.php // 编辑一下a.php文件 git status git add a.php git status // 此时发现文件已经在暂存区了，此时如果后悔和之前第一次不一样 git reset Head a.php // 这样可以取消放入 cat a.php // 查看文件内容 里边的内容还是之前编辑那样 git checkout a.php // 恢复到仓库提交的初始状态 cat a.php // 此时文件内没有内容 alias命令别名提高操作效率之前敲提交需要： git add . git commit-m '' 每次都比较麻烦 git config --global alias.a add // 以后git a . 等价于 ait add . subl .gitconfig // 在根目录执行 查看全局配置文件 可以看到[alias]下有 a = add ，此时可以直接在这里编辑想改的代码 // 比如我改成如下 [alias] a = add . c = commit l = log s = status // 回到xj仓库目录 touch z.php git s git a git s git c // 会打开vim 第一行写上描述保存退出即可 git l Git分支详解Git分支Branch存在的意义[ ]是提交的版本 其他功能分支a ---[ ]---[ ] / \\ / \\ ---[ ]---[ ]---[ ]--- master主分支----------&gt; \\ / \\ / 其他功能分支b ---[ ]---[ ]---[ ] 实例讲解分支branch基本管理操作git下新建目录 fz mkdir fz cd fz git init git branch // 此时查看分支是查看不到任何分支 touch xj.php git add . git commit -m '提交xj.php' git branch // 此时会看到一个主分支 * master，*星号代表当前所在的分支 git branch ask // 创建一个ask分支 git branch // 此时可以看到主分支 *master和branch 分支 git checkout ask //切换分支到ask touch ask.html git add . git commit -m '提交ask.html' ls // 可以看到俩文件 ask.html 和 xj.php git checkout master ls // 此时切换分支回master后仅看到 xi.php git checkout -b bbs // 创建并且切换到bbs分支 分支的合并与删除git checkout master // 假如当前产品问答功能已经做好，需要切换到主分支 git merge ask // 将ask分支的所有提交合并到主分支上 git branch -d ask // 删除分支 分支冲突实例解决一个资源被不同的分支所共同修改了，在合并的时候会产生冲突 git下新建目录 ct mkdir ct cd ct git init vim xj.php // 使用vim任意新建一个文件，内容冒号 : git commit -m 'master提交xj.php' git branch ask // 创建ask分支 git checkout -b bbs // 创建并切换到bbs分支 ls // 能够看到包含了之前master提交的xj.php文件（因为是从主分支的提交点后创建的ask和bbs分支，因此也拥有主分支提交的文件） vim xj.php // 此时内容是 : 将其改为bbs git add . git commit -m 'bbs提交xj.php' git checkout ask vim xj.php // 此时内容是 : 将其改为ask git add . git commit -m 'ask提交的xj.php' git checkout master // 切换回主分支 git merge bbs // 合并bbs分支 cat xj.php // 可以看到内容是 bbs git merge ask // 此时合并ask分支将会报错 Merge conflict in xj.php subl xj.php // 打开xj.php,可以看到结构如下 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD bbs ======= ask &gt;&gt;&gt;&gt;&gt;&gt;&gt; ask // 直接将内容改为这样保存 bbs ask git add . // 此时再提交即可 git commit -m '修复合并提交xj.php' 分支管理merged及分支强制删除git branch --merged // 查看已经合并的分支 git checkout -b test // 新建并切换到分支test git checkout master // 切换到主分支 git branch --merged // 可以看到ask、bbs已经和master分支合并 git checkout test touch mm.php git a git commit -m 'test提交mm.php' git checkout master git branch --no-merged // 查看没有合并的分支 git branch -d test // 删除分支 test 会有提示 git branch -D test // 直接删除分支 标准的分支操作工作流master 被称为：稳定分支 一般从master分出develop分支 然后从develop分出ask分支 此时我和张三是ask分支新增模块的开发者，就将这个分支拉到本地 假如我负责登录页面，然后我可以在本地创建ui或者其他分支，等写好功能后合并到ask 假如张三负责后台页面，他可能会本地创建ht或者其他分支，等写好功能后合并到ask 然后将ask分支合并到develop分支 stash临时存储区实例讲解主要解决：临时需要切换分支，但是当前分支不想提交，我们可以将其暂时存储起来 mkdir ns cd ns git init touch master.php git add . git commit -m '提交master.php' git branch ask git branch bbs git checkout ask git branch 可以看到当前有三个分支 * ask bbs master touch ask.php git add . git commit -m 'ask提交ask.php' vim ask.php // 内容里添加ask.php 保存退出,注意该文件已经commit一次了 git add . git status // 可以看到添加暂存区成功 On branch ask Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: asd.php // 此时想切换到bbs分支将会提示 git checkout bbs // error: Your local changes to the following files would be overwritten by checkout: asd.php // Please commit your changes or stash them before you switch branches. Aborting // 会提示如果切换分支会覆盖文件，因此不允许切换其他分支 // 因此可以把当前文件放到临时存储区 git stash git stash list // 可以查看临时存储区的列表 git checkout bbs // 然后可以切换分支 git checkout ask // bbs分支忙完后切换回ask git stash apply // 恢复临时存储区的文件 git stash list // 当然临时存储区里文件依然存在的 git stash drop stash@{0} // 不想要的话可以删除 git stash list // 此时临时存储区为空 git stash // 再来放到临时存储区暂存一下 // 如果想把临时存储区直接删除为空可以使用： git stash pop // 将文件库提交一次 git add . git commit -m '提交asd,master' touch xj.php // 因为还没有放进暂存区，此时执行临时存储区是不会操作的 git stash //No local changes to save git add . git stash // 需要文件放入暂存区后再执行 touch ns.php // 再新增一个 git add . git stash git stash apply stash@{1} // 可以恢复第一个文件 git stash apply stash@{2} // 可以恢复第二个文件 使用TAG标签声明项目阶段版本git tag // 显示当前TAG列表 git tag v1.0 生成zip代码发布压缩包mkdir TAG cd TAG git init touch tag.txt git add . git commit -m 'test' // 'tagcms/'表示压缩之后的文件叫'tagcms' git archive master --prefix='tagcms/' --forma=zip &gt; tagcms.zip 使用系统别名定义git全局指令cd // 回到根目录 ls -a // 找到.bash_profile ，我没找到新建了一个 // 使用subl打开该文件 subl .bash_profile // 输入以下内容 alias gs=\"git status\" alias gc=\"git commit -m \" alias gl=\"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\" alias gb=\"git branch\" alias ga=\"git add .\" alias go=\"git checkout\" // 关闭当前git窗口，重新打开一个git窗口就可以使用刚才配置的命令 合并分支产生的实际问题演示mkdir ys cd ys git init touch master.php ga gc 'master提交master.php' go -b ask gb // 此时已经在ask分支上 touch ask.php ga gc 'ask提交ask.php' gl // 查看到文件的提交信息 go master // 切换分支 git merge ask // 合并ask，可以看到Fast-forward快速合并关键词 gl // 查看日志 * a9c1c63 - (HEAD -&gt; master, ask) ask提交ask.php (5 minutes ago) &lt;2022zimo&gt; * 1ac517b - master提交master.php (17 minutes ago) &lt;2022zimo&gt; //当前分支如下 ask分支-[提交ask.php] / \\ / \\ --master主分支--[提交master.php] ---------------[合并]&gt; // 另一种情况 cd .. mkdir ys2 cd ys2 git init touch master.php ga gc 'master commit' gl // 查看日志 看到是初次提交 * 12e27d9 - (HEAD -&gt; master) master commit (5 seconds ago) &lt;2022zimo&gt; go -b ask touch ask.php ga gc 'ask commit' go master // 切换到master touch m2.php ga gc 'm2 commit' git merge ask // 合并描述任意打字 gl // 查看日志 如下： * 42cf081 - (HEAD -&gt; master) zimo Merge branch 'ask' (2 minutes ago) &lt;2022zimo&gt; |\\ | * b9dff47 - (ask) ask commit (20 hours ago) &lt;2022zimo&gt; * | 7f0e6fe - m2 commit (20 hours ago) &lt;2022zimo&gt; |/ * 12e27d9 - master commit (20 hours ago) &lt;2022zimo&gt; //当前分支如下 --master主分支--[提交master.php]--[提交m2.php]--[合并]---&gt; \\ / \\ / ask分支-[提交ask.php] rebase合理的优化分支合并// 以上可知，主分支提交一个文件后，并分出去一个分支后，如果没有新的提交没有commit记录，在合并分支时候就不会有合并的记录 // rebase就是先将子分支提交记录存起来看不见，然后将子分支的提交点移动到主分支最新的提交点，然后将子分支的动作恢复与主分支进行合并 // 如果在其他开源项目提交一些操作的时候先走一下rebase cd .. mkdir re cd re git init // 主分支提交一次 touch master.php ga gc 'master commit' gl * 691006b - (HEAD -&gt; master) master commit (3 seconds ago) &lt;2022zimo&gt; // 然后切换到子分支 ask，创建文件提交一次 go -b 'ask' touch ask.php ga gc 'ask commit' gl // 此时子分支能看到俩条记录 * f83df17 - (HEAD -&gt; ask) ask commit (9 seconds ago) &lt;2022zimo&gt; * 691006b - (master) master commit (3 minutes ago) &lt;2022zimo&gt; // 回到主分支 go master touch m2.php ga gc 'm2 commit' // 此时因为主分支往前走了一个提交，如果合并分支会产生合并记录 go ask gl git rebase master gl // 可以看到将子分支的提交（ ask commit）放到主分支最新提交（ m2 commit）的后边了 * 6a89788 - (HEAD -&gt; ask) ask commit (14 seconds ago) &lt;2022zimo&gt; * 9d3435c - (master) m2 commit (3 minutes ago) &lt;2022zimo&gt; * 691006b - master commit (9 minutes ago) &lt;2022zimo&gt; go master gl git merge ask gl // 日志非常干净 * 6a89788 - (HEAD -&gt; master, ask) ask commit (4 minutes ago) &lt;2022zimo&gt; * 9d3435c - m2.php (7 minutes ago) &lt;2022zimo&gt; * 691006b - master commit (12 minutes ago) &lt;2022zimo&gt; 国内与国外项目托管平台介绍使用github创建仓库 https://github.com/ SSH与GITHUB远程无密码连接生成秘钥 使用 ssh 连接 Github 发送指令更加安全可靠，也可以免掉每次输入密码的困扰。 在命令行中输入以下代码（windows 用户使用 Git Bash） // ssh-keygen -t rsa 一直按回车键直到结束。系统会在~/.ssh 目录中生成 id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub。 打开 id_rsa.pub,复制密钥，点击github头像，再点击设置 点击new ssh key 向 GitHub 添加秘钥 点击 New SSH key 按钮，添加上面生成的 id_rsa.pub 公钥内容。 然后就能使用ssh链接直接拉取代码文件了。 git clone git@github.com:wuzimo666/demo.git cd demo // 拉取到本地后，假如你新提交了文件,这时文件还在本地 touch zimo.zimo.com git add . git commit -m 'test' // 当你想提交给远程，此时需要使用： git push 此时发现远程仓库中多了刚才提交的文件 本地版本使用remote与GITHUB关联// github新建一个仓库zimo mkdir test cd test git init subl README.MD // 内容随意 git add . git commit -m 'first commit' subl README.MD // 打开readme将以下代码写入 git remote add origin git@github.com:wuzimo666/zimo.git // 添加远程仓库与远程进行关联，可以像服务器推送代码 git remote add origin git@github.com:wuzimo666/zimo.git （自己的ssh仓库地址） git remote -v // 查看远程仓库 git push -u origin master // 推送数据到远程仓库 // 此时刷新github仓库可以看到有README.MD文件 本地分支与github远程分支同步// 接上边，当前能够看到仓库只有一个master分支 git branch -a // 查看远程分支，远程分支会用红色表示出来 // 在本地新建一个分支并切换 ask git checkout -b ask touch ask.html git add . git commit -m 'ask commit' git push // 此时会出现错误 （大意是：当前的分支没有与远程的分支进行关联） 可以使用以下代码： git push --set-upstream origin ask // 此时仓库中能够看到多了一个ask分支 新入职员工参与项目开发时分支使用// 场景：公司当前项目有个功能正在开发，新建了一个ask分支，我新来公司，经理也把我归纳到该开发小组里。所以我需要将代码拉到我的电脑里 // 来到根目录 克隆仓库里代码 git clone git@github.com:wuzimo666/zimo.git cd zimo git branch // 可以看到当前在且仅有master分支 git branch -a git pull origin ask:ask // 请求远程，把ask分支请求到本地里，因为本地目前是master分支 git checkout ask // 此时就把需要开发的ask分支拉取到本地了 // 模拟开发工作 // 创建文件 touch index.php touch hello.asp git add . git commit -m 'zimo first commit' git push // 此时会出现错误 （大意是：当前的分支没有与远程的分支进行关联） 可以使用以下代码： git push --set-upstream origin ask // 此时仓库中ask分支能够看到多了俩文件： index.php hello.asp github远程分支的合并// 当前功能开发完成，线上需要把ask分支合并到master，然后删除ask分支 git checkout master git pull // 把master更改成最新的状态 git checkout ask git rebase master // 将ask分支的起始点移动到master的最新点上 git checkout master git merge ask git push // 推送到远程 git branch --merged // 查看合并的分支 远程分支删除操作// 接上方 直接使用 git push origin --delete ask git branch -a git branch -d ask // 删除本地的ask分支 git branch 自动部署之流程分析与创建WEB站点github服务器 -------- 运行网站代码的服务器 \\ \\ 本地生产的代码 GITHUB自动部署到WEB服务器","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"GIT","slug":"GIT","permalink":"https://wuzimo233.github.io/tags/GIT/"}]},{"title":"微信小程序商城项目","slug":"16-小程序商城项目","date":"2022-07-25T07:30:00.000Z","updated":"2022-07-25T07:27:40.191Z","comments":true,"path":"posts/17.html","link":"","permalink":"https://wuzimo233.github.io/posts/17.html","excerpt":"","text":"准备工具篇 下载 HBuilder https://www.dcloud.io/index.html 安装所有插件 下载微信开发者工具 https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 注册并登录微信公众平台：https://mp.weixin.qq.com/ 获取 AppID(小程序ID) 前言生成小程序以及要跳过的坑 生成小程序时不能用ID选择器，用class uniapp没有router路由 小程序生命周期函数（比如onload）不能用在子组件里面，而是用在父组件里面 小程序没有 window对象，包括没有 document… 等节点操作 （例如：document.getElementById() 。。。） 搭建项目主界面配置HBuilder新建默认模板项目，运行到小程序模拟器微信开发者工具，同时打开微信开发者工具的设置-安全设置-开启服务端口。 配置主界面下方四个tab栏： 将准备好的素材文件夹 static 覆盖到项目根目录， 在pages下新建 sort（分类）、shopping（购物车）、my（我的）三个文件夹，并都在内部创建子vue文件， 接着在pages.json文件配置底部导航栏，代码如下： { \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages { // 展示用户初次进入的页面 \"path\": \"pages/index/index\", \"style\": { \"navigationBarTitleText\": \"首页\", \"navigationBarBackgroundColor\":\"#fe0024\", \"navigationBarTextStyle\":\"white\" } }, { \"path\": \"pages/search/search\", \"style\": { \"navigationBarTitleText\": \"搜索\" } }, { \"path\": \"pages/sort/sort\", \"style\": { \"navigationBarTitleText\": \"分类\" } }, { \"path\": \"pages/shopping/shopping\", \"style\": { \"navigationBarTitleText\": \"购物车\" } }, { \"path\": \"pages/my/my\", \"style\": { \"navigationBarTitleText\": \"个人中心\" } } ], // globalStyle 用于设置应用的状态栏、导航条、标题、窗口背景色等。 \"globalStyle\": { \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"uni-app\", \"navigationBarBackgroundColor\": \"#F8F8F8\", \"backgroundColor\": \"#F8F8F8\" }, // 如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定一级导航栏， // 以及 tab 切换时显示的对应页 \"tabBar\": { \"color\": \"#333333\", \"selectedColor\": \"#8fc0ff\", \"backgroundColor\": \"#ffffff\", \"borderStyle\": \"black\", \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./static/tab/tab-a.png\", \"selectedIconPath\": \"./static/tab/tab-b.png\" }, { \"pagePath\": \"pages/sort/sort\", \"text\": \"分类\", \"iconPath\": \"./static/tab/tab-c.png\", \"selectedIconPath\": \"./static/tab/tab-d.png\" }, { \"pagePath\": \"pages/shopping/shopping\", \"text\": \"购物车\", \"iconPath\": \"./static/tab/tab-e.png\", \"selectedIconPath\": \"./static/tab/tab-f.png\" }, { \"pagePath\": \"pages/my/my\", \"text\": \"我的\", \"iconPath\": \"./static/tab/tab-g.png\", \"selectedIconPath\": \"./static/tab/tab-h.png\" } ] } } 首页组件拆分在pages/index下新建文件夹‘sonzjijian’ ，依次新建 search.vue、swipers.vue、purchase.vue、list.vue等文件，首页下方是动态的加载效果所以考虑引用公共组件 ，即在pages下新建comonents文件夹，内部新建card.vue // 引入组件 （首页从上至下排序） 搜索 search.vue 轮播 swipers.vue 抢购 purchase.vue 天猫榜单 list.vue 引入公用组件 --懒加载卡片 card.vue 在pages/index/index.vue里引入所有子组件 &lt;template&gt; &lt;view &gt; &lt;!-- 搜索 --&gt; &lt;Search&gt;&lt;/Search&gt; &lt;!-- 轮播图 --&gt; &lt;Swipers&gt;&lt;/Swipers&gt; &lt;!-- 抢购 --&gt; &lt;Purchase &gt;&lt;/Purchase&gt; &lt;!-- 榜单 --&gt; &lt;List &gt;&lt;/List&gt; &lt;!-- 卡片流 懒加载卡片--&gt; &lt;Card &gt;&lt;/Card&gt; &lt;/view&gt; &lt;/template&gt; 。。。 // 引入组件 // 搜索 import Search from './sonzhujian/search.vue' // 轮播 import Swipers from './sonzhujian/swipers.vue' // 抢购 import Purchase from './sonzhujian/purchase.vue' // 天猫榜单 import List from './sonzhujian/list.vue' // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' export default { components:{ Search,Swipers,Purchase,List,Card }, } 完成搜索组件展示关于upx单位： uni-app 使用 upx 作为默认尺寸单位， upx 是相对于基准宽度的单位，可以根据屏幕宽度进行自适应。uni-app 规定屏幕基准宽度750upx。 &lt;template&gt; &lt;!-- 首页搜索区域 --&gt; &lt;view class=\"search-view\"&gt; &lt;view class=\"search-men\"&gt; &lt;!-- uniapp 不需要。。/ 可以直接输入文件夹名字查找--&gt; &lt;image src=\"/static/search/logo.png\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"search-ing\"&gt; &lt;image src=\"/static/search/sousuo.png\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;input type=\"text\" placeholder=\"搜索喜欢的内容\" disabled /&gt; &lt;/view&gt; &lt;view class=\"search-saoma\"&gt; &lt;image src=\"/static/search/saoma.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;style scoped&gt; /* scoped css样式仅在当前文件生效*/ .search-view { height: 100upx; background: #fe001d; display: flex; justify-content: space-between; align-items: center; } .search-view image { width: 50upx; height: 50upx; } .search-ing { background: #ffffff; height: 70upx; border-radius: 50upx; display: flex; flex-direction: row; flex: 1; position: relative; margin-right: 30upx; } .search-ing input { height: 70upx; line-height: 70upx; width: 100%; font-size: 30upx; color: #b2b2b2; padding-left: 80upx; } .search-ing image { width: 35upx; height: 35upx; position: absolute; left: 30upx; align-self: center; } .search-saoma { margin-right: 30upx; } .search-men { width: 50upx; height: 50upx; padding: 0 20upx; } &lt;/style&gt; 自定义轮播展示与请求轮播数据使用 swiper 组件 请求轮播数据完成数据渲染 打开项目接口文档拿到 首页轮播的接口地址 &lt;template&gt; &lt;view class=\"swiper-top\"&gt; &lt;!-- @change 事件--&gt; &lt;swiper :autoplay=\"true\" :circular=\"true\" :interval=\"2000\" :duration=\"1000\" @change=\"swiperFun()\"&gt; &lt;!-- 每个swiper-item 都是独立的会滑动板块 是需要要遍历的整体 --&gt; &lt;block v-for=\"(item,index) in bannerdata\" :key=\"index\"&gt; &lt;swiper-item&gt; &lt;view class=\"swiper-item\"&gt; &lt;!-- mode 图片裁剪、缩放的模式 --&gt; &lt;img :src=item.image mode=\"aspectFill\"&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;!-- 指示点 --&gt; &lt;view class=\"instruct-view\"&gt; &lt;block v-for=\"(item,index) in bannerdata\" :key=\"index\"&gt; &lt;!-- 小方块颜色动态的跟随背景图变化而变化 num默认0，即让下标为0的第一个方块套上了该class属性， activee选择器生效的前提是value值为真 想让方块颜色跟随背景图变化需要找到滑动事件： current --当前所在滑块的index @change --current改变时会触发 change 事件， --&gt; &lt;view class=\"instruct\" :class=\"{active:index == num}\"&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { // 指示方块的下标值等于num num:0, bannerdata:[] }; }, methods: { banner(){ uni.request({ url:'https://meituan.thexxdd.cn/api/getbanner', methods:'GET', success:(res)=&gt;{ console.log(res) this.bannerdata = res.data.data }, fail:(err)=&gt;{ console.log(err) } }) } // 使用swiper自带的@change事件 --滑块滑动时的触发事件 它接收一个参数 每次滑动后current值会增加 而ecurrent的值和index的值是相等的 swiperFun(e){ // console.log(e.detail.current); this.num = e.detail.current } }, }; &lt;/script&gt; &lt;style scoped&gt; .swiper-top { height: 250upx; margin: 20upx 10upx; border-radius: 10upx; position: relative; } swiper { height: 250upx !important; background: yellow; border-radius: 10upx; overflow: hidden; } .swiper-item { height: 250upx !important; overflow: hidden; } .swiper-item image { width: 100%; height: 250upx !important; border-radius: 10upx; } /* 指示点 */ .instruct-view { display: flex; justify-content: center; position: absolute; bottom: 10upx; left: 0; width: 100%; } .instruct { background: #4e90a6; height: 10upx; width: 40upx; border-radius: 50upx; margin: 0 10upx; } .active { background: #ffffff !important; } &lt;/style&gt; class封装request请求原因：很多页面都需要发起请求，即需要使用uni.request（），那么就比较麻烦。 uni.request({ url:'', methods:'', success:(res)=&gt;{ console.log(res) }, fail:(err)=&gt;{ console.log(err) } }) 如果将其抽出封装成公用的方法或者类就很方便了。 项目根目录下新建api文件夹，其下再建立api.js、request.js 封装请求接口在request.js里放置所有的请求接口， // 该文件用于写请求地址 const url = 'https://meituan.thexxdd.cn/api/' // 使用面向对象class方法创造 urls类 const urls = class { //constructor 构造方法 --可以从别的页面传值过来 接收值 constructor(){ } // static：静态方法 --直接使用类来调用（即 urls.m() 就可以调用），不是静态方法的话需要实例化类 也就是new // 存放所有的方法 static m(){ // 首页轮播图 --使用es6的模板字符串方法拼接 let bannerget = `${url}getbanner` // 导出对象 return { bannerget, } } } export default urls 封装请求方式在api.js中作request请求 // request 该文件用于 写请求方法 const request = class { // 参数url是request.js暴露出的url // 参数data是post请求传递的值 constructor(url,arg) { this.url = url; this.arg = arg; } // 封装 post请求 modepost() { return new Promise((resolve,reject) =&gt; { uni.request({ url:this.url, method:'POST', data:this.arg, }).then(res =&gt; { resolve(res[1].data); }).then(err =&gt;{ reject('出错了'); }) }) } // 封装 get请求 modeget() { return new Promise((resolve,reject) =&gt; { uni.request({ url:this.url, method:'GET', }).then(res =&gt; { resolve(res[1].data); }).then(err =&gt;{ reject('出错了'); }) }) } } export default request 在swiper组件此时可以这样使用 &lt;script&gt; import urls from '../../../api/request.js' import request from '../../../api/api.js' export default { data() { return { // 指示方块的下标值等于num num:0, bannerdata:[] }; }, methods: { banner() { //返回新的promise实例对象 new request(urls.m().bannerget).modeget() .then( res =&gt; { console.log(res) this.bannerdata = res.data }) .catch( err =&gt; { console.log(err) }) }, swiperFun(e){ this.num = e.detail.current } }, created(){ //加载完后直接调用banner方法 this.banner() } }; &lt;/script&gt; 还能使用try catch 方法 methods: { async banner() { try { //返回新的promise实例对象用await接收到结果(记得方法前加上axync) 当返回错误的时候会进入 catch里 let data = await new request(urls.m().bannerget).modeget() console.log(data) this.bannerdata = data.data }catch(e){ } }, 因为每个页面几乎都有请求发送，每次引入api和request就很麻烦，所以挂载到全局 main.js //main.js中引入api和request // 引入请求地址 import urls from './api/request.js' Vue.prototype.Urls = urls // 引入请求方法 import request from './api/api.js' Vue.prototype.Request = request //此时的swiper组件中就这样发送请求了 methods: { async banner() { try { //返回新的promise实例对象用await接收到结果(记得方法前加上axync) 当返回错误的时候会进入 catch里 let data = await new this.Request(this.Urls.m().bannerget).modeget() console.log(data) this.bannerdata = data.data }catch(e){ } }, 统一请求接口到父组件每个页面都再调用请求也很麻烦，所以将所有请求放到父组件统一发送，父组件将接口响应的数据传递给子组件 &lt;template&gt; &lt;view &gt; &lt;!-- 搜索 --&gt; &lt;Search&gt;&lt;/Search&gt; &lt;!-- 轮播图 --&gt; &lt;Swipers :bannerdata=\"bannerdata\"&gt;&lt;/Swipers&gt; &lt;!-- 抢购 --&gt; &lt;Purchase&gt;&lt;/Purchase&gt; &lt;!-- 榜单 --&gt; &lt;List&gt;&lt;/List&gt; &lt;!-- 卡片流 懒加载卡片--&gt; &lt;Card&gt;&lt;/Card&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入组件 // 搜索 import Search from './sonzhujian/search.vue' // 轮播 import Swipers from './sonzhujian/swipers.vue' // 抢购 import Purchase from './sonzhujian/purchase.vue' // 天猫榜单 import List from './sonzhujian/list.vue' // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' export default { components:{ Search,Swipers,Purchase,List,Card }, data(){ return { bannerdata:[], recomdata:[], billdata:[], commdata:[], pageid:0, } }, methods:{ // 把请求统一放到父组件 async indexRequest() { // 轮播 let banner = new this.Request(this.Urls.m().bannerget).modeget() try { // 同时并发请求：Promise.all([]) 里边的所有请求全部得到结果后才会返回 let res = await Promise.all([banner]) console.log(res); // 轮播 this.bannerdata = res[0].data }catch(e) { } }, // 上拉加载所得数据 }, mounted() { this.indexRequest() }, } &lt;/script&gt; &lt;style&gt; /* 全局背景色 */ page { background: #f4f4f4; } &lt;/style&gt; 子组件 swiper.vue 通过props接收父组件传递来的数据 export default { // bannerdata是父组件 通过ref传递进来的数据 类型是Array props:{ bannerdata:Array, }, } 完成推荐抢购商品组件数据在request.js中添加抢购商品接口 // 该文件用于写请求地址 // static：静态方法 --直接使用类来调用（即 urls.m() 就可以调用），不是静态方法的话需要实例化类 也就是new // 存放所有的方法 static m(){ // 首页轮播图 --使用es6的模板字符串方法拼接 let bannerget = `${url}getbanner` // 推荐抢购商品 let getrecommurl = `${url}recom` // 导出对象 return { bannerget, getrecommurl, } } 在index/index.vue中使用，并将recomdata数据通过ref传递到子组件 methods:{ // 把请求统一放到父组件 async indexRequest() { // 轮播 let banner = new this.Request(this.Urls.m().bannerget).modeget() // 推荐抢购商品 let recomm = new this.Request(this.Urls.m().getrecommurl).modeget() try { // 同时并发请求：Promise.all([]) let res = await Promise.all([banner,recomm]) console.log(res); // 轮播 this.bannerdata = res[0].data // 快抢购 this.recomdata = res[1].data }catch(e) { } }, }, mounted() { this.indexRequest() }, } 子组件purchase.vue代码如下： &lt;template&gt; &lt;!-- 抢购组件 --&gt; &lt;view class=\"Purchase-view\"&gt; &lt;view class=\"pur-flex\"&gt; &lt;!-- 左边 --&gt; &lt;view class=\"pur-left widthing\"&gt; &lt;view class=\"pur-top\"&gt; &lt;text&gt;{{recomdata[0].title}}&lt;/text&gt; &lt;text&gt;{{recomdata[0].lable}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"pur-img\"&gt; &lt;block v-for=\"(item,index) in recomdata[0].image\" :key=\"index\"&gt; &lt;view&gt;&lt;img :src=\"item.img\" alt=\"\"&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 右边 --&gt; &lt;view class=\"pur-right widthing\"&gt; &lt;!-- 上 --&gt; &lt;view class=\"pur-right-top\"&gt; &lt;view class=\"pur-top two\"&gt; &lt;text&gt;{{recomdata[1].title}}&lt;/text&gt; &lt;text&gt;{{recomdata[1].lable}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"pur-right-img\"&gt; &lt;block v-for=\"(item,index) in recomdata[1].image\" :key=\"index\"&gt; &lt;view&gt;&lt;img :src=\"item.img\" alt=\"\"&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 下 --&gt; &lt;view&gt; &lt;view class=\"pur-top three\"&gt; &lt;text&gt;{{recomdata[2].title}}&lt;/text&gt; &lt;text&gt;{{recomdata[2].lable}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"pur-right-img\"&gt; &lt;block v-for=\"(item,index) in recomdata[2].image\" :key=\"index\"&gt; &lt;view&gt;&lt;img :src=\"item.img\" alt=\"\"&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { recomdata: Array, }, }; &lt;/script&gt; &lt;style scoped&gt; .Purchase-view { background: #ffffff; margin: 0 10upx; border-radius: 10upx; } .pur-top { display: flex; align-items: center; height: 50upx; padding-left: 9upx; } .pur-top text:nth-child(1) { font-size: 30upx; font-weight: bold; } .pur-top text:nth-child(2) { font-size: 24upx; color: red; padding-left: 10upx; } /* 图片 */ .pur-img { display: flex; flex-wrap: wrap; } .pur-img view { width: 50%; height: 150upx; display: flex; align-items: center; justify-content: center; } .pur-img image { width: 120upx; height: 120upx !important; } .pur-img view:nth-child(n + 3) { padding-top: 50upx; } .pur-right-img { display: flex; align-items: center; } .pur-right-img image { width: 120upx; height: 120upx; } .pur-right-img view { width: 50%; height: 150upx; display: flex; align-items: center; justify-content: center; } .pur-right { display: flex; flex-wrap: wrap; } .pur-right view { width: 100%; } .pur-flex { display: flex; align-items: center; } .widthing { width: 50%; box-sizing: border-box; } .pur-left { border-right: 1rpx solid #f1f1f1; } .pur-right-top { border-bottom: 1rpx solid #f1f1f1; } .two text:nth-child(2) { color: #ff7594 !important; } .three text:nth-child(2) { color: #96b06f !important; } &lt;/style&gt; 完成天猫榜单组件数据在request.js中添加抢购商品接口 // 存放所有的方法 static m(){ // 首页轮播图 --使用es6的模板字符串方法拼接 let bannerget = `${url}getbanner` // 推荐抢购商品 let getrecommurl = `${url}recom` // 天猫榜单 let billboardurl = `${url}billboard` // 导出对象 return { bannerget, getrecommurl, billboardurl, } } 在index/index.vue中使用，并将billdata数据通过ref传递到子组件 methods:{ // 把请求统一放到父组件 async indexRequest() { // 轮播 let banner = new this.Request(this.Urls.m().bannerget).modeget() // 推荐抢购商品 let recomm = new this.Request(this.Urls.m().getrecommurl).modeget() // 天猫榜单 let billboard = new this.Request(this.Urls.m().billboardurl).modeget() try { // 同时并发请求：Promise.all([]) let res = await Promise.all([banner,recomm,billboard]) console.log(res); // 轮播 this.bannerdata = res[0].data // 快抢购 this.recomdata = res[1].data // 天猫榜单 this.billdata = res[2].data }catch(e) { } }, }, mounted() { this.indexRequest() }, } 子组件list.vue代码如下: &lt;template&gt; &lt;view class=\"list-top\"&gt; &lt;view class=\"list-text\"&gt; &lt;text&gt;&lt;/text&gt; &lt;text&gt;天猫榜单&lt;/text&gt; &lt;text&gt;闭着眼睛跟榜买&lt;/text&gt; &lt;/view&gt; &lt;view class=\"list-view\"&gt; &lt;block v-for=\"(item, index) in billdata\" :key=\"index\"&gt; &lt;view class=\"menb\"&gt; &lt;image :src=\"item.image\" mode=\"aspectFill\" /&gt; &lt;text&gt;{{ item.title }}&lt;/text&gt; &lt;text&gt;{{ item.want }}人想要&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { billdata: Array }, }; &lt;/script&gt; &lt;style scoped&gt; /* /less */ .list-top { margin: 20upx 10upx; } .list-text { height: 70rpx; display: flex; align-items: center; } .list-text text:nth-child(1) { background: #2c405a; height: 35upx; width: 10upx; } .list-text text:nth-child(2) { font-size: 30upx; font-weight: bold; padding-left: 5upx; } .list-text text:nth-child(3) { font-size: 24upx; color: #999999; padding-left: 10upx; } .list-view { height: 400rpx; background: #ffffff; border-radius: 9rpx; display: flex; flex-wrap: wrap; } .menb text:nth-child(2) { font-size: 28rpx; } .menb text:nth-child(3) { font-size: 20rpx; color: #fe0024; } .menb image { width: 80rpx; height: 100rpx !important; padding-bottom: 4rpx; } .menb { width: 33.333%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding-bottom: 2rpx; box-sizing: border-box; } .list-view view:nth-child(-n + 3) { border-bottom: 1rpx solid #f1f1f1; } .list-view view:nth-child(2) { border-left: 1rpx solid #f1f1f1; border-right: 1rpx solid #f1f1f1; } .list-view view:nth-child(5) { border-left: 1rpx solid #f1f1f1; border-right: 1rpx solid #f1f1f1; } &lt;/style&gt; 封装并请求卡片流商品组件因为该组件的（流动布局）功能在其他页面也会用到，所以封装到公共组件文件夹去，即在pages下新建comonents文件夹，再新建card.vue文件 在request.js中添加卡片商品流以及上拉加载接口 由于接口文档显示get请求需要携带?query参数， // 存放所有的方法 static m(){ // 首页轮播图 --使用es6的模板字符串方法拼接 let bannerget = `${url}getbanner` // 推荐抢购商品 let getrecommurl = `${url}recom` // 天猫榜单 let billboardurl = `${url}billboard` // 卡片商品流以及上拉加载 let commodcradurl = `${url}commodcrad` // 导出对象 return { bannerget, getrecommurl, billboardurl, commodcradurl, searchurl, } } 在index/index.vue中使用，并将recomdata数据通过ref传递到子组件 。。。。。。 // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' // 把请求统一放到父组件 menthods:{ async indexRequest() { // 轮播 let banner = new this.Request(this.Urls.m().bannerget).modeget() // 推荐抢购商品 let recomm = new this.Request(this.Urls.m().getrecommurl).modeget() // 天猫榜单 let billboard = new this.Request(this.Urls.m().billboardurl).modeget() // 卡片商品流以及上拉加载 （！！注意需要携带参数） let commodcrad = new this.Request(this.Urls.m().commodcradurl + '?page=' + this.pageid).modeget() try { // 同时并发请求：Promise.all([]) let res = await Promise.all([banner,recomm,billboard,commodcrad]) console.log(res); // 轮播 this.bannerdata = res[0].data // 快抢购 this.recomdata = res[1].data // 天猫榜单 this.billdata = res[2].data // 卡片商品流 this.commdata = res[3].data }catch(e) { } }, }, } mounted() { this.indexRequest() }, 公用组件Card.vue代码如下: &lt;template&gt; &lt;view class=\"comm-view\"&gt; &lt;block v-for=\"(item,index) in commdata\" :key=\"index\"&gt; &lt;view class=\"comm-card\"&gt; &lt;view class=\"comm-img\"&gt;&lt;image :src=\"item.image\" mode=\"aspectFill\" /&gt;&lt;/view&gt; &lt;view class=\"comm-title\"&gt;&lt;text&gt;{{item.title}}&lt;/text&gt;&lt;/view&gt; &lt;view class=\"comm-left\"&gt; &lt;text&gt;{{item.freight}}&lt;/text&gt; &lt;text&gt;预计{{item.Duration}}h发货&lt;/text&gt; &lt;/view&gt; &lt;view class=\"comm-right\"&gt;{{item.Price}}￥&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { // props接收父组件传递的数组对象 props:{commdata:Array}, methods: {} }; &lt;/script&gt; &lt;style scoped&gt; .comm-img { height: 450rpx; } .comm-img image { width: 100%; height: 450rpx; border-top-left-radius: 10upx; border-top-right-radius: 10upx; } .comm-card { width: calc(50% - 5rpx * 2); margin: 5rpx; background: #ffffff; border-radius: 10upx; } .comm-title { font-size: 28rpx; height: 100rpx; line-height: 50rpx; padding-left: 10rpx; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; // 控制多行的行数 -webkit-box-orient: vertical; } .comm-left { font-size: 20rpx; text-align: center; display: flex; align-items: center; padding-left: 10rpx; height: 50rpx; } .comm-left text { padding: 3rpx 4rpx; border-radius: 10rpx; } .comm-left text:nth-child(1) { border: 2rpx solid #1183e6; margin-right: 10rpx; color: #1183e6; } .comm-left text:nth-child(2) { border: 2rpx solid red; color: red; } .comm-right { font-size: 30rpx; font-weight: bold; color: #f3022f; height: 50rpx; line-height: 50rpx; padding-left: 10rpx; } .comm-view { display: flex; flex-wrap: wrap; padding: 0 5rpx; } &lt;/style&gt; 完成上拉加载上拉加载时，一般会加载全部服务器返回的数据，一般用户不会看完那么多的数据，体验感不好，因此一般是仅显示前几条数据，其他数据下拉屏幕获取 首先先封装上拉加载时执行的函数 **pullup()**， 使用uni-app 生命周期 onReachBottom 函数来操作 – 页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。 在index.vue中添加如下代码 // 上拉加载所得数据 methods:{ async pullup() { // 卡片流商品 try { let commodcrad = await new this.Request(this.Urls.m().commodcradurl + '?page=' + this.pageid).modeget() console.log(commodcrad); // 把之前得到的数据和上拉得到的数据作数组合并 ! ES6的数组合并方法 this.commdata = [...this.commdata,...commodcrad.data] }catch(e) { } } }, // 页面处理事件--上拉加载更多 onReachBottom () { this.pageid ++; this.pullup() } 封装上拉提示用户在上拉的时候，应该给出一个提示比如：正在加载中… 或者到底了… 因为该功能属于公共的，所以考虑封装到公共commponents文件夹里 新建loading-men.vue文件 &lt;template&gt; &lt;!-- 上拉加载组件 --&gt; &lt;!-- 默认是隐藏的该组件，当上拉加载时，父组件传递的对象参数 到loAD() 中，解构后让 v-if为真 组件显示--&gt; &lt;view class=\"loading-men\" v-if=\"loading\"&gt; &lt;!-- 没数据后图片会隐藏 控制图片的代码是写在index.vue的pullup()方法里 --&gt; &lt;image src=\"/static/loading/loadtmall.gif\" mode=\"widthFix\" v-if=\"picture\"&gt;&lt;/image&gt; &lt;text&gt;{{tips}}&lt;/text&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { loading: false, picture: true, tips: '玩命加载中' }; }, methods: { loAd(value) { // 接收父组件传递过来的 whether 数据 其他俩值是默认值 let { whether = false, picture = true, tips = '玩命加载中'} = value; // 下方数据的数据会自动获取上边的解构的对象值，如果父组件没有传递，就取默认值 this.loading = whether; this.picture = picture; this.tips = tips; } } } &lt;/script&gt; &lt;style scoped&gt; .loading-men { width: 200rpx; height: 100upx; font-size: 20rpx; color: #a7a7a7; margin: 0 auto; display: flex; flex-direction: column; justify-content: center; align-items: center; } .loading-men image { width: 60rpx; height: 80upx; display: block; } &lt;/style&gt; 因为用到的地方较多，所以引入到main.js // 引入上拉加载组件 import loadn from 'pages/commponents/loading-men.vue' // 注册到组件 Vue.component('loader-on',loadn) -------------------------------------------------------- // 然后在index.vue中引入组件loader-on组件 &lt;!-- 上拉加载 --&gt; &lt;loader-on ref=\"loadon\"&gt;&lt;/loader-on&gt; 同时在index.vue中 pullup() 方法和 onReachBottom() 事件 代码修改如下： // 上拉加载所得数据 async pullup() { // 卡片流商品 try { // 下拉后得到的数据（数组） let commodcrad = await new this.Request(this.Urls.m().commodcradurl + '?page=' + this.pageid).modeget() console.log(commodcrad,'上拉加载的数据'); if(commodcrad.data.length == 0) { // 当没有数据时，通过ref，将下拉加载的图片隐藏 同时调整提示的文字 this.$refs.loadon.loAd({ whether : true, picture :false , tips : '我是有底线的！'}) }else { // 需要把之前得到的数据和上拉得到的数据做数组合并 !! 。。。表示展开 this.commdata = [...this.commdata,...commodcrad.data] } }catch(e) { } } // 页面处理事件--上拉加载更多 // 给子组件传递数据，即让index.vue中调用子组件的方法，考虑使用ref（在组件上添加） --类似传统的document.getElementById() onReachBottom () { this.$refs.loadon.loAd({ whether: true, }) this.pageid ++; this.pullup() } 商品搜索页面因为商品搜索并不是在 index.vue 组件上执行，而是跳转到搜索的功能组件里执行。 因此在 pages **文件夹 新建 **search / search.vue 先在pages.json里配置路径 { \"path\": \"pages/search/search\", \"style\": { \"navigationBarTitleText\": \"搜索\" } }, 在 index / sonzhujian / search.vue 中设置点击input框区域的跳转功能 &lt;view class=\"search-ing\" @click=\"searCh()\"&gt; &lt;image src=\"/static/search/sousuo.png\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;input type=\"text\" placeholder=\"搜索喜欢的内容\" disabled /&gt; &lt;/view&gt; // ... methods:{ searCh (){ // uni.navigateTo 保留当前页面，跳转到目标页面 uni.navigateTo({ url: '../search/search' }); } } 搜索页面布局 &lt;template&gt; &lt;!-- 搜索页面组件 --&gt; &lt;view&gt; &lt;!-- 文本框 和 搜索按钮 --&gt; &lt;view class=\"search-cont\"&gt; &lt;view class=\"search\"&gt; &lt;!-- 使用v-model 获取输入框的值 --&gt; &lt;input type=\"text\" placeholder-class=\"inputclass\" confirm-type=\"搜索\" focus=\"true\" placeholder=\"请输入关键字\" v-model='searchdata' /&gt; &lt;/view&gt; &lt;view class=\"search-code\" &gt;搜索&lt;/view&gt; &lt;/view&gt; &lt;!-- 搜索历史 --&gt; &lt;view class=\"search-history\" v-if=\"ifhistory\"&gt; &lt;!-- 最近搜索 和 删除icon--&gt; &lt;view class=\"search-title\"&gt; &lt;view&gt;最近搜索&lt;/view&gt; &lt;view &gt;&lt;image src=\"/static/search/searchend.svg\" mode=\"widthFix\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 历史关键词 --&gt; &lt;view class=\"menu-block\"&gt; &lt;view&gt;衣服&lt;/view&gt; &lt;view&gt;裤子&lt;/view&gt; &lt;view&gt;女装&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { } &lt;/script&gt; &lt;style scoped&gt; .search { height: 70upx; line-height: 70upx; width: 100%; display: flex; flex-direction: row; background: #FFFFFF; border-radius: 20upx; margin-left: 20upx; } .search input { height: 70upx; line-height: 70upx; width: 100%; font-size: 30upx; color: #666666; padding-left: 30upx; } .search-cont { display: flex; justify-content: space-between; height: 70upx; align-items: center; padding: 30upx 0; background: #f8f8f8; } .search-code { width: 150upx; height: 50upx; text-align: center; font-size: 30upx; } .search-history{margin: 20upx;} .search-title{font-size: 30upx; font-weight: bold; display: flex; justify-content:space-between; align-items: center; height: 60upx; line-height: 60upx;} .search-title image{width: 36upx; height: 36upx; display: block;} .menu-block view { background: #f7f8fa; border-radius: 6upx; font-size: 27upx; color: #292c33; text-align: center; padding: 10upx; margin: 20upx 20upx 0 0; } .menu-block { display: flex; flex-direction: row; justify-content: flex-start; flex-wrap: wrap; } &lt;/style&gt; 历史搜索的功能实现&lt;template&gt; &lt;!-- 搜索页面组件 --&gt; &lt;view&gt; &lt;!-- 文本框 和 搜索按钮 --&gt; &lt;view class=\"search-cont\"&gt; &lt;view class=\"search\"&gt; &lt;!-- 使用v-model 获取输入框的值 @confirm 点击键盘按钮触发事件--&gt; &lt;input type=\"text\" placeholder-class=\"inputclass\" confirm-type=\"搜索\" focus=\"true\" placeholder=\"请输入关键字\" v-model='searchdata' @confirm=\"onKeyInput\"/&gt; &lt;/view&gt; &lt;!-- 给点击搜索绑定点击事件 --&gt; &lt;view class=\"search-code\" @click=\"seArch()\" &gt;搜索&lt;/view&gt; &lt;/view&gt; &lt;!-- 搜索历史 --&gt; &lt;view class=\"search-history\" v-if=\"ifhistory\"&gt; &lt;!-- 最近搜索 和 删除icon--&gt; &lt;view class=\"search-title\"&gt; &lt;view&gt;最近搜索&lt;/view&gt; &lt;view&gt;&lt;image src=\"/static/search/searchend.svg\" mode=\"widthFix\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 历史关键词 --&gt; &lt;view class=\"menu-block\"&gt; &lt;block v-for=\"(item,index) in Storagedata\" :key=\"index\"&gt; &lt;view @click=\"menubtn(item)\"&gt;{{item}}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' // 解构console.log()方便使用 var {log} = console export default { components:{Card}, data () { return { // 存放输入框的值 searchdata:'', // 是否有搜索历史 ifhistory:'false', // 搜索历史数据 Storagedata:'', // 请求页数 pageid:0, // 搜索的结果 commdata:[], // 没有搜索结果 searchno: false, // 最后一次搜索结果 searchkey:'' } }, methods :{ // 点击 搜索按钮 触发搜索功能 seArch() { if(this.searchdata != '') { this.ifhistory = false this.pageid = 0 this.getStorage(this.searchdata) this.searchData(this.searchdata) } }, // 键盘 回车键 触发搜索功能 onKeyInput(e) { let searchkey = e.detail.value // 当文本框不为空时 if(searchkey != '') { this.ifhistory = false this.pageid = 0 this.getStorage(searchkey) this.searchData(searchkey) } }, // 在去请求接口之前，要把搜索结果先存到 本地缓存，然后放到最近搜索这里 （接收的参数是回车事件获取到的 value） getStorage(searchkey) { // 存之前先取之前用户搜索的历史 --key值随意取名 如果没有就取空数组表示本地缓存没有数据 let searcharray = uni.getStorageSync('search_key') || [] // 存到 searcharray 数组前面 searcharray.unshift(searchkey) // 存 uni.setStorageSync(KEY,DATA) key是名称 DATA是内容 uni.setStorageSync('search_key',searcharray) // 取 uni.getStorageSync(KEY) }, // 取出本地缓存的搜索历史 // uni.setStorage(OBJECT) 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 setStorage() { let setdata = uni.getStorageSync('search_key') // 1.判断缓存里有没有重复的关键词 --有就 数组去重 // 使用的是ES6 Set方法 let setdataarr = Array.from(new Set(setdata)) // 2.判断缓存里有没有数据 if(setdataarr.length == 0) { // 隐藏搜索历史 this.ifhistory = false }else { this.Storagedata = setdataarr this.ifhistory = true } }, }, created() { this.setStorage() }, } &lt;/script&gt; //..... 商品搜索请求接口先添加清除历史功能 &lt;!-- 最近搜索 和 删除icon--&gt; &lt;view class=\"search-title\"&gt; &lt;view&gt;最近搜索&lt;/view&gt; &lt;!-- 给图标添加点击事件 removeStorage --&gt; &lt;view @click=\"removeStorage()\"&gt;&lt;image src=\"/static/search/searchend.svg\" mode=\"widthFix\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; // 清空本地缓存 即清空搜索历史 removeStorage() { uni.removeStorageSync('search_key'); // 在调用一下setStorage方法，主要目的是将最近搜索给隐藏 this.setStorage() }, 公用的请求接口方法 // 公用的请求接口方法 搜索商品 async searchData(searchkey,idn='001'){ this.searchkey = searchkey // 请求的参数 const keys = '?keyword=' + searchkey + '&amp;' + 'page=' + this.pageid try{ let searchdata = await new this.Request(this.Urls.m().searchurl + keys).modeget() // 判断 if(idn == '002'){ // 上拉加载 if(searchdata.data.length == 0) { this.$refs.loadon.loAd({ whether : true, picture :false , tips : '我是有底线的！'}) }else { this.commdata = [...this.commdata,...searchdata.data] } }else { // 隐藏 this.$refs.loadon.loAd({whether : false}) // 判断是否有数据 没有就展示提示 if(searchdata.data.length == 0) { this.searchno = true }else { // 有数据的话就赋值给data里 不展示提示 this.commdata = searchdata.data this.searchno = false } } }catch(e){ //TODO handle the exception } }, 引入style文件夹里的公共样式 在 main.js // 提示框的css样式 import './style/style.css' 最终代码如下: &lt;template&gt; &lt;!-- 搜索页面组件 --&gt; &lt;view&gt; &lt;!-- 文本框 和 搜索按钮 --&gt; &lt;view class=\"search-cont\"&gt; &lt;view class=\"search\"&gt; &lt;!-- 使用v-model 获取输入框的值 @confirm 点击键盘按钮触发事件--&gt; &lt;input type=\"text\" placeholder-class=\"inputclass\" confirm-type=\"搜索\" focus=\"true\" placeholder=\"请输入关键字\" v-model='searchdata' @confirm=\"onKeyInput\"/&gt; &lt;/view&gt; &lt;!-- 给点击搜索绑定点击事件 --&gt; &lt;view class=\"search-code\" @click=\"seArch()\" &gt;搜索&lt;/view&gt; &lt;/view&gt; &lt;!-- 搜索历史 --&gt; &lt;view class=\"search-history\" v-if=\"ifhistory\"&gt; &lt;!-- 最近搜索 和 删除icon--&gt; &lt;view class=\"search-title\"&gt; &lt;view&gt;最近搜索&lt;/view&gt; &lt;view @click=\"removeStorage()\"&gt;&lt;image src=\"/static/search/searchend.svg\" mode=\"widthFix\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 历史关键词 --&gt; &lt;view class=\"menu-block\"&gt; &lt;block v-for=\"(item,index) in Storagedata\" :key=\"index\"&gt; &lt;view @click=\"menubtn(item)\"&gt;{{item}}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 展示搜索结果 --&gt; &lt;Card :commdata=\"commdata\" v-if=\"!searchno\"&gt;&lt;/Card&gt; &lt;!-- 没有搜索结果 --&gt; &lt;view class=\"empty-cart\" v-if=\"searchno\"&gt; &lt;image src=\"/static/search/sousuono.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;抱歉！暂无相关商品&lt;/text&gt; &lt;/view&gt; &lt;!-- 上拉加载 --&gt; &lt;loader-on ref=\"loadon\"&gt;&lt;/loader-on&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' // 解构console.log()方便使用 var {log} = console export default { components:{Card}, data () { return { // 存放输入框的值 searchdata:'', // 是否有搜索历史 ifhistory:'false', // 搜索历史数据 Storagedata:'', // 请求页数 pageid:0, // 搜索的结果 commdata:[], // 没有搜索结果 searchno: false, // 搜索值最后一次搜索结果 searchkey:'' } }, methods :{ // 点击 搜索按钮 触发搜索功能 seArch() { if(this.searchdata != '') { this.ifhistory = false this.pageid = 0 this.getStorage(this.searchdata) this.searchData(this.searchdata) } }, // 键盘 回车键 触发搜索功能 onKeyInput(e) { let searchkey = e.detail.value // 当文本框不为空时 if(searchkey != '') { this.ifhistory = false this.pageid = 0 this.getStorage(searchkey) this.searchData(searchkey) } }, // 在去请求接口之前，要把搜索结果先存到 本地缓存，然后放到最近搜索这里 （接收的参数是回车事件获取到的 value） getStorage(searchkey) { // 存之前先取之前用户搜索的历史 --key值随意取名 如果没有就取空数组表示本地缓存没有数据 let searcharray = uni.getStorageSync('search_key') || [] // 存到 searcharray 数组前面 searcharray.unshift(searchkey) // 存 uni.setStorageSync(KEY,DATA) key是名称 DATA是内容 uni.setStorageSync('search_key',searcharray) // 取 uni.getStorageSync(KEY) }, // 取出本地缓存的搜索历史 // uni.setStorage(OBJECT) 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 setStorage() { let setdata = uni.getStorageSync('search_key') // 1.判断缓存里有没有重复的关键词 --有就 数组去重 // 使用的是ES6 Set方法 let setdataarr = Array.from(new Set(setdata)) // 2.判断缓存里有没有数据 if(setdataarr.length == 0) { // 隐藏搜索历史 this.ifhistory = false }else { this.Storagedata = setdataarr this.ifhistory = true } }, // 清空本地缓存的Storage即清空搜索历史 removeStorage() { uni.removeStorageSync('search_key'); this.setStorage() }, // 搜索历史 menubtn (item) { // 先隐藏搜索历史 this.ifhistory = false this.pageid = 0 // 再发起请求 this.searchData(item) }, // 公用的请求接口方法 搜索商品 给参数传一个值 idn 用于判断触发搜索 async searchData(searchkey,idn='001'){ this.searchkey = searchkey // 请求的参数 const keys = '?keyword=' + searchkey + '&amp;' + 'page=' + this.pageid try{ let searchdata = await new this.Request(this.Urls.m().searchurl + keys).modeget() // 判断 if(idn == '002'){ // 上拉加载 if(searchdata.data.length == 0) { this.$refs.loadon.loAd({ whether : true, picture :false , tips : '我是有底线的！'}) }else { this.commdata = [...this.commdata,...searchdata.data] } }else { // 隐藏 this.$refs.loadon.loAd({whether : false}) // 判断是否有数据 没有就展示提示 if(searchdata.data.length == 0) { this.searchno = true }else { // 有数据的话就赋值给data里 不展示提示 this.commdata = searchdata.data this.searchno = false } } }catch(e){ //TODO handle the exception } }, }, created() { this.setStorage() }, // 页面处理事件--上拉加载更多 onReachBottom () { // 显示提示 通过ref 操作dom this.$refs.loadon.loAd({ whether: true, }) this.pageid++ this.searchData(this.searchkey,'002') } } &lt;/script&gt; 商品详情页自定义顶部导航栏在pages文件夹下新建 details.vue文件 pages.json中写入地址 { // 展示用户初次进入的页面 \"path\": \"pages/details/details\", \"style\": { \"navigationBarTitleText\": \"详情页\", \"navigationStyle\": \"custom\" // 文字可以排列到顶部 } }, 获取右上角胶囊按钮的宽高和到边框的距离 // getMenuButtonBoundingClientRect() 本API用于获取小程序下胶囊按钮的布局位置信息（宽高、边距等等），方便开发者布局顶部内容时避开该按钮坐标信息以屏幕左上角为原点。 下方的部分新建sonzujian文件夹下新建top.vue： &lt;template&gt; &lt;view&gt; &lt;view class=\"navs-view\"&gt; &lt;view class=\"navs-image\" :style=\" 'height:'+ tophight.height + 'px;' \"&gt; &lt;image src=\"/static/details/fanhuihei.png\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"navs\"&gt; &lt;block v-for=\"(item,index) in navalue\" :key=\"index\"&gt; &lt;!-- 动态设置 高度 和 行高 与胶囊对齐 同时设置一个底部横线--&gt; &lt;view class=\"navs-nav\" :class=\"{navactivetext:index == num}\" :style=\" 'height:'+ tophight.height + 'px;' + 'line-height:' + tophight.height + 'px;' \" @click=\"navbtn(index)\" &gt;{{item.name}}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;view style=\"width: 20px; padding-right: 20rpx;\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ props:{ // 接收父组件数据 子组件自定义高度 tophight:Object }, data() { return { num:0, navalue: [ { 'name':'商品' }, { 'name':'评价' }, { 'name':'详情' } ] } }, methods:{ // 控制短横线跳转位置 navbtn(index){ this.num = index } } } &lt;/script&gt; &lt;style scoped&gt; .navs-nav{font-size: 30upx; width: 100upx; text-align: center; color: #464230; } .navs-image image{width: 20px; height: 20px;} .navs-image{width: 20px; display: flex; align-items: center; padding-left: 20rpx;} .navs{display: flex; justify-content: center; align-self: center; } .navactivetext{border-bottom: 5upx solid #3d3b32;} .navs-view{display: flex; align-items: center; justify-content: space-between;} &lt;/style&gt; 此时父组件details.vue是这样： &lt;template&gt; &lt;view &gt; &lt;!-- 返回按钮 --&gt; &lt;view class=\"header-fixed backno\" v-show=\"showAbs\"&gt; &lt;!-- 箭头符号设置的动态的高 --&gt; &lt;view class=\"status_bar\" :style=\"'height: '+ tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;view class=\"navs-image\" :style=\"'height: '+ tophight.height + 'px;' \"&gt; &lt;image src=\"/static/details/fanhuibai.jpg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- tab --&gt; &lt;!--子组件 默认不显示出来--&gt; &lt;view class=\"header-fixed backyes\" v-show=\"!showAbs\"&gt; &lt;!-- 放置一个div 撑开到顶部距离 --&gt; &lt;view class=\"status_bar\" :style=\"'height: '+ tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;!-- 引用子组件 且给子组件传递 tophight 子组件里设置高度--&gt; &lt;top :tophight=\"tophight\"&gt;&lt;/top&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import Top from './sonzhujian/top.vue' export default { components:{ Top, }, data(){ return { tophight:{}, // 胶囊按钮的数据 showAbs:true, //控制箭头按钮显示/隐藏 } }, created(){ // 获取胶囊按钮的数据 m包含胶囊按钮的所有信息 this.tophight = uni.getMenuButtonBoundingClientRect() } } &lt;/script&gt; &lt;style scoped&gt; page{background: #f2f2f2;} .header-fixed{ position: fixed; top: 0; left: 0; right: 0; z-index: 2; } .backyes{background: #f8f8f8;} .backno{background: none;} .status_bar { width: 100%; /* background: #007AFF; */ } .navs-image image{width: 28px; height: 28px; border-radius: 50%; } .navs-image{display: flex; align-items: center; padding-left: 20upx; } /* banner部分 */ .imageurl { width: 100%; height: 700upx !important; } swiper { height: 700upx !important; } .swiper-video{height: 700upx; background: #4CD964;} .swiper-video video{width: 100%; height: 700upx;} /* 自定义按钮 */ .video-img image{width: 90upx; height: 90upx; z-index: 999; border: 2px solid #FFFFFF; border-radius: 50%;} .video-img{width: 90upx; height: 90upx; position: absolute; bottom: 0; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%); } .video-btn{height: 700upx; position: relative;} &lt;/style&gt; 滚动监听显示隐藏导航栏首先有滚动监听的方法： onPageScroll ( ) – 监听页面滚动，参数为Object 然后有滚动的淡入淡出效果: opacity属性 此时details.vue文件代码如下： &lt;template&gt; &lt;view &gt; &lt;!-- 返回按钮 --&gt; &lt;view class=\"header-fixed backno\" v-show=\"showAbs\"&gt; &lt;!-- 箭头符号设置的动态的高 --&gt; &lt;view class=\"status_bar\" :style=\"'height: '+ tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;view class=\"navs-image\" :style=\"'height: '+ tophight.height + 'px;' \"&gt; &lt;image src=\"/static/details/fanhuibai.jpg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- tab --&gt; &lt;!--子组件 默认不显示出来 同时透明度值默认是0 --&gt; &lt;view class=\"header-fixed backyes\" v-show=\"!showAbs\" :style=\"{opacity:styleObject}\"&gt; &lt;!-- 放置一个div 撑开到顶部距离 --&gt; &lt;view class=\"status_bar\" :style=\"'height: '+ tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;!-- 引用子组件 且给子组件传递 tophight 子组件里设置高度--&gt; &lt;top :tophight=\"tophight\"&gt;&lt;/top&gt; &lt;/view&gt; &lt;view style=\"height: 2000upx;\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import Top from './sonzhujian/top.vue' export default { components:{ Top, }, data(){ return { tophight:{}, // 胶囊按钮的数据 showAbs:true, //控制箭头按钮显示/隐藏 true为显示 styleObject:0, //透明度 } }, created(){ // 获取胶囊按钮的数据 m包含胶囊按钮的所有信息 this.tophight = uni.getMenuButtonBoundingClientRect() }, // 这里的 e 就是滚动的距离 onPageScroll(e){ console.log(e); this.handleScroll(e.scrollTop) }, methods:{ // 导航栏的显示 接收一个参数 top是滚动的距离 handleScroll(top) { // 90 300 是任意随便写的 当滑动的距离大于90时 if(top &gt; 90) { let opacity = top / 300 // 这一步是让透明度尽量变小 opacity = opacity &gt; 1 ? 1 : opacity // 如果透明度大于1就等于1 否则透明度就取小于1 this.showAbs = false // 控制顶部栏 的箭头按钮隐藏 this.styleObject = opacity // 透明度赋值一下 }else { this.shhowAbs = true //小于90 即显示顶部导航栏 } } } } &lt;/script&gt; 带视频和图片的轮播组件轮播组件其实也就是swiper组件 因为uniapp 的swiper组件 再子组件内时，带有视频的轮播不能播放视频，所以轮播还是写到父组件 details.vue 里边 :show-center-play-btn = “false” 隐藏视频中间默认得播放按钮:controls=”false” 隐藏左下角播放组件object-fit=”cover” 当视频大小与 video 容器大小不一致时，视频的表现形式。contain：包含，fill：填充，cover：覆盖uni.createVideoContext(videoId, this) 创建并返回 video 上下文 videoContext 对象获取videodom对象 &lt;template&gt; &lt;view &gt; &lt;!-- 返回按钮 --&gt; ... &lt;!-- 子组件 tab --&gt; &lt;!--组件 默认不显示出来 同时透明度值默认是0 --&gt; ... &lt;!-- 图片视频宣传样例 --&gt; &lt;!-- 注意：如果含有视频播放，在子组件里无法触发视频播放，必须要在父组件 --&gt; &lt;view&gt; &lt;swiper :indicator-dots=\"dots\" :interval=\"3000\" :duration=\"1000\" :circular=\"true\" indicator-color=\"rgba(216, 216, 216)\" indicator-active-color=\"#7a7a7a\" &gt; &lt;swiper-item class=\"swiper-video\"&gt; &lt;view class=\"video-btn\"&gt; &lt;view&gt; &lt;video id=\"myVideo\" src=\"http://vd2.bdstatic.com/mda-naa98nr851kwmwya/cae_h264_delogo/1641911777690304151/mda-naa98nr851kwmwya.mp4\" :show-center-play-btn = \"false\" :controls=\"false\" object-fit=\"cover\" &gt;&lt;/video&gt; &lt;/view&gt; &lt;!-- 播放按钮 --&gt; &lt;view class=\"video-img\" @click=\"videoPlay()\" &gt; &lt;image src=\"/static/details/bofang.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view&gt; &lt;image :src=\"item\" mode=\"aspectFill\" class=\"imageurl\" &gt;&lt;/image&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; data(){ return { videoplay:{}, // 得到视频上下文 得到结果是对象 } }, mounted(){ // 得到视频节点 (对象) this.videoplay = uni.createVideoContext('myVideo') }, methods:{ // 手动触发视频播放 videoPlay(){ setTimeout(()=&gt;{ this.videoplay.play() },200) } } 视频操作的一些方法在video上添加属性 @play=”playFun” 当开始/继续播放时触发 play事件 // 视频播放时触发的方法 playFun(){ this.startVideo = false // 中间播放按钮 隐藏 this.conting = true // 显示视频左下角播放组控件 } @pause=”pauseFun” 当暂停播放时触发 pause 事件 // 视频暂停时触发的方法 pauseFun(){ this.conting = false this.startVideo = true } @ended=”endedFun“ 当播放到末尾时触发 ended 事件 endedFun(){ this.conting = false this.startVideo = true } swiper 的滑动事件 @change current 改变时会触发 change 事件， @change=\"bannerfun()\" //写在swiper属性中 // 滑块滑动时触发 bannerfun(){ this.videoplay.pause() }, 请求banner栏的数据接口的添加就和之前一样定义好就不赘述了， 在mthods里定义请求的方法 methods:{ // 请求数据方法 async detRequest(id){ let introduce = new this.Request(this.Urls.m().introduceurl + '?id=' + id).modeget() try{ // 因为后期需要发起多次请求,用promise.all做一个并发请求 let res = await Promise.all([introduce]) // 图片视频的数据 this.imagetext = res[0].data console.log(res); }catch(e) { } }, } // 在onLoad里边调用请求方法 这里的参数是暂时选择的一个接口地址 onLoad(){ this.detRequest('5f8bbf2823954733542169a1') } 在swiper里遍历 &lt;swiper :indicator-dots=\"dots\" :interval=\"3000\" :duration=\"1000\" :circular=\"true\" indicator-color=\"rgba(216, 216, 216)\" indicator-active-color=\"#7a7a7a\" @change=\"bannerfun()\" &gt; &lt;block v-for=\"(iteming,index) in imagetext[0].media\" :key=\"index\"&gt; &lt;swiper-item class=\"swiper-video\"&gt; &lt;view class=\"video-btn\"&gt; &lt;view&gt; &lt;video id=\"myVideo\" :src=\"iteming.video\" :show-center-play-btn = \"false\" :controls=\"conting\" object-fit=\"cover\" @play=\"playFun\" @pause=\"pauseFun\" @ended=\"endedFun\" &gt;&lt;/video&gt; &lt;/view&gt; &lt;!-- 播放按钮 --&gt; &lt;view class=\"video-img\" @click=\"videoPlay()\" v-show=\"startVideo\"&gt; &lt;image src=\"/static/details/bofang.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;block v-for=\"(item,indexing) in iteming.imgArray\" :key=\"indexing\"&gt; &lt;swiper-item&gt; &lt;view&gt; &lt;image :src=\"item\" mode=\"aspectFill\" class=\"imageurl\" &gt;&lt;/image&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/block&gt; &lt;/swiper&gt; 对指示点的出现时机作配置，当请求到的数据里的video有数据时，不显示指示点，否则显示指示点 // 请求数据方法 async detRequest(id){ let introduce = new this.Request(this.Urls.m().introduceurl + '?id=' + id).modeget() try{ // 因为后期需要发起多次请求,用promise.all做一个并发请求 let res = await Promise.all([introduce]) // 图片视频的数据 this.imagetext = res[0].data let mendata = res[0].data[0] // 如果有视频,不显示面板指示点 先拿到数据里的video地址 this.truevideo = mendata.media[0].video // 三元表达式 如果视频数据为空 就显示指示点 否则不显示 this.dots = this.truevideo == ''? true : false }catch(e) { } }, 同时用v-if判断，当没有请求到video数据时，隐藏视频的swiper= &lt;!-- 视频数据不为空 才显示视频组件 --&gt; &lt;swiper-item class=\"swiper-video\" v-if=\"iteming.video !== ''\"&gt; 对有视频的情况，进行指示点的详细判断，在视频页面不显示指示点，图片页面显示指示点，核心思路是e.current值 // 滑块滑动时触发 这里的 e 包含了很多的数据 其中 current值等于 请求到的index值 bannerfun(e){ // if(e.detail.current !== 0) { //滑块滑动到图片的时候显示面板指示点 方法 1 // this.dots = true // }else { // this.dots = false // } let inx = e.detail.current //滑块滑动到图片的时候显示面板指示点 方法 2 if(this.truevideo !== '') { this.videoplay.pause() //暂停视频 this.dots = inx == 0 ? false : true }else { this.dots = true } }, 当滑动视频时候会触发自带的 enable-progress-gesture 属性 –开启控制进度的手势 ，给它关闭掉，这样下次会继续播放之前暂停的视频。 // 在video标签内 :enable-progress-gesture = \"false\" 封装预览图片预览图片功能是公共的组件，因此抽出到新目录 在根目录下新建public/logic.js // 预览图片 class Login{ // index --当前图片下标 imgarr --图片地址(是数组参数) constructor(index,imgarr){ this.index = index this.imgarr = imgarr } // 调用预览图片的方法 previewImg(){ uni.previewImage({ current:this.index, urls:this.imgarr }) .then(res =&gt; { console.log(res) }) .catch(err =&gt; { console.log(err); }) } } // 导出 module.exports = { Login } 引入到details.vue文件 // 预览图片 node导入模式 const { Login } = require('../../public/logic.js') 给图片上添加点击事情,同时实例化引入的Login，并传入参数后调用内置的previewImg方法 &lt;image :src=\"item\" mode=\"aspectFill\" class=\"imageurl\" @click=\"previmg(indexing,iteming.imgArray)\"&gt;&lt;/image&gt; //... // 预览图片 previmg(index,imgArray){ console.log(index,imgArray) // 实例化类 ,同时传入俩参数,接着调用里边的previewImg方法 new Login(index,imgArray).previewImg() }, 获取商品标题价格等数据在pages/details/sonzhujian下新建price.vue 接着在details.vue引入price.vue， &lt;template&gt; &lt;view&gt; &lt;!-- 价格区域 --&gt; &lt;view class=\"price-view\"&gt; &lt;view&gt;当前价&lt;/view&gt; &lt;view class=\"price-list\"&gt; &lt;text&gt;¥{{priceetc.Trueprice}}&lt;/text&gt; &lt;text class=\"scribing\"&gt;原价¥{{priceetc.Crossedprice}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 淘金币抵6% --&gt; &lt;view class=\"Discount-view\"&gt; &lt;text&gt;{{priceetc.Goldcoin}}&lt;/text&gt; &lt;text&gt;{{priceetc.integral}}&lt;/text&gt; &lt;/view&gt; &lt;!-- 标题 --&gt; &lt;view class=\"price-Title\"&gt; &lt;view class=\"titleing\"&gt;{{priceetc.title}}&lt;/view&gt; &lt;view class=\"price-Image\" &gt; &lt;image src=\"/static/details/canshu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;参数&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 月销 --&gt; &lt;view class=\"Monthly\"&gt;销量{{priceetc.sales_volume}}&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props:{ priceetc:Object, }, } &lt;/script&gt; &lt;style scoped&gt; .price-view{ /* background: #FFFFFF; */ background:linear-gradient(to right,#ff0000,#ff4000,#ff8000); height: 120upx; font-size: 35upx; padding-left: 20upx; display: flex; flex-direction: column; justify-content: center; color: #FFFFFF; } .price-list{display: flex; align-items: center; line-height: 50upx;} .price-list text:nth-child(1){font-size: 40upx; padding-right: 10upx;} .price-list text:nth-child(2){ font-size: 25upx; /* background: red; color: #fe0032; height: 30upx; line-height: 30upx; text-align: center; border-radius: 50upx; padding: 9upx 23upx; */ } .scribing{text-decoration: line-through; color: #b5b5b5 !important; padding-left: 7rpx; } .textstyle text:nth-child(2){background: #FFFFFF !important;} .coupon-text{color: #FFFFFF !important;} /* 优惠券 */ .Discount-view{ font-size: 25upx; background: #FFFFFF; height: 100upx; display: flex; align-items: center; padding: 0 20upx; } .Discount-view text:nth-child(-n+2){background: #ffeaef; height: 30upx; line-height: 30upx; text-align: center; padding: 10upx; border-radius: 10upx; margin-right: 10upx; } .Discount-view text:nth-child(3){flex: 1; text-align: right;} /* 标题 */ .price-Title{font-size: 35upx; height: 100upx; background: #FFFFFF; display: flex; align-items: center; padding: 0 20upx;} .titleing{ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; // 控制多行的行数 -webkit-box-orient: vertical; flex: 1; } .price-Title image{width: 50upx; height: 50upx; padding-bottom: 5upx;} .price-Image{display: flex; flex-direction: column; justify-content: center; align-items: flex-end; font-size: 25upx; width: 150upx; /* background: #1183E6; */ } /* 月销 */ .Monthly{ background: #FFFFFF; font-size: 25upx; color: #999999; display: flex; justify-content: flex-end; height: 70upx; line-height: 70upx; padding-right: 20upx; } &lt;/style&gt; 兄弟组件传值请求产品参数数据在pages/details/sonzhujian下新建parame.vue 接着在details.vue引入parame.vue，同时引入写好的公共样式文件夹pattern，并在main.js中引入 功能需求：price.vue组件中点击参数后，parame.vue组件显示产品参数页面 思路： 默认使用v-if 隐藏 然后兄弟组件间传值 –使用bus总线传值 public文件夹下新建文件bus.js // vue 的总线传值 import Vue from 'vue' export default new Vue() 然后在main.js中引入 // bus传值 import bus from './public/bus.js' Vue.prototype.$bus = bus 在要发送数据的组件里使用全局事件总线： methods:{ // 兄弟组件传值显示产品参数 parameFun(){ // $emit() 传值 第一个值是要调用组件的名称可以随意命名 第二个值是要传递的参数 this.$bus.$emit('parames',{show:true}) } } 在要用到数据的组件里接收： created(){ // 接收 $on this.$bus.$on('parames',res =&gt; { console.log(res); // 让键值对的键相对应 this.couponif = res.show }) }, 在price.vue组件的点击参数事件中，添加请求方法，并通过全局总线传递给兄弟组件 &lt;!-- priceetc.id -- 通过父组件details.vue传递过来的priceetc.id 值作为本组件发起请求的id参数 --&gt; &lt;view class=\"price-Image\" @click=\"parameFun(priceetc.id)\"&gt; &lt;image src=\"/static/details/canshu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;参数&lt;/text&gt; &lt;/view&gt; methods:{ // 兄弟组件传值显示产品参数 async parameFun(id){ try{ let parameter = await new this.Request(this.Urls.m().parameterurl + '?id=' + id).modeget() // $emit() 传值 第一个值是要调用组件的名称可以随意命名 第二个值是要传递的参数 this.$bus.$emit('parames',{show:true,data:parameter.data}) }catch(e){ } } } 子组件代码如下： &lt;template&gt; &lt;view v-if=\"couponif\"&gt; &lt;!-- 遮罩层 --&gt; &lt;!-- catchtouchmove 防止穿透点击下方的事件 --&gt; &lt;view class=\"Coupon-yin anim\" :catchtouchmove=\"true\" @click=\"hideCou()\"&gt;&lt;/view&gt; &lt;view class=\"Coupon-view coup-anim\"&gt; &lt;view class=\"Coupon-title\"&gt;产品参数&lt;/view&gt; &lt;block v-for=\"(item,index) in paramedata\" :key=\"index\"&gt; &lt;view class=\"parame-view\"&gt; &lt;view class=\"parame-left\"&gt;{{item.title}}&lt;/view&gt; &lt;view class=\"parame-right\"&gt;{{item.label}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { couponif:false, // 隐藏组件的数据 paramedata:[], // 接收所有产品参数的数据 } }, created(){ // 接收 $on 兄弟组件数据 this.$bus.$on('parames',res =&gt; { // 让键值对的键相对应 console.log(res); let {show,data} = res this.paramedata = data this.couponif = show }) }, methods:{ // 隐藏该组件 hideCou(){ this.couponif = false } } } &lt;/script&gt; &lt;style scoped&gt; .parame-view{ font-size: 28rpx; display: flex; border-bottom: 1px solid #F0F0F0; justify-content: flex-start; padding: 25rpx 15rpx; } .parame-left{ width: 100upx; padding-right: 25upx; } .parame-right{ flex: 1; } &lt;/style&gt; 获取商品评价数据在pages/details/sonzhujian下新建evaluate.vue 接着在details.vue引入evaluate.vue，引入css样式 在添加请求商品评价数据的方法，通过ref传递给子组件 &lt;!-- 商品评价 --&gt; &lt;evaluate :comment=\"comment\"&gt;&lt;/evaluate&gt; // 请求数据方法 async detRequest(id){ // 商品评价的数据 let wxcommnt = new this.Request(this.Urls.m().wxcommnturl + '?id=' + id).modeget() try{ // 因为后期需要发起多次请求,用promise.all做一个并发请求 let res = await Promise.all([introduce,wxcommnt]) console.log(res); // 拿到评价数据 this.comment = res[1].data }catch(e) { } }, 子组件evaluate.vue代码如下 &lt;template&gt; &lt;!-- 当返回的评价数据大于0条才展示此组件 --&gt; &lt;view class=\"evaluate-view\" v-if=\"comment[0].commlen &gt; 0\"&gt; &lt;!-- 第一排 --&gt; &lt;view class=\"evaluate-top\"&gt; &lt;view&gt;商品评价({{comment[0].commlen}})&lt;/view&gt; &lt;view class=\"evaluate-rig\"&gt; &lt;text&gt;查看全部&lt;/text&gt; &lt;image src=\"/static/details/quanbu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 评论的标签 --&gt; &lt;!-- 如果评价标签数据数组的长度大于0才展示数据 --&gt; &lt;view class=\"evaluate-class\" v-if=\"comment[0].commtag.length &gt; 0\"&gt; &lt;block v-for=\"(item,index) in comment[0].commtag\" :key=\"index\"&gt; &lt;text&gt;{{item.label}}({{item.num}})&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 评价内容 --&gt; &lt;view class=\"evaluate-User\"&gt; &lt;block v-for=\"(item,index) in comment[0].parcontent\" :key=\"index\"&gt; &lt;view&gt; &lt;view class=\"USering\"&gt; &lt;image :src=\"item.avatarUrl\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;{{item.nickName}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"USering-text\"&gt;{{item.text}}&lt;/view&gt; &lt;view class=\"USering-time\"&gt; &lt;text&gt;{{item.time}}&lt;/text&gt; &lt;text&gt;颜色:{{item.color}}&lt;/text&gt; &lt;text&gt;尺码:{{item.size}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { // 接收父组件的数据 props: { comment:Array } } &lt;/script&gt; &lt;style scoped&gt; .evaluate-view{background: #FFFFFF; margin-top: 20upx; padding: 20upx; } .evaluate-top{font-size: 30upx; height: 50upx; display: flex; justify-content: space-between; align-items: center; /* background: #4CD964; */ } .evaluate-rig image{width: 27upx; height: 27upx; padding-left: 20upx; } .evaluate-rig{display: flex; align-items: center;} /* 分类 */ .evaluate-class{font-size: 25upx; display: flex; flex-wrap: wrap; margin: 15upx 0; } .evaluate-class text{background: #feecea; border-radius: 50upx; padding: 15upx; margin: 0upx 14upx 14upx 0; } /* 用户评价 */ .evaluate-User{font-size: 25upx; color: #999999;} .evaluate-User image{width: 50upx; height: 50upx !important; border-radius: 50%; } .USering{height: 50upx; /* background: #007AFF; */ display: flex; align-items: center; } .USering text{padding-left: 10rpx;} .USering-text{color: #333333; line-height: 40upx; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; // 控制多行的行数 -webkit-box-orient: vertical; } .USering-time{display: flex; align-items: center; height: 50upx; } .USering-time text:nth-child(1){padding-right: 10upx;} &lt;/style&gt; 请求商品详情图片介绍数据数据在datails中已经取到，是priceetc:{} 数据里 在pages/details/sonzhujian下新建produce.vue，在父组件引入 同时父组件将priceetc通过ref传递给produce.vue 其中图片是应该点击能够预览，可以使用之前封装的 logic.js // 预览图片 node导入模式 const { Login } = require('../../public/logic.js') &lt;template&gt; &lt;view class=\"Product-view\"&gt; &lt;block v-for=\"(item,index) in priceetc.Detaileddrawing\" :key=\"index\"&gt; &lt;image :src=\"item\" mode=\"widthFix\" @click=\"previmg(index,priceetc.Detaileddrawing)\"&gt;&lt;/image&gt; &lt;/block&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 预览图片 node导入模式 const { Login } = require('../../../public/logic.js') export default{ props:{priceetc:Object}, methods:{ // 参数1 --当前图片下标 参数2 --图片地址(所有图片的数组) previmg(index,imgArray){ new Login(index,imgArray).previewImg() } } } &lt;/script&gt; &lt;style scoped&gt; .Product-view{margin-top: 20upx; padding-bottom: 90upx;} .Product-view image{width: 100%; vertical-align: bottom;} &lt;/style&gt; 商品所有的评价在pages下新建comments文件夹，同时在其下 新建comments.vue, 为了便于观察，可以在page.json中先将comments.vue,放到第一位 开始写comments.vue组件内容 &lt;template&gt; &lt;view class=\"comments-view\"&gt; &lt;!-- 评价分类的标签 --&gt; &lt;!-- 如果评价标签的数据长度大于0,就表示有数据,才显示标签 --&gt; &lt;view class=\"evaluate-class\" v-if=\"labeldata.length &gt; 0\"&gt; &lt;block v-for=\"(item, index) in labeldata\" :key=\"index\"&gt; &lt;!-- 如果评价标签数据中的num值为空代表是'全部'标签,就不展条数 --&gt; &lt;text v-if=\"item.num == ''\"&gt;{{ item.label }}&lt;/text&gt; &lt;text v-else&gt;{{ item.label }}({{ item.num }})&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 完整的评价内容 --&gt; &lt;block v-for=\"(item,index) in commdata\" :key=\"index\"&gt; &lt;view class=\"comments-user\"&gt; &lt;view class=\"comments-top comments-flex\"&gt; &lt;image :src=\"item.avatarUrl\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;!-- 用户头像 --&gt; &lt;text&gt;{{item.nickName}}&lt;/text&gt; &lt;!-- 用户昵称 --&gt; &lt;/view&gt; &lt;view class=\"comments-zh comments-flex\"&gt; &lt;text&gt;{{item.time}}&lt;/text&gt; &lt;text&gt;颜色分类:{{item.color}}&lt;/text&gt; &lt;text&gt;尺码:{{item.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"comments-mes\"&gt;{{item.text}}&lt;/view&gt; &lt;!-- 如果 item.isimg 中有数据,就显示图片 --&gt; &lt;view class=\"comments-img\" v-if=\"item.isimg\"&gt; &lt;block v-for=\"(items,indexs) in item.image\" :key=\"indexs\"&gt; &lt;!-- 评论图片 有没有数据 取决于isimg的布尔值 --&gt; &lt;view class=\"user-images\"&gt; &lt;image :src=\"items\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { // 选中第几个 labeldata: [], commdata: [] }; }, methods: { async reqComm(id) { let comtag = new this.Request(this.Urls.m().comtagurl + '?id=' + id).modeget(); //评价分类标签数据 let comtconent = new this.Request(this.Urls.m().comtconenturl + '?id=' + id + '&amp;label=' + '全部').modeget(); //评价的内容数据 try { let res = await Promise.all([comtag, comtconent]); console.log(res); // 标签数据 this.labeldata = res[0].data; // 评价数据 this.commdata = res[1].data; } catch {} } }, onLoad() { this.reqComm('5f8bbf2823954733542169a1'); } }; &lt;/script&gt; &lt;style scoped&gt; .comments-view { margin: 20upx; } /* 分类 */ .evaluate-class { font-size: 25upx; display: flex; flex-wrap: wrap; padding-bottom: 50upx; border-bottom: 1px solid #eeeeee; } .evaluate-class text { background: #feecea; border-radius: 50upx; padding: 15upx; margin: 0upx 14upx 14upx 0; } /* 选中*/ .actives { background: #ff0036 !important; color: #fff !important; } /* user评价 */ .comments-user { font-size: 30upx; padding-bottom: 15upx; border-bottom: 1px solid #eeeeee; margin: 25upx 0; } .comments-flex { display: flex; align-items: center; } .comments-top image { width: 60upx; height: 60upx !important; border-radius: 50%; } .comments-top text { padding-left: 10upx; } .comments-zh { height: 80upx; font-size: 25upx; color: #a7a7a7; } .comments-zh text { padding-right: 8upx; } .comments-mes { line-height: 1.5; } .comments-top { height: 60upx; } .comments-img { display: flex; flex-wrap: wrap; } .user-images { width: calc(33.33% - 10rpx * 2); height: 200rpx; padding: 10rpx; } .user-images image { width: 100%; height: 200rpx; border-radius: 2rpx; } &lt;/style&gt; 完成商品分类查询评价先完成图片预览功能 &lt;image :src=\"items\" mode=\"aspectFill\" @click=\"preTmage(indexs,item.image)\"&gt;&lt;/image&gt; // 预览图片 node导入模式 const { Login } = require('../../public/logic.js') // 阅览图片方法 preTmage(index,imgArray){ new Login(index,imgArray).previewImg() } 然后完成点击标签变色，且展示相关评论功能， &lt;template&gt; &lt;view class=\"comments-view\"&gt; &lt;!-- 评价分类的标签 --&gt; &lt;!-- 如果评价标签的数据长度大于0,就表示有数据,才显示标签 --&gt; &lt;view class=\"evaluate-class\" v-if=\"labeldata.length &gt; 0\"&gt; &lt;block v-for=\"(item, index) in labeldata\" :key=\"index\"&gt; &lt;!-- 如果评价标签数据中的num值为空代表是'全部'标签,就不展示条数 --&gt; &lt;!-- 添加动态的class 当num等于下标值时触发--&gt; &lt;text v-if=\"item.num == ''\" :class=\"{ actives: num == index }\" @click=\"labelFun(item.commid,item.label,index)\"&gt;{{ item.label }}&lt;/text&gt; &lt;text v-else :class=\"{ actives: num == index }\" @click=\"labelFun(item.commid,item.label,index)\"&gt;{{ item.label }}({{ item.num }})&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 完整的评价内容 --&gt; &lt;block v-for=\"(item, index) in commdata\" :key=\"index\"&gt; &lt;view class=\"comments-user\"&gt; &lt;view class=\"comments-top comments-flex\"&gt; &lt;image :src=\"item.avatarUrl\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;!-- 用户头像 --&gt; &lt;text&gt;{{ item.nickName }}&lt;/text&gt; &lt;!-- 用户昵称 --&gt; &lt;/view&gt; &lt;view class=\"comments-zh comments-flex\"&gt; &lt;text&gt;{{ item.time }}&lt;/text&gt; &lt;text&gt;颜色分类:{{ item.color }}&lt;/text&gt; &lt;text&gt;尺码:{{ item.size }}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"comments-mes\"&gt;{{ item.text }}&lt;/view&gt; &lt;!-- 如果 item.isimg 中有数据,就显示图片 --&gt; &lt;view class=\"comments-img\" v-if=\"item.isimg\"&gt; &lt;block v-for=\"(items, indexs) in item.image\" :key=\"indexs\"&gt; &lt;!-- 评论图片 有没有数据 取决于isimg的布尔值 --&gt; &lt;view class=\"user-images\"&gt;&lt;image :src=\"items\" mode=\"aspectFill\" @click=\"preTmage(indexs, item.image)\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 预览图片 node导入模式 const { Login } = require('../../public/logic.js'); export default { data() { return { // 选中第几个 num:0, labeldata: [], // 标签数据 commdata: [], // 评价数据 }; }, methods: { async reqComm(id) { let comtag = new this.Request(this.Urls.m().comtagurl + '?id=' + id).modeget(); //评价分类标签数据 let comtconent = new this.Request(this.Urls.m().comtconenturl + '?id=' + id + '&amp;label=' + '全部').modeget(); //评价的内容数据 try { let res = await Promise.all([comtag, comtconent]); console.log(res); // 标签数据 this.labeldata = res[0].data; // 评价数据 this.commdata = res[1].data; } catch {} }, // 预览览图片方法 preTmage(index, imgArray) { new Login(index, imgArray).previewImg(); }, // 点击标签切换的方法 async labelFun(commid,label,index){ this.num = index // 请求分类标签的接口 let comtconent1 = await new this.Request(this.Urls.m().comtconenturl + '?id=' + commid + '&amp;label=' + label).modeget(); this.commdata = comtconent1.data } }, // onLoad生命周期可以接收上个页面过来的值 e就包含接收的数据 onLoad(e) { this.reqComm(e.id); } }; &lt;/script&gt; &lt;style scoped&gt; .comments-view { margin: 20upx; } /* 分类 */ .evaluate-class { font-size: 25upx; display: flex; flex-wrap: wrap; padding-bottom: 50upx; border-bottom: 1px solid #eeeeee; } .evaluate-class text { background: #feecea; border-radius: 50upx; padding: 15upx; margin: 0upx 14upx 14upx 0; } /* 选中*/ .actives { background: #ff0036 !important; color: #fff !important; } /* user评价 */ .comments-user { font-size: 30upx; padding-bottom: 15upx; border-bottom: 1px solid #eeeeee; margin: 25upx 0; } .comments-flex { display: flex; align-items: center; } .comments-top image { width: 60upx; height: 60upx !important; border-radius: 50%; } .comments-top text { padding-left: 10upx; } .comments-zh { height: 80upx; font-size: 25upx; color: #a7a7a7; } .comments-zh text { padding-right: 8upx; } .comments-mes { line-height: 1.5; } .comments-top { height: 60upx; } .comments-img { display: flex; flex-wrap: wrap; } .user-images { width: calc(33.33% - 10rpx * 2); height: 200rpx; padding: 10rpx; } .user-images image { width: 100%; height: 200rpx; border-radius: 2rpx; } &lt;/style&gt; 最后完成点击evaluate.vue组件的查看全部，携带id跳转到当前商品的评价页面功能 先给evaluate添加点击事件并且拿到评价数据中携带的商品id，然后使用uni.navigateTo跳转到comments页面 &lt;view class=\"evaluate-rig\" @click=\"commEnts(comment[0].parcontent[0].commid)\"&gt; &lt;text&gt;查看全部&lt;/text&gt; &lt;image src=\"/static/details/quanbu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; // 跳转到评论详情 commEnts(id){ uni.navigateTo({ url:'../comments/comments?id=' + id }) }, comments组件接收值，然后调用请求接口的方法 // onLoad生命周期可以接收上个页面过来的值 e就包含接收的数据 onLoad(e) { this.reqComm(e.id); } 锚点链接将页面滚动到目标位置uni.pageScrollTo(OBJECT) –将页面滚动到目标位置 在top.vue文件中，通过$parent调用父组件的方法，同时传递参数index过去 methods:{ // 控制短横线跳转位置 navbtn(index){ this.num = index if(index === 0) { // 跳转到页面顶部 uni.pageScrollTo({ scrollTop:0, duration:300 }) }else { this.$parent.fathEr(index) } } } 父组件中给节点添加 class属性，即可使用uni.pageScrollTo的方法去跳转到该节点 &lt;!-- 商品评价 --&gt; &lt;evaluate :comment=\"comment\" class=\"evaluate\"&gt;&lt;/evaluate&gt; &lt;!-- 商品详情 --&gt; &lt;product :priceetc=\"priceetc\" class=\"produce\"&gt;&lt;/product&gt; // 被 子组件top 用来锚点链接 fathEr(index){ let clsdata = index === 1 ? '.evaluate' : '.produce' uni.pageScrollTo({ selector:clsdata, duration:300 }) } 此时发现因为之前固定了导航栏，所以滑动到评价或者详情区域，被胶囊按钮的高度和它到顶部的距离之和盖住了一部分 如下代码导致： &lt;!-- 子组件 tab --&gt; &lt;!--组件 默认不显示出来 同时透明度值默认是0 --&gt; &lt;view class=\"header-fixed backyes\" v-show=\"!showAbs\" :style=\"{opacity:styleObject}\"&gt; &lt;!-- 放置一个div 撑开到顶部距离 --&gt; &lt;view class=\"status_bar\" :style=\"'height: '+ tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;!-- 引用子组件 且给子组件传递 tophight 子组件里设置高度--&gt; &lt;top :tophight=\"tophight\"&gt;&lt;/top&gt; &lt;/view&gt; 解决方法：减去顶部被盖住的距离 思路：不使用uniapp的方法，使用微信小程序的一个方法 SelectorQuery wx.createSelectorQuery() 功能描述： 返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替。 const query = wx.createSelectorQuery() query.select('#the-id').boundingClientRect() query.selectViewport().scrollOffset() query.exec(function(res){ res[0].top // #the-id节点的上边界坐标 res[1].scrollTop // 显示区域的竖直滚动位置 }) // 被子组件top 用来锚点链接 fathEr(index) { let clsdata = index === 1 ? '.evaluate' : '.produce'; let he = this.tophight.top + this.tophight.height; //胶囊按钮到顶部距离 + 自身高度 const query = this.createSelectorQuery(); query.select(clsdata).boundingClientRect(); query.selectViewport().scrollOffset(); query.exec(res =&gt; { // res[0].top // clsdata节点到上边界的距离 节点的上边界坐标 // res[1].scrollTop // 往下滑动屏幕后,到节点的距离 显示区域的竖直滚动位置 // 跳转 uni.pageScrollTo({ scrollTop: res[0].top + res[1].scrollTop - he, duration: 300 }); }); } 添加功能：当和滑动到目标位置时，顶部的导航栏自动选中对应的tab /* * 定义mutations事件类型：函数名称port const ADDCOUNT = 商品详情页下方的功能组件pages/details/sonzhujian/新建shopping.vue 静态布局如下： &lt;template&gt; &lt;view&gt; &lt;view class=\"shopping-view\"&gt; &lt;view class=\"shopping-text\"&gt; &lt;image src=\"/static/details/fenxiang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;分享&lt;/text&gt; &lt;/view&gt; &lt;view class=\"shopping-text middle\"&gt; &lt;image src=\"/static/details/gouwuche.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;购物车&lt;/text&gt; &lt;text&gt;10&lt;/text&gt; &lt;/view&gt; &lt;!-- 未收藏 --&gt; &lt;view class=\"shopping-text\"&gt; &lt;image src=\"/static/details/shoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;收藏&lt;/text&gt; &lt;/view&gt; &lt;!-- 已收藏 --&gt; &lt;view class=\"shopping-text\"&gt; &lt;image src=\"/static/details/yishoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;已收藏&lt;/text&gt; &lt;/view&gt; &lt;view class=\"join join-right\"&gt;加入购物车&lt;/view&gt; &lt;view class=\"join join-left\"&gt;立即购买&lt;/view&gt; &lt;/view&gt; &lt;!-- 登录弹窗 --&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { } }, methods:{ }, } &lt;/script&gt; &lt;style scoped&gt; .shopping-view image { width: 35rpx; height: 35rpx; } .shopping-view { font-size: 30upx; background: #ffffff; border-top: 1rpx solid #cccccc; height: 100upx; display: flex; align-items: center; position: fixed; bottom: 0; left: 0; width: 100%; } .join { flex: 2; text-align: center; height: 80upx; line-height: 80upx; color: white; } .shopping-text { height: 100upx; flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; } .shopping-text text { font-size: 23upx; padding-top: 5upx; color: #666666; } .join-right { background: linear-gradient(to right, #ffc800 10%, #ff9602 80%); border-top-left-radius: 50upx; border-bottom-left-radius: 50upx; } .join-left { background: linear-gradient(to right, #ff7500 10%, #ff4b00 80%); border-top-right-radius: 50upx; border-bottom-right-radius: 50upx; margin-right: 10upx; } .middle { border-left: 1rpx solid #f4f4f4; border-right: 1rpx solid #f4f4f4; position: relative; } .middle text:nth-child(3) { font-size: 16upx; background: #fe0036; color: #ffffff; border-radius: 50%; width: 30upx; height: 30upx; padding: 0 !important; text-align: center; line-height: 30upx; position: absolute; top: 10upx; right: 10upx; } &lt;/style&gt; 收藏和取消收藏功能点击收藏后，发起请求 所以这个接口是有权限的，因为一般收藏需要用户登录了才能操作，收藏只属于自己，不属于别人。（权限接口，需携带token） 根据请求的返回值，来显示或者隐藏 组件 在shopping组件中要写俩对应不同的图标情况 &lt;!-- 未收藏 --&gt; &lt;!-- 根据接口文档 id为1 是收藏 --&gt; &lt;view class=\"shopping-text\" @click=\"collEct(1)\" v-if=\"collects == 0\"&gt; &lt;image src=\"/static/details/shoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;收藏&lt;/text&gt; &lt;/view&gt; &lt;!-- 已收藏 --&gt; &lt;!-- 根据接口文档 id为2 是取消收藏 --&gt; &lt;view class=\"shopping-text\" @click=\"collEct(0)\" v-if=\"collects == 1\"&gt; &lt;image src=\"/static/details/yishoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;已收藏&lt;/text&gt; &lt;/view&gt; 在details.vue中拿到商品id // 商品id this.goodid = mendata.id 通过ref传递给子组件 props:{ goodid:String, }, &lt;!-- 未收藏 --&gt; &lt;!-- 子组件将接收到的goodid 当作第二个data参数填入 --&gt; &lt;view class=\"shopping-text\" @click=\"collEct(1,goodid)\" v-if=\"collects == 0\"&gt; &lt;image src=\"/static/details/shoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;收藏&lt;/text&gt; &lt;/view&gt; &lt;!-- 已收藏 --&gt; &lt;!-- 根据接口文档 id为2 是取消收藏 --&gt; &lt;view class=\"shopping-text\" @click=\"collEct(0,goodid)\" v-if=\"collects == 1\"&gt; &lt;image src=\"/static/details/yishoucang.svg\" mode=\"widthFix\" /&gt; &lt;text&gt;已收藏&lt;/text&gt; &lt;/view&gt; 在点击事件中发起post请求 methods:{ // 收藏和取消收藏 async collEct(num,id){ let data = { num:num,id:id } // 等于 { num,id } try{ // this.Urls.m().enshrineurl 代表url , data 代表携带的参数 data let enshrine = await new this.Request(this.Urls.m().enshrineurl,data).modepost(); console.log(enshrine); let { errrcode } = enshrine.msg if(errrcode == '401') { // 要登录 }else { } }catch { } } }, 此时点击收藏会返回401，没有权限，即没有登录的时候，后端不知道是谁在操作收藏会阻止。 /* * 定义mutations事件类型：函数名称port const ADDCOUNT = 登录弹窗以及微信小程序登录当点击收藏后，弹出登录弹窗，登陆后刷新页面 登录弹窗功能在很多页面都要用到，因此抽出做一个公用的组件 在pages/commponents/新建showmodal.vue,并注册到main.js，同时在shopping组件中引入showmodal组件 showmodal.vue 布局如下： &lt;template&gt; &lt;view class=\"showmodel anim\" v-if=\"modeling\"&gt; &lt;view class=\"showmodel-view\"&gt; &lt;view class=\"showmodel-tips\"&gt; &lt;text&gt;请登录后在操作&lt;/text&gt; &lt;/view&gt; &lt;view class=\"showmodel-button\"&gt; &lt;button plain=\"true\" &gt;取消&lt;/button&gt; &lt;!-- 小程序中只有button触发登录 --&gt; &lt;button plain=\"true\" open-type=\"getUserInfo\" @click=\"getUserInfo()\"&gt;确定&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { // 默认隐藏的数据 modeling:false, } }, methods:{ cancel(){ this.modeling = true }, getUserInfo(){ }, } } &lt;/script&gt; &lt;style scoped&gt; .showmodel{ background: rgba(0,0,0,0.7); position: fixed; left: 0; right: 0; bottom: 0; top: 0; display: flex; justify-content: center; align-items: center; z-index: 999; } .showmodel-view{ background: white; width: 100%; margin: 0 90rpx; height: 280rpx; border-radius: 20rpx; position: relative; } .showmodel-tips{ display: flex; flex-direction: column; justify-content: center; height: 190rpx; } .showmodel-tips text{display: block; text-align: center; font-size: 32rpx;} .showmodel-button{ border-top: 0.5rpx solid #FEECEA; display: flex; justify-content: space-between; align-items: center; position: absolute; bottom: 0; left: 0; right: 0; } .showmodel-button button{ font-size: 32rpx; font-weight: bold; border: none; padding: 0 !important; margin: 0; width: 100%; border-radius: inherit; } .showmodel-button button:nth-child(1){border-right: 0.5rpx solid #FEECEA;} .showmodel-button button:nth-child(2){color: #ff6699} &lt;/style&gt; 然后 注册到main.js // 注册到main.js // 引入登录弹窗组件 import showmodal from 'pages/commponents/showmodal.vue' Vue.component('showmodal',showmodal) //在 shopping组件中引入showmodal组件 &lt;!-- 使用 全局引入的登录弹窗 组件--&gt; &lt;showmodal&gt;&lt;/showmodal&gt; showmodal.vue中，默认隐藏组件 &lt;view class=\"showmodel anim\" v-if=\"modeling\"&gt; 当有登录请求的时候显示，即当点击 shopping组件中收藏时，后端返回401检测到没有登录时候，在shopping组件中去操控子组件showmodal的v-if属性 思路：父子组件传值，refs &lt;!-- 使用 全局引入的登录弹窗 组件--&gt; &lt;showmodal ref=\"show\"&gt;&lt;/showmodal&gt; // 请求的时候如果返回值是401 就展示弹窗组件 （通过ref调用子组件里的方法） if(errcode == '401') { // 要登录 this.$refs.show.cancel() }else { } 登录逻辑思路： 封装发起登录的请求方法： 新建login/login.js 引入请求接口、请求方法、弹框类 新建wxLogin类， 接收俩参数，user和msg，在类中封装wxlogin( )方法 和 loGin( )方法 wxlogin方法获取登录请求要携带的五个参数： 1）首先将user对象 解构出微信头像、微信昵称。 2）然后返回一个promise实例对象，执行 **wx.login(Object object)**，调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。 将五个数据赋值给了data中，返回的成功值取到data 将会return出去 loGin( )方法中： 1）首先判断constructor构造函数的第二个参数msg，是否值为”getUserProfile:ok”，如果不是就抛出错误(‘登录失败’)， //抛出错误,阻止代码允许 2）接着获取code，即调用wxlogin()方法结果赋值给userdata，此时userdata包含了所有的参数，记得添加await和async拿到返回值 3）然后再try，catch中调用后台的微信接口返回结果给user，添加刚才得到的userdata作为请求的data参数 4）判断user中msg值是否为 SUCCESS，如果是就 执行 **uni.setStorageSync(KEY,DATA) ** 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 //即存储用户信息到本地缓存 ​ 5）然后调用 弹窗 中的showtoast方法，显示登录成功 ​ 6）最后返回 return(‘SUCCESS’) // 微信登录 import request from '../api/api.js' // 引入请求接口 import urls from '../api/request.js' // 引入请求方法 import toast from '../public/toast.js' // 引入弹框类 class wxLogin { constructor(user,msg){ this.user = user this.msg = msg } // 调用接口登录,async其实是返回一个promise async loGin(){ // 拒绝登录 即登陆失败 if(this.msg !== \"getUserInfo:ok\") { console.log('拒绝登录') throw ('登录失败') } // 获取code let userdata = await this.wxlogin() try{ let user = await new request(urls.m().wxloginurl,userdata).modepost() if(user.msg == 'SUCCESS'){ uni.setStorageSync('wxuser', user.data);//存储用户信息到本地缓存 new toast('登录成功').showtoast() return('SUCCESS') } }catch(e){ return e // 500,501,502, //TODO handle the exception } } // 获取code wxlogin(){ let {avatarUrl,nickName} = this.user return new Promise((resolve,reject)=&gt;{ wx.login({ success: (res) =&gt; { let data = {//wx404e88f75f32c85b appid:'wx404e88f75f32c85b', secret:'0402d0b4b834bf9449b2477115a2e25f', nickName, avatarUrl, code:res.code } resolve(data) }, fail: (err) =&gt; { reject('登录失败') } }) }) } } export default wxLogin 收藏按钮逻辑点击收藏按钮后 getUserInfo() 执行思路： 点击确定 会隐藏 showmodel组件 实例化 Toast 类，并传递 title值，同时实例调用 **showloading()**方法，内部 **uni.showLoading **方法生效即显示loading提示框，展示提示文字title值，并且使用mask显示透明蒙层防止触摸穿透 获取用户信息 –wx.getUserProfile，获取用户头像昵称等。当点击拒绝，可以在err回调中查看errMsg，当点击允许后调用res回调，回调中res能够拿到err数据中的包含用户头像和昵称的信息userInfo和 代表成功值的errMsg信息， 然后调用wxusEr（），即调用前边写在login.js里的登录请求方法，成功后存储用户头像、昵称和token值到本地，然后调用其他弹窗组件**showtoast()**，显示登录成功后自动隐藏。 // 登录 async getUserInfo(){ this.modeling = false new this.$Toast('登录中').showloading() /*wx.getUserProfile 获取用户信息。页面产生点击事件后才可调用，每次请求都会弹出授权窗口，用户同意后返回userInfo。该接口用于替换 wx.getUserInfo， */ wx.getUserProfile({ desc: '登录' //声明获取用户个人信息后的用途，不超过30个字符 }) .then(res=&gt;{ let {userInfo,errMsg} = res this.wxusEr(userInfo,errMsg) }) .catch(err=&gt;{ console.log('拒绝登录或登录失败') }) }, // 调用登录 async wxusEr(userInfo,errMsg){ try{ let data = await new wxLogin(userInfo,errMsg).loGin() if(this.msg == 'coll'){ // 更新收藏状态 this.$bus.$emit('collict', {colldata:data}) } }catch(e){ //TODO handle the exception } } 封装消息提示框微信弹窗已经弃用 现在准备一个登录时候的弹窗反馈：使用微信小程序（uni）自带的uni.showToast 新建public/toast.js // 一些弹窗 class Toast{ // title String 提示的内容，长度与 icon 取值有关 // icon String 图标 // duration Number 提示的延迟时间，单位毫秒，默认：1500 // mask Boolean 是否显示透明蒙层，防止触摸穿透，默认：false constructor(title,icon,duration=1300,mask=true) { this.title = title this.icon = icon this.duration = duration this.mask = mask } // 消息提示框：自动消失 showtoast(){ uni.showToast({ title: this.title, icon:this.icon, duration: this.duration, mask:this.mask }); } // 消息提示框：手动消失 showloading(){ // uni.showLoading 显示 loading 提示框, 需主动调用 uni.hideLoading 才能关闭提示框。 uni.showLoading({ title: this.title, mask:this.mask }); } } export default Toast main.js引入 // toast弹窗 import toast from './public/toast.js' Vue.prototype.$Toast = toast 携带token令牌登录小程序使用 js-base64加密token，下载 js-base.js到本地的api下， 在login.js中引入加密方法，取出本地存储的token进行加密，然后将token放置在header中 // request 该文件封装了请求方法 // 引入js-base.js let Base64 = require('./base64').Base64 const request = class { // 参数url是request.js暴露出的url // 参数data是post请求传递的值 constructor(url, arg) { this.url = url; this.arg = arg; } // 封装 post请求 modepost() { return new Promise((resolve, reject) =&gt; { uni.request({ url: this.url, method: 'POST', data: this.arg, header: { Authorization: this.baseFun() } }).then(res =&gt; { resolve(res[1].data); }).then(err =&gt; { reject('出错了'); }) }) } // 封装 get请求 modeget() { return new Promise((resolve, reject) =&gt; { uni.request({ url: this.url, method: 'GET', header: { Authorization: this.baseFun() } }) .then(res =&gt; { // 输出成功的值 resolve(res[1].data); }).then(err =&gt; { // 失败的原因/提示 reject('出错了'); }) }) } // 加密token 方法 baseFun() { const token = uni.getStorage('wxuser').token //取出token const base64 = Base64.encode(token + ':') //使用base里的方法 return 'Basic ' + base64 } } export default request 当请求携带了token后，shopping.vue中 let enshrine = await new this.Request(this.Urls.m().enshrineurl,data).modepost(); enshrine就能返回带有： 成功的200 状态码 errcodes 表示收藏与否的数值 1或者 2 和提示信息msg 判断：当collects值为errcodes时，下方栏展示收藏或者未收藏的图标，但因为每次重新请求数据默认是取到collects的默认值0，所以图标不会变化。 因此还需要请求一个接口 –获取详情页商品是否收藏：GET /collection?query= {权限接口，需携带token} // 收藏和取消收藏 async collEct(num,id){ let data = { num:num,id:id } // 等于 { num,id } try{ // this.Urls.m().enshrineurl 代表url , data 代表携带的参数 data let enshrine = await new this.Request(this.Urls.m().enshrineurl,data).modepost(); console.log(enshrine,'我是enshrine'); let { errcode } = enshrine.msg if(errcode == '401') { // 要登录 // 使用 全局引入的登录弹窗 组件里的方法 this.$refs.show.showing() }else if(errcode == '200'){ this.collects = enshrine.msg.collects //判断当collects值为errcodes时，下方栏展示收藏或者未收藏的图标，但因为每次重新请求数据默认是取到collects的默认值0，使用图标不会变化 } }catch { } }, 获取该商品是否已经收藏父组件datails中调用获取详情页商品是否收藏的接口 collectionur 即当页面加载就调用该接口检查是否res[2]的返回值，并将返回值赋值给colldata ，通过refs将colldata传递给子组件 // 获取商品是否收藏 let collection = new this.Request(this.Urls.m().collectionurl + '?id=' + id).modeget(); let res = await Promise.all([introduce, wxcommnt,collection]); console.log('商品是否收藏数据',res[2]); this.colldata = res[2]; &lt;!-- 底部操作栏组件 --&gt; &lt;shopping :goodid=\"goodid\" :colldata=\"colldata\"&gt;&lt;/shopping&gt; 子组件shopping中接收数据， 监听器wtach 监听msg对象中是否有变化，有新值就赋值给collects，这样就实现了收藏图标变化 props:{ goodid:String, colldata:Object, }, watch:{ // 收藏和获取该商品是否收藏 colldata(newValue,oldValue) { console.log(newValue); let { collects } = newValue.msg this.collects = collects } } 当本地没有token的时候，即用户重新登陆后， 虽然这个请求返回的msg.errcode 值是 302 ，msg.msg返回值是 “未登录,收藏默认未收藏状态” let collection = new this.Request(this.Urls.m().collectionurl + '?id=' + id).modeget(); let res = await Promise.all([introduce, wxcommnt,collection]); // ....... {__ob__: Observer} msg: Object collects: 0 errcode: \"302\" msg: \"未登录,收藏默认未收藏状态\" 但是：当登陆后，之前收藏的图标仍然显示未收藏 思路：每次登录后刷新收藏状态 首先需要知道登陆成功，即shopping组件中，当errcode值等于401时候，表示没有登录，就调用弹窗组件showmodal.vue展示提示登录的弹窗,并且传递值 ‘coll’ 到子组件的参数中 // 收藏和取消收藏 async collEct(num,id){ let data = { num:num,id:id } // 等于 { num,id } try{ // this.Urls.m().enshrineurl 代表url , data 代表携带的参数 data let enshrine = await new this.Request(this.Urls.m().enshrineurl,data).modepost(); console.log(enshrine,'我是查看收藏成功与否'); let { errcode } = enshrine.msg if(errcode == '401') { // 要登录 // 使用 全局引入的登录弹窗 组件里的方法 // 登陆这里传值过去 coll this.$refs.show.showing('coll') }else if(errcode == '200'){ this.collects = enshrine.msg.collects } }catch { } }, 子组件中，showing方法显示组件，同时接受值‘coll’， data(){ return { // 默认隐藏的数据 modeling:false, // 告知是哪个组件传值过来 msg:'', } }, // 显示组件 接收父组件shopping里的coll 这里参数默认是空值 showing(msg = ''){ this.msg = msg this.modeling = true }, 然后拿着msg到调用登录方法 wxusEr 下： 判断如果当前组件的msg等于了‘coll’，就使用全局事件总线将data值传递出去 命名未 collict // 调用登录 async wxusEr(userInfo,errMsg){ try{ let data = await new wxLogin(userInfo,errMsg).loGin() console.log(data); // data 值是 success 来自于login.js中的返回值 //如果登录成功就 if(this.msg == 'coll'){ // 更新收藏状态 emit是传值的作用 collict随意命名 值的话是data data值是SUCCESS this.$bus.$emit('collict', {colldata:data}) } }catch(e){ //TODO handle the exception } } 最后在父组件这，先封装一个更新收藏状态的方法，然后在生命周期created中接收 collict 值，当值等于SUCCESS时，调用更新状态的方法 // 登录成功后，更新收藏状态 async reFresh(){ try{ // 获取商品是否已经收藏 let collection = await new this.Request(this.Urls.m().collectionurl + '?id=' + this.goodid).modeget(); console.log(collection,'更新商品是否收藏'); this.collects = collection.msg.collects }catch(err) { console.log(err); } } // 接收showmodal组件传过来的判断是否登录的 SUCCESS 值 created(){ this.$bus.$on('collict',res =&gt; { if(res.colldata == 'SUCCESS'){ // 更新收藏状态 this.reFresh() } }) }, 获取购物车商品件数在接口文件内添加获取商品件数接口 ， // 获取购物车件数 let mycarturl = `${url}mycart` // 加入购物车 let atcarturl = `${url}atcart` 在details组件内，发起请求，拿到res数据，初次其长度为0，即购物车里0件商品 // 获取购物车件数 let mycart = new this.Request(this.Urls.m().mycarturl).modeget(); try { // 因为后期需要发起多次请求,用promise.all做一个并发请求 let res = await Promise.all([ ... , mycart] ); console.log( ' ... ' , 获取购物车数据',res[3] ); } catch (e) { } 然后shopping中完成登陆之后刷新购物车功能 // 登录成功后，更新收藏状态 async reFresh(){ try{ // 获取商品是否已经收藏 let collection = await new this.Request(this.Urls.m().collectionurl + '?id=' + this.goodid).modeget(); console.log(collection,'更新商品是否收藏'); this.collects = collection.msg.collects // 更新购物车件数 let mycart = await new this.Request(this.Urls.m().mycarturl).modeget(); this.cartnum = mycart.data.length }catch(err) { console.log(err); } } 封装商品sku选择组件在pages/commponents下新建addtocart组件，同时在details中引入， 静态布局代码如下： &lt;template&gt; &lt;!-- 公用的商品sku选择组件 --&gt; &lt;view &gt; &lt;view class=\"Coupon-yin anim\" :catchtouchmove=\"true\" &gt;&lt;/view&gt; &lt;view class=\"Coupon-view coup-anim padd\"&gt; &lt;!-- 商品图片 --&gt; &lt;view class=\"commodity-view\"&gt; &lt;view class=\"commodity-left-img\"&gt; &lt;image :src=\"attribute.image\" mode=\"aspectFill\"&gt;图片1 &lt;/image&gt; &lt;/view&gt; &lt;view class=\"commodity-zh\"&gt; &lt;view&gt;¥300&lt;/view&gt; &lt;view&gt;库存100件&lt;/view&gt; &lt;view class=\"choice\"&gt; &lt;text&gt;请选择:&lt;/text&gt; &lt;text&gt;颜色&lt;/text&gt; &lt;text&gt;尺码&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"commodity-right-img\"&gt; &lt;image src=\"/static/details/guanbi.svg\" mode=\"widthFix\"&gt; 图片2 &lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 主要颜色 --&gt; &lt;view class=\"sku-view\"&gt; &lt;text class=\"sku-title\"&gt;主要颜色&lt;/text&gt; &lt;view class=\"sku-mian\"&gt; &lt;view &gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt; 图片3 &lt;/image&gt; &lt;text&gt;黑色&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 尺寸 --&gt; &lt;view class=\"sku-view\"&gt; &lt;text class=\"sku-title\"&gt;尺码&lt;/text&gt; &lt;view class=\"sku-mian sku-two\"&gt; &lt;view&gt;S&lt;/view&gt; &lt;view&gt;M&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 购买数量 --&gt; &lt;view class=\"sku-view sku-height\" &gt; &lt;view class=\"sku-title numes\"&gt;购买数量&lt;/view&gt; &lt;view class=\"sku-mums-gight\"&gt; &lt;view&gt;-&lt;/view&gt; &lt;view&gt;0&lt;/view&gt; &lt;view&gt;+&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 确定按钮 --&gt; &lt;view class=\"determine coup-anim\" &gt;确定&lt;/view&gt; &lt;!-- 登录弹窗 --&gt; &lt;showmodal ref=\"show\"&gt;&lt;/showmodal&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style scoped&gt; .padd { padding: 15upx; margin-bottom: 90rpx; } .Coupon-view text { display: block; } .commodity-view { /* background: #4CD964; */ height: 200upx; display: flex; } .commodity-left-img { width: 200upx; height: 200upx; } .commodity-left-img image { width: 200upx; height: 200upx; border-radius: 10upx; } .commodity-zh { font-size: 27upx; color: #3d4245; flex: 1; } .commodity-zh view:nth-child(1) { font-size: 35upx; color: #fe0036; } .commodity-zh view { padding-top: 10upx; padding-left: 15upx; } .choice { display: flex; align-items: center; } .choice text { padding-right: 8upx; } .commodity-right-img { width: 50upx; height: 50upx; } .commodity-right-img image { width: 50upx; height: 50upx; } /* sku */ .sku-view { margin-top: 40upx; border-bottom: 1px solid #e5e5e5; } .sku-title { font-size: 30upx; color: #051b28; font-weight: bold; margin-bottom: 20upx; } .sku-mian image { width: 45upx; height: 45upx; padding-right: 17upx; } .sku-mian view { display: flex; align-items: center; height: 65upx; background: #f5f5f5; border: 1rpx solid #f5f5f5; border-radius: 20upx; padding: 0 14upx; margin-right: 30upx; margin-bottom: 30upx; } .sku-mian { font-size: 27upx; color: #051b28; display: flex; align-items: center; flex-wrap: wrap; } .sku-two view { padding: 0 35upx; } /* 购买数量 */ .sku-height { height: 120upx; display: flex; align-items: center; justify-content: space-between; } .numes { margin: 0 !important; } .sku-mums-gight { display: flex; align-items: center; } .sku-mums-gight view { font-size: 30upx; color: #051b28; font-weight: bold; background: #f5f5f5; border-radius: 10upx; width: 90upx; height: 70upx; line-height: 70upx; text-align: center; } .sku-mums-gight view:nth-child(2) { background: none !important; } .determine { z-index: 999; font-size: 30upx; color: #ffffff; background: #fe0036; height: 90upx; line-height: 90upx; text-align: center; position: fixed; bottom: 0; left: 0; right: 0; } /* 选了颜色加上边框 */ .active { border: 1rpx solid red !important; } &lt;/style&gt; 添加 隐藏或显示 购物车组件功能 显示组件思路:在父组件details中通过ref绑定子组件Addtocart，然后details中封装一个方法用于在子组件shopping中用$parent调用该方法来控制Addtocart组件中的数据 &lt;!-- 公用的商品sku组件 父组件通过ref可以通过这个方式 控制节点 --&gt; &lt;Addtocart ref=\"addto\"&gt;&lt;/Addtocart&gt; // 父组件details中被子组件shopping调用的方法 shoPp(){ this.$refs.addto.showCou() } // shopping调用父组件details里的sku组件 couponsFun(){ this.$parent.shoPp() } // Addtocart组件中控制显示隐藏的方法 被其他组件调用 methods:{ // 被其他组件调用显示sku组件 showCou(){ this.couponif = true } } 隐藏组件思路：给叉叉按钮或者遮罩背景添加点击事件，然后将v-if属性变为false &lt;!-- 背景遮罩层 --&gt; &lt;view class=\"Coupon-yin anim\" :catchtouchmove=\"true\" @click=\"hideCou()\"&gt;&lt;/view&gt; &lt;view class=\"commodity-right-img\" @click=\"hideCou()\"&gt; &lt;!-- 叉叉按钮 --&gt; &lt;image src=\"/static/details/guanbi.svg\" mode=\"widthFix\"&gt; 图片2 &lt;/image&gt; &lt;/view&gt; // 隐藏sku组件 hideCou(){ this.couponif = false } sku组件的确定功能点击立即购买也会显示sku组件，但是立即购买显示的sku组件的确定按钮是会跳转到付款页面，而点击加入购物车显示的sku组件的确定按钮仅仅是加入了购物车功能，在点击确定按钮时，要让按钮知道点击的目的。 所以要传值过去，让确定按钮执行相应的操作。 思路： 多写两条确定按钮，分别触发的点击事件不一样，通过v-if来选择不同的情况。 &lt;!-- 确定按钮 --&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '002'\"&gt;确定&lt;/view&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '003'\"&gt;确定&lt;/view&gt; // data中默认mean值是002 data() { return { couponif:false, //显示 或 隐藏该组件 mean: '002', // 设置一个值 002代表加入购物车 003代表直接购买 } }, // 在shopping组件中给立即购买添加相同的点击事件，但传递的参数值不同 &lt;view class=\"join join-right\" @click=\"couponsFun('002')\"&gt;加入购物车&lt;/view&gt; &lt;view class=\"join join-left\" @click=\"couponsFun('003')\"&gt;立即购买&lt;/view&gt; // 调用父组件details里的sku组件 并且将相应点击触发的值传递给父组件的shoPp方法的参数中 couponsFun(mean){ this.$parent.shoPp(mean) } // 父组件details被子组件shopping调用 同时接收子组件传递的参数值mean 最终通过ref拿到子组件sku的节点并使用其showCou方法 同时传递mean参数值 shoPp(mean){ this.$refs.addto.showCou(mean) } 请求商品sku组件的数据后台request.js配置很好接口后，到父组件details，发起请求拿到数据，并拿到轮播的第一张图片和价格、库存、商品id、标题等数据然后psuh到res[4]数据中，最后传递给子组件sku使用数据 // 请求数据方法 id是商品的id async detRequest(id) { // ...... // 商品sku组件数据 let wxsku = new this.Request(this.Urls.m().wxskuurl + '?id=' + id).modeget(); try { // 因为后期需要发起多次请求,用promise.all做一个并发请求 let res = await Promise.all([ ... , wxsku ]); console.log(' ... , 'sku组件数据',res[4]); // 获取sku数据 这里的数据来自轮播图和商品价格 let defaultdata = { image:mendata.media[0].imgArray[0], // 拿到轮播图第一张图片 price:mendata.describe.Trueprice, // 拿到价格 totalstock:mendata.describe.Total_stock, // 拿到库存 id:mendata.id, // 拿到商品id title:mendata.describe.title, // 拿到商品标题，在提交到购物车需要用到 } // 将以上数据 push到一个数组里面 即 商品sku组件数据 this.skudata = res[4].data this.skudata.push(defaultdata) console.log(this.skudata,'商品sku新数据') } catch (e) {} }, 子组件保存数据： props:{ skudata:Array, }, // watch监听数据 // 因为图片会随着选择码数时变化，所以使用监听更高效 watch:{ // 获取父组件来的sku默认展示数据 skudata(newValue,oldValue) { console.log(newValue,'sku新值'); this.id = newValue[2].id this.attribute = newValue[2] this.title = newValue[2].title } } data() { return { couponif:false, //显示 或 隐藏该组件 mean: '002', // 设置一个值 002代表加入购物车 003代表直接购买 id:'', //商品id attribute:{}, // 商品展示的sku title:'', // 商品标题 } }, sku组件中模板代码修改如下： &lt;!-- 商品图片 --&gt; &lt;view class=\"commodity-view\"&gt; &lt;view class=\"commodity-left-img\"&gt; &lt;image :src=\"attribute.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"commodity-zh\"&gt; &lt;view&gt;¥{{attribute.price}}&lt;/view&gt; &lt;view&gt;库存{{attribute.totalstock}}件&lt;/view&gt; &lt;view class=\"choice\"&gt; &lt;text&gt;请选择:&lt;/text&gt; &lt;text&gt;颜色&lt;/text&gt; &lt;text&gt;尺码&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"commodity-right-img\" @click=\"hideCou()\"&gt; &lt;!-- 叉叉按钮 --&gt; &lt;image src=\"/static/details/guanbi.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 主要颜色 --&gt; &lt;view class=\"sku-view\"&gt; &lt;text class=\"sku-title\"&gt;主要颜色&lt;/text&gt; &lt;view class=\"sku-mian\"&gt; &lt;block v-for=\"(item,index) in skudata[1]\" :key=\"index\"&gt; &lt;view &gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt; &lt;/image&gt; &lt;text&gt;{{item.color}}&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 尺寸 --&gt; &lt;view class=\"sku-view\"&gt; &lt;text class=\"sku-title\"&gt;尺码&lt;/text&gt; &lt;view class=\"sku-mian sku-two\"&gt; &lt;block v-for=\"(item,index) in skudata[0]\" :key=\"index\"&gt; &lt;view&gt;{{item}}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; 计算属性处理选中某个sku给 颜色 / 尺码 按钮添加点击事件，并且动态绑定边框变色的css属性 ，属性值默认-1，index值取自于对应的item 或 item.color // 给颜色按钮添加点击事件，并且动态绑定边框变色的css属性 &lt;view @click=\"colorFun(item.color,index)\" :class=\"{active:index == colornum}\"&gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;text&gt;{{item.color}}&lt;/text&gt; &lt;/view&gt; // 尺码添加点击事件， 并且动态绑定边框变色的css属性 &lt;block v-for=\"(item,index) in skudata[0]\" :key=\"index\"&gt; &lt;view @click=\"sizeFun(item,index)\" :class=\"{active:index == sizenum}\"&gt;{{item}}&lt;/view&gt; &lt;/block&gt; // 选择颜色 colorFun(color,index){ console.log(color,index); this.colornum = index }, // 选择尺码 sizeFun(size,index){ console.log(size,index); this.sizenum = index } 接着完成请选择：颜色 尺码 的文字动态变化 使用计算属性：choice // 选择颜色 colorFun(color,index){ console.log(color,index); this.colornum = index this.colorvalue = color //每次选中颜色后 data中的colorvalue就有值 可以将其赋值给请选择。。。 }, // 选择尺码 sizeFun(size,index){ console.log(size,index); this.sizenum = index this.sizevalue = size //每次选中尺码后 data中的sizevalue就有值 可以将其赋值给请选择。。。 } computed:{ // 选择sku的改变 choice(){ if(this.colorvalue == '' || this.sizevalue == '') { return '请选择' }else { return '已选择' } } }, **此时，在template模板中的代码块如下使用计算属性中的方法 ** &lt;view class=\"choice\"&gt; &lt;text&gt;{{choice}}:&lt;/text&gt; &lt;text&gt;颜色&lt;/text&gt; &lt;text&gt;尺码&lt;/text&gt; &lt;/view&gt; 再一次使用计算属性：skumen 完成选择颜色或者尺码时，上方主要颜色下 显示的文字 // 选择颜色或者尺码 主要颜色下显示的文字 skumen(){ // 两个都被选中 if(this.sizevalue != '' &amp;&amp; this.colorvalue != '') { // 返回一个对象 return { color:this.colorvalue,size:this.sizevalue, } // 两个都未选中 }else if(this.sizevalue == '' &amp;&amp; this.colorvalue == ''){ return { color:'主要颜色',size:'尺码', } // 假如尺码没有选择, 并且 颜色选择了 }else if(this.sizevalue == '' &amp;&amp; this.colorvalue != '') { return { color:'',size:'尺码', } // 假如尺码选择了, 并且 颜色没选择 }else if(this.sizevalue != '' &amp;&amp; this.colorvalue == '') { return { color:'主要颜色',size:'', } } } 最后当未选择商品和尺码时候 ，禁止确定按钮功能 在计算属性中，添加return的一个 键值对，当ban为true时，可以触发确定的点击功能 扩展知识：JS中的逻辑运算符&amp;&amp;、|| 只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值; 只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值; 只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。 只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。 &lt;!-- 确定按钮 --&gt; &lt;!-- 利用计算属性 如果两个未选中就禁止使用确定按钮 --&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '002'\" @click=\"skumen.ban &amp;&amp; detErmine()\"&gt;确定&lt;/view&gt; // 。。。。。。 // 选择颜色或者尺码 主要颜色下显示的文字 skumen(){ // 两个都被选中 if(this.sizevalue != '' &amp;&amp; this.colorvalue != '') { // 返回一个对象 return { color:this.colorvalue,size:this.sizevalue,ban:true } // 两个都未选中 }else if(this.sizevalue == '' &amp;&amp; this.colorvalue == ''){ return { color:'主要颜色',size:'尺码',ban:false } // 假如尺码没有选择, 并且 颜色选择了 }else if(this.sizevalue == '' &amp;&amp; this.colorvalue != '') { return { color:'',size:'尺码',ban:false } // 假如尺码选择了, 并且 颜色没选择 }else if(this.sizevalue != '' &amp;&amp; this.colorvalue == '') { return { color:'主要颜色',size:'',ban:false } } } 请求每个sku的库存、价格分析可得当同时选择了颜色和尺码，才会展示相应的价格和库存，即发起请求 this.skuing() 那么如何得知选择了尺码和颜色呢 **在监听器中，监听skumen方法返回的数据变化： ** 当得到的newValue中的color和size数据不为空，即都选择了就调用请求方法 methods：{ // 获取请求每个sku的数据 async skuRequest(obj){ try{ let querysku = await new this.Request(this.Urls.m().queryskuurl,obj).modepost(); console.log(querysku); // 刚好得到的data和之前用于展示库存、价格、图片的对象里的键值对一致 this.attribute = querysku.data[0] }catch(err){ //TODO handle the exception console.log(err); } } } watch:{ // 是否选择了尺码和颜色 skumen(newValue,oldValue){ console.log(newValue,'更新后的尺码和颜色数据'); let { color,size } = newValue if(color != '' &amp;&amp; size != '') { this.skuRequest( // 将请求需要的参数在这里放到一个对象中一个带到请求方法参数中 {id:this.id, color:color,size:size} ) } } } 商品购买数量加减对减号和加号添加点击事件，并且当数值为1时，禁用减号按钮，核心思路是利用三元表达式和 click 的false情况 &lt;!-- 购买数量 --&gt; &lt;view class=\"sku-view sku-height\" &gt; &lt;view class=\"sku-title numes\"&gt;购买数量&lt;/view&gt; &lt;view class=\"sku-mums-gight\"&gt; &lt;!-- 三元表达式 如果商品数量等于1 就禁用 - 按钮 ，否则可以使用减号按钮--&gt; &lt;view @click=\"many === 1 ? forbid==false : forbid==true &amp;&amp; reDuce()\"&gt;-&lt;/view&gt; &lt;view&gt;{{many}}&lt;/view&gt; &lt;view @click=\"pLus()\"&gt;+&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; data() { return { many:1, // 购买数量 forbid:true, // 购买数量最少为1，&lt;=1 时禁止按钮点击 } } // 数量 reDuce(){ this.many -- if(this.many === 1) { new this.$Toast('数量不能低于1','error').showtoast() } }, // 加数量 pLus(){ this.many ++ }, 加入所选商品到购物车当点击确定按钮，需要在addtoart.vue文件中获取如下的data对象中的所有数据用作请求的data参数， 拿到返回结果后，判断如果存在errcode 即没有登录，调用登录弹窗和登录请求弹窗。 如果返回的数据值 ‘SUCCESS’ ，那么隐藏sku组件，同时调用反馈弹窗，并且调用一次获取购物车件数的接口，将拿到的件数（length值）传递给shoppping.vue组件中，刷新购物车的件数 —（使用vuex传值） // 加入购物车按钮 (需要选择颜色和尺码后才能触发) detErmine(){ // 点击确定按钮 要将这里的data对象传到请求作为参数使用 let data = { id:this.id, size:this.sizevalue, color:this.colorvalue, image:this.attribute.image, price:this.attribute.price, title:this.title, many:this.many, } try{ let atcartdata = await new this.Request(this.Urls.m().atcarturl,data).modepost(); console.log(atcartdata,'加入购物车的返回数据'); if(atcartdata.msg.errcode){ // 如果errcode存在就需要登录 // 登陆这里传值过去 'coll' this.$refs.show.showing('coll') }else if(atcartdata.msg == \"SUCCESS\"){ this.hideCou() new this.$Toast('加入购物车成功','success').showtoast() //反馈 弹窗 // 相同的sku（颜色、尺码一样）加入购物车后只显示一条，仅件数变化 （后端接口已经做了处理） let mycart = await new this.Request(this.Urls.m().mycarturl).modeget(); console.log(mycart,\"购物车件数\"); } }catch(e){ //TODO handle the exception } } vuex传值到购物车的商品数量在项目根目录下新建文件夹 store，其下新建store.js // vuex存放数据，数据仓库，数据管理中心 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) // 购物车件数 const cartnum = { nums:'' } const state = { // 购物车件数 cartnum, } export default new Vuex.Store({ // 数据仓库中心 state, // 传值 // actions : 异步传值 --不能直接到达数据仓库， 组件中使用 ： store.dispatch() // getters : 类似计算属性，带有缓存，有新的值进来才会被触发 （不常用） // mutitions : 同步传值：可以直接传给state 组件中使用 ： store.commit('mutations中方法名',value) mutations:{ // 加入购物车成功后传值的购物车条数 (第一个参数是state仓库，第二个是要传递过来的值) mutacart(state,nums){ // 接收到组件传过来的值之后要存储到数据中心仓库 state.cartnum = { nums:nums } } } }) 在sku组件中，将获取到的购物车件数，存储到vuex中， // 加入购物车按钮 (需要选择颜色和尺码后才能触发) async detErmine(){ // 点击确定按钮 要将这里的data对象传到请求作为参数使用 let data = { id:this.id, size:this.sizevalue, color:this.colorvalue, image:this.attribute.image, price:this.attribute.price, title:this.title, many:this.many, } try{ let atcartdata = await new this.Request(this.Urls.m().atcarturl,data).modepost(); console.log(atcartdata,'加入购物车的返回数据'); if(atcartdata.msg.errcode){ // 如果errcode存在就需要登录 // 登陆这里传值过去 'coll' this.$refs.show.showing('coll') }else if(atcartdata.msg == \"SUCCESS\"){ this.hideCou() new this.$Toast('加入购物车成功','success').showtoast() //反馈 弹窗 // 相同的sku（颜色、尺码一样）加入购物车后只显示一条，仅件数变化 （后端接口已经做了处理） let mycart = await new this.Request(this.Urls.m().mycarturl).modeget(); console.log(mycart,\"购物车件数\"); // 使用vuex方法 将购物车件数值传递到 仓库 this.$store.commit('mutacart',mycart.data.length) } }catch(e){ //TODO handle the exception } }, 在shopping.vue组件，监听器中使用vuex的数据 watch:{ // 加入购物车成功后存储到vuex后，从vuex仓库中心拿取值；监听vuex数据中心的值变化， // 如果vuex数据中心的值变化才会被触发执行 \"$store.state.cartnum\"(newValue,oldValue) { console.log(newValue,'监听器监听vuex中购物车件数'); this.cartnum = newValue } }, 商品订单页直接下单获取待付款商品数据pages新建 payment-page目录，下方新建payment.vue,同时去page.json中引入 然后对addtocart.vue文件中的确定按钮进行添加点击事件，并配置方法， &lt;view class=\"determine coup-anim\" v-if=\"mean == '003'\" @click=\"skumen.ban &amp;&amp; purChase()\"&gt;确定&lt;/view&gt; // 直接下单 async purChase(){ // 点击确定按钮 要将这里的data对象传到请求作为参数使用，因为购物车的商品类目不止一个，所以用数组包裹很多对象 let data = [ { id:this.id, size:this.sizevalue, color:this.colorvalue, image:this.attribute.image, price:this.attribute.price, title:this.title, many:this.many, total_price:this.attribute.price * this.many, //商品总价 }, ] // 校验登录状态 try{ let tokening = await new this.Request(this.Urls.m().tokeningurl).modeget(); console.log(tokening,'检查登录状态'); if(tokening.msg.errcode == \"401\") { // 没有token 就展示登录弹窗 this.$refs.show.showing('coll') }else if(tokening.msg == \"SUCCESS\") { // 数组，对象转换成字符串才能携带值 let cartdata = JSON.stringify(data) // 跳转到下单页面 同时携带参数 uni.navigateTo({ url:'../payment-page/payment?cartdata=' + cartdata, }) } }catch(e){ //TODO handle the exception } }, // 在payment.vue组件中，使用onLoad生命周期 的e参数 接收 参数 export default { // e就是上个页面使用navigateTo路径，携带的值 --来自于addtocart组件 purChase方法 onLoad(e){ // 将JSON字符串转化为对象 console.log(JSON.parse(e.cartdata)) }, } 视图层展示待付款的商品js浮点数解决： 在上个组件addtocart中对total_price数据进行修改 *total_price:parseFloat((this.attribute.price * this.many).toFixed(10)),* //商品总价 ,解决浮点数 总价显示小数点后两位： npm i e-commerce_price // 引入下载的node库 –支付小数点后两位 价格补零const Price = require(‘e-commerce_price’) payment.vue 完整代码如下： &lt;template&gt; &lt;view&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 收货地址 --&gt; &lt;view class=\"payment-name\" &gt; &lt;view class=\"payment-left-img\"&gt; &lt;image src=\"/static/loading/address-shouhuo.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 收货地址 --&gt; &lt;view class=\"payment-add\" &gt;请选择收货地址&lt;/view&gt; &lt;view class=\"payment-right-img\"&gt; &lt;image src=\"/static/loading/shouhuo-jiantou.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 商品详情 --&gt; &lt;view class=\"payment-commodity\"&gt; &lt;block v-for=\"(item,index) in comminfo\" :key=\"index\"&gt; &lt;view class=\"payment-order\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{item.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{item.color}};尺码:{{item.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥ {{item.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{item.many}}&lt;/text&gt; &lt;/view&gt; &lt;view&gt; 共{{item.many}}件 小计: ￥ {{item.total_price}} &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 底部提交订单 --&gt; &lt;view class=\"place-order\"&gt; &lt;text&gt;合计: ￥{{Totalprice}}&lt;/text&gt; &lt;text @click=\"placeOrder()\"&gt;提交订单&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入下载的node库 --支付小数点后两位 价格补零 const Price = require('e-commerce_price') export default { data(){ return { comminfo:[], //上个页面接收的商品数据 Totalprice:0, //商品总价 小数点两位数 } }, // e就是路径上携带的值 来自于addtocart组件 purChase方法 onLoad(e){ // 将JSON字符串转化为对象 console.log(JSON.parse(e.cartdata)) this.comminfo = JSON.parse(e.cartdata) // 合计支付总价计算 numdata默认为0，使用forEach遍历 let numdata = 0 JSON.parse(e.cartdata).forEach(item=&gt;{ numdata += item.total_price }) // 合计总价 小数点两位数 this.Totalprice = Price(numdata) // 将需补0的数据传入方法 }, } &lt;/script&gt; &lt;style&gt; page{background-color: #f2f2f2;} .payment-view{margin: 15upx;} .payment-name{ height: 150upx; background-color: #FFFFFF; border-radius: 15upx; font-size: 28upx; display: flex; align-items: center; justify-content: space-between; padding: 0 10upx; } .payment-left-img{width: 60upx; height: 60upx;} .payment-left-img image{width: 60upx; height: 60upx;} .payment-add text{display: block;} .payment-add text:nth-child(2){padding: 4rpx 0;} .payment-add{flex: 1;padding-left: 20rpx;} .payment-right-img{width: 40upx; height: 40upx;} .payment-right-img image{width: 40upx; height: 40upx;} /* 下单商品 */ .payment-commodity{ background-color: #FFFFFF; border-radius: 15upx; font-size: 28upx; padding: 10rpx; margin: 15upx 0; } .payment-order{display: flex;justify-content: space-between; height: 200upx; /* background: #4CD964; */ margin-bottom: 20rpx; } .payment-order text{display: block;} .payment-order-img{width: 200upx; height: 200upx; border-radius: 8upx; padding-right: 10upx; } .payment-order-img image{width: 200upx; height: 200upx; border-radius: 8upx; } .payment-title{flex: 1;} .payment-title text:nth-child(1){ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; } .payment-title text:nth-child(2){ background-color: rgb(250, 250, 250); padding: 5upx; border-radius: 7upx; } .payment-price{text-align: right;} .payment-flex{ display: flex; flex-direction: column; justify-content: space-between;} .text-you{color: rgb(156, 156, 156); margin-top: 8upx; } /* 提交 */ .place-order{height: 90upx; background-color: #FFFFFF; position: fixed; bottom: 0; left: 0; right: 0; display: flex; align-items: center; justify-content: flex-end; } .place-order text:nth-child(2){background-color: rgb(255, 0, 54); height: 90upx; width: 270upx; color: #FFFFFF; text-align: center; line-height: 90upx; margin-left: 30upx; } &lt;/style&gt; 我的收货地址页面 在pages下新建my-address文件夹，然后在下方新建my-address.vue、new-address.vue文件 然后注册到pages.json { \"path\": \"pages/my-address/my-addres\", \"style\": { \"navigationBarTitleText\": \"我的收货地址\" } }, { \"path\": \"pages/my-address/new-address\", \"style\": { \"navigationBarTitleText\": \"新增收货地址\" } }, my-address.vue组件静态布局 &lt;template&gt; &lt;view&gt; &lt;view class=\"my-address-view\"&gt; &lt;view class=\"my-address-name\" @click=\"getAdd(item)\"&gt; &lt;text&gt;北京大学&lt;/text&gt; &lt;view class=\"my-address-adding\"&gt; &lt;text&gt;张三&lt;/text&gt; &lt;text&gt;10086&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"my-address-change\"&gt; &lt;image src=\"/static/loading/genggai.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 新增收货地址 --&gt; &lt;view class=\"button-address\" &gt; &lt;image src=\"/static/loading/xinzeng.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;新增收货地址&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { } }, methods:{ async getadd(){ try{ let atcartdata = await new this.Request(this.Urls.m().gainaddurl).modeget() console.log(atcartdata,'请求收货地址信息'); }catch(e){ //TODO handle the exception } } }, created(){ this.getadd() } } &lt;/script&gt; &lt;style&gt; page{background-color: #F2F2F2;} .my-address-view{ font-size: 30upx; background: #FFFFFF; margin: 10upx; padding: 0 10upx; border-radius: 10upx; display: flex; align-items: center; justify-content: space-between; } .my-address-name{ flex: 1; height: 130rpx; display: flex; flex-direction: column; justify-content: center; } .my-address-name view{display: flex; align-items: center;} .my-address-change{width: 50upx; height: 50upx;} .my-address-change image{width: 50upx; height: 50upx;} .my-address-adding{color: #A7A7A7; padding-top: 8upx;} .my-address-adding text:nth-child(1){padding-right: 15upx;} /* 新增收货地址 */ .button-address{ font-size: 30upx; display: flex; align-items: center; justify-content: center; height: 100upx; background: #FFFFFF; position: fixed; bottom: 0; left: 0; right: 0; } .button-address image{width: 50upx; height: 50upx; padding-right: 20upx; } &lt;/style&gt; 完成新的登录页面 在pages/components/新建login-page.vue 在里边完成登录逻辑 &lt;template&gt; &lt;view class=\"login-page\" v-if=\"login\"&gt; &lt;button type=\"primary\" open-type=\"getUserInfo\" @click=\"getUserInfo()\"&gt;登录&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入登录 import wxLogin from '../../login/login.js' export default{ data() { return { login: false } }, methods:{ showing(boll=true){ this.login = boll }, // 登录 async getUserInfo(event){ new this.$Toast('登录中').showloading() //新的登录接口：wx.getUserProfile wx.getUserProfile({ desc: '登录' }) .then(res=&gt;{ let {userInfo,errMsg} = res this.wxusEr(userInfo,errMsg) }) .catch(err=&gt;{ console.log('拒绝登录或登录失败') }) }, // 调用登录 async wxusEr(userInfo,errMsg){ try{ let data = await new wxLogin(userInfo,errMsg).loGin() // 登录成功更新需要请求的接口或者数据 this.$bus.$emit('mycart', {cart:data}) this.login = false }catch(e){ //TODO handle the exception } } } } &lt;/script&gt; &lt;style scoped&gt; .login-page{ position: fixed; left: 0; right: 0; bottom: 0; top: 0; display: flex; justify-content: center; align-items: center; background: #FFFFFF; z-index: 999; } .login-page button{ width: 350rpx; } &lt;/style&gt; 因为其他地方会用到，所以放到公共main.js中 // 引入新的登录组件 import loginpage from 'pages/commponents/login-page.vue' Vue.component('loginpage',loginpage) 引入到收货组件my-address.vue里使用 &lt;template&gt; &lt;view&gt; &lt;view class=\"my-address-view\"&gt; 。。。。。 &lt;/view&gt; &lt;!-- 新增收货地址 --&gt; 。。。。。 &lt;!-- 登录界面 --&gt; &lt;loginpage&gt;&lt;/loginpage&gt; &lt;/view&gt; &lt;/template&gt; 完整login-page.vue逻辑代码 &lt;script&gt; // 引入 微信登录逻辑 import wxLogin from '../../login/login.js' export default{ data() { return { login: false //默认不展示登录组件，除非登录接口返回数据 } }, methods:{ // 当需要展示组件时，调用这个方法 默认是true 即可以展示组件 showing(boll=true){ this.login = boll }, // 登录的方法 async getUserInfo(event){ // 显示其他的弹窗 登录时的反馈 弹窗 new this.$Toast('登录中').showloading() /*wx.getUserProfile 获取用户信息。页面产生点击事件 后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo */ //新的登录接口：wx.getUserProfile wx.getUserProfile({ desc: '登录咯' }) .then(res=&gt;{ let {userInfo,errMsg} = res // res中包含用户的个人信息 如昵称,头像等 this.wxusEr(userInfo,errMsg) }) .catch(err=&gt;{ console.log('拒绝登录或登录失败') new this.$Toast('用户取消登录','none').showtoast() //登录时的反馈 弹窗 }) }, // 调用登录 async wxusEr(userInfo,errMsg){ try{ // 微信登录逻辑 let data = await new wxLogin(userInfo,errMsg).loGin() // 登录成功后 更新需要请求的接口或者数据 emit是传值的作用 // mycart、cart随意命名 cart值是data data值是SUCCESS 在my-addres.vue中接收 $on this.$bus.$emit('mycart', {cart:data}) this.login = false }catch(e){ //TODO handle the exception } } } } &lt;/script&gt; my-address.vue组件逻辑代码 &lt;script&gt; export default { data(){ return { } }, methods:{ // 获取收货地址 async getadd(){ try{ let atcartdata = await new this.Request(this.Urls.m().gainaddurl).modeget() console.log(atcartdata,'请求到的收货地址信息'); if(atcartdata.msg.errcode) { // 需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() } }catch(e){ //TODO handle the exception } } }, created(){ this.getadd() }, mounted() { this.$bus.$on('mycart',res =&gt; { // res就是收到的值 这里是来自于loain-oage.vue中的 cart: \"SUCCESS\" console.log(res,'我是收到的data') if(res.cart == 'SUCCESS') { // 如果登录成功就 获取收货地址 this.getadd() } }) } // gainaddurl } &lt;/script&gt; 获取我的收货地址数据首次获取到的数据肯定是空的，因为没有设置过地址 对获取到的请求结果进行判断，出现errcode值就需要重新登陆，数据长度为0，展示提示新增地址的消息，最后拿到结果赋值 data(){ return { adddata:[], //存放收货地址信息 searchno:false, //默认不展示提示 } }, methods:{ // 获取收货地址 async getadd(){ try{ let atcartdata = await new this.Request(this.Urls.m().gainaddurl).modeget() console.log(atcartdata,'请求到的收货地址信息'); // 如果存在errcode值就表示没有token 没有登录 if(atcartdata.msg.errcode) { // 就需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() // 如果data长度为0,就表示收货地址为空 }else if(atcartdata.data.length === 0) { // 展示提示信息 this.searchno = true }else { // 登陆后拿到数据时赋值给一个数组中 this.adddata = atcartdata.data this.searchno = false //同时隐藏提示信息 } }catch(e){ //TODO handle the exception } } } 最终拿到数据后，遍历数据然后放到view标签中展示 &lt;template&gt; &lt;view&gt; &lt;block v-for=\"(item,index) in adddata\" :key=\"index\"&gt; &lt;view class=\"my-address-view\"&gt; &lt;view class=\"my-address-name\" @click=\"getAdd(item)\"&gt; &lt;text&gt;{{item.city + item.address}}&lt;/text&gt; &lt;view class=\"my-address-adding\"&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;text&gt;{{item.mobile}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"my-address-change\"&gt; &lt;image src=\"/static/loading/genggai.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 新增收货地址 --&gt; &lt;view class=\"button-address\" &gt; &lt;image src=\"/static/loading/xinzeng.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;新增收货地址&lt;/text&gt; &lt;/view&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 如果没有保存收货地址 就展示此处 --&gt; &lt;view class=\"empty-cart\" v-if=\"searchno\"&gt; &lt;image src=\"/static/search/sousuono.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;你还没有收货地址&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; 然后在new-address.vue文件中，进行代码编写 ：静态布局如下 主要难点是使用了 uniapp的picker选择器 picker： 从底部弹起的滚动选择器。支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。 &lt;template&gt; &lt;view class=\"new-address-view\"&gt; &lt;!-- 收货地址 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;收货城市:&lt;/view&gt; &lt;view&gt; &lt;input type=\"text\" placeholder=\"请选择收货城市\" disabled placeholder-style=\"color:#9c9c9c\" /&gt; &lt;/view&gt; &lt;view&gt; &lt;picker mode=\"region\" &gt; &lt;text&gt;选择城市&lt;/text&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 详细地址 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;详细地址:&lt;/view&gt; &lt;view&gt;&lt;input type=\"text\" placeholder=\"请填写详细地址\" placeholder-style=\"color:#9c9c9c\" /&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 联系人 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;联系人:&lt;/view&gt; &lt;view&gt;&lt;input type=\"text\" placeholder=\"请填写收货人姓名\" placeholder-style=\"color:#9c9c9c\" /&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 手机号码 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;手机号:&lt;/view&gt; &lt;view&gt;&lt;input type=\"number\" placeholder=\"请填写收货人手机号码\" placeholder-style=\"color:#9c9c9c\" /&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 保存地址 --&gt; &lt;view class=\"conServe adcolor\" &gt;保存地址&lt;/view&gt; &lt;!-- 修改地址 --&gt; &lt;!-- &lt;view class=\"conServe adcolor\" v-if=\"!nameadd\"&gt;修改地址&lt;/view&gt; --&gt; &lt;!-- 删除地址 --&gt; &lt;!-- &lt;view class=\"conServe decolor\" v-if=\"!nameadd\"&gt;删除&lt;/view&gt; --&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style scoped&gt; .new-address-view { padding: 10upx 30upx; } .new-address { height: 100upx; display: flex; align-items: center; justify-content: space-between; font-size: 28rpx; border-bottom: 1rpx solid #f0f0f0; } .new-address view:nth-child(1) { width: 150rpx; } .new-address view:nth-child(2) { flex: 1; } .new-address view:nth-child(3) { color: #4cd964; } /* 保存 */ .conServe { height: 80rpx; font-size: 30rpx; border-radius: 10rpx; font-weight: bold; display: flex; align-items: center; justify-content: center; margin-top: 30rpx; } .adcolor { background: linear-gradient(to right, #ffd300, #e6be00); } .decolor { background-color: red; color: #ffffff; } &lt;/style&gt; 在选择城市这里，添加**@change事件 – value 改变时触发 change 事件，event.detail = {value: value}** 然后把e里边拿到的数据赋值给city，然后将city字符串通过 v-model绑定到 input标签中， 其他input也通过v-model绑定数据到data中 &lt;!-- 收货城市 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;收货城市:&lt;/view&gt; &lt;view&gt; &lt;input type=\"text\" v-model=\"city\" placeholder=\"请选择收货城市\" disabled placeholder-style=\"color:#9c9c9c\" /&gt; &lt;/view&gt; &lt;view&gt; &lt;picker mode=\"region\" @change=\"regionChange\"&gt; &lt;text&gt;选择城市&lt;/text&gt; &lt;/picker&gt;y &lt;/view&gt; &lt;!-- 详细地址 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;详细地址:&lt;/view&gt; &lt;view&gt; &lt;input type=\"text\" v-model=\"address\" placeholder=\"请填写详细地址\" placeholder-style=\"color:#9c9c9c\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 联系人 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;联系人:&lt;/view&gt; &lt;view&gt; &lt;input type=\"text\" v-model=\"name\" placeholder=\"请填写收货人姓名\" placeholder-style=\"color:#9c9c9c\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 手机号码 --&gt; &lt;view class=\"new-address\"&gt; &lt;view&gt;手机号:&lt;/view&gt; &lt;view&gt; &lt;input type=\"number\" v-model=\"mobile\" placeholder=\"请填写收货人手机号码\" placeholder-style=\"color:#9c9c9c\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; data() { return { city:'', address:'', name:'', mobile:'', } }, methods:{ // 省市区选择 e里边包含了选择的城市数据 regionChange(e){ // console.log(e.detail) let values = e.detail.value // 浙江省 杭州市 上城区 var str = '' //空字符串 values.forEach((item) =&gt; { str += item + ' ' }) this.city = str }, } 新增收货地址拿到用户填写的收货地址数据后，需要点击保存地址按钮提交数据到后台， 在new-address.vue 中，给按钮绑定点击事件preTion( ),在事件中发起请求，声明一个对象保存需要的参数数据，作为请求的参数使用，并且请求成功和失败时候设置对应的提示弹窗， &lt;script&gt; export default { data() { return { city:'', address:'', name:'', mobile:'', } }, methods:{ // 省市区选择 e里边包含了选择的城市数据 regionChange(e){ // console.log(e.detail) let values = e.detail.value // 浙江省 杭州市 上城区 var str = '' //空字符串 values.forEach((item) =&gt; { str += item + ' ' }) this.city = str }, // 保存并提交收货地址 async preTion(){ new this.$Toast('正在提交中','loading').showloading() //反馈 弹窗 let obj = { city:this.city, address:this.address, name:this.name, mobile:this.mobile } try{ let sudeadd = await new this.Request(this.Urls.m().sudeaddurl,obj).modepost() console.log(sudeadd,'提交保存的收货地址'); if(sudeadd.msg == 'SUCCESS') { new this.$Toast('提交成功').showtoast() //反馈 弹窗 // 完成自动返回到上一级页面 setTimeout(()=&gt;{ uni.navigateBack({ data: 1 }) },200) }else { new this.$Toast(sudeadd.msg,'none').showtoast() //反馈 弹窗 } // 如果出现errcode 就表示没有登录 if(sudeadd.msg.errcode) { // 就需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() uni.hideLoading(); } }catch(e){ //TODO handle the exception } } } } &lt;/script&gt; 当新增保存地址后，完成自动返回到上一级页面 if(sudeadd.msg == 'SUCCESS') { new this.$Toast('提交成功').showtoast() //反馈 弹窗 setTimeout(()=&gt;{ uni.navigateBack({ data: 1 }) },200) }else { new this.$Toast(sudeadd.msg,'none').showtoast() //反馈 弹窗 } 上一级页面 my-address.vue 中每次进入页面要刷新一下 收货地址 methods:{ // 获取收货地址 async getadd(){ try{ let atcartdata = await new this.Request(this.Urls.m().gainaddurl).modeget() console.log(atcartdata,'请求到的收货地址信息'); // 如果存在errcode值就表示没有token 没有登录 if(atcartdata.msg.errcode) { // 就需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() // 如果data长度为0,就表示收货地址为空 }else if(atcartdata.data.length === 0) { // 展示提示信息 this.searchno = true }else { // 登陆后拿到数据时赋值给一个数组中 this.adddata = atcartdata.data this.searchno = false //同时隐藏提示信息 } }catch(e){ //TODO handle the exception } }, // 点击新增收货地址按钮 chAnge(){ uni.navigateTo({ url:'./new-address' }) } }, // onShow生命周期 表示:无论从什么页面返回,都会再一次执行下面的方法 onShow(){ this.getadd() }, 实现收货地址的修改功能 点击修改图标，进入修改地址页面，可以编辑和删除 给点击事件传递两个值，第一个001代表修改收货地址，002代表新增收货地址，第二个参数item，包含了地址的详细信息，是放到修改点击事件里 &lt;block v-for=\"(item,index) in adddata\" :key=\"index\"&gt; &lt;view class=\"my-address-view\"&gt; &lt;view class=\"my-address-name\" @click=\"getAdd(item)\"&gt; &lt;text&gt;{{item.city + item.address}}&lt;/text&gt; &lt;view class=\"my-address-adding\"&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;text&gt;{{item.mobile}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 传值 001表示修改 同时将item传递过去--&gt; &lt;view class=\"my-address-change\" @click=\"chAnge('001',item)\"&gt; &lt;image src=\"/static/loading/genggai.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 新增收货地址 --&gt; &lt;!-- 传值 002表示新增收货 --&gt; &lt;view class=\"button-address\" @click=\"chAnge('002')\"&gt; &lt;image src=\"/static/loading/xinzeng.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;新增收货地址&lt;/text&gt; &lt;/view&gt; // 新增收货地址 同时也修改地址 传递参数判断 点击后跳转的页面,将参数转为json字符串添加到要跳转链接后边 chAnge(value = '002',data=[]){ let obj = { value,data } let str = JSON.stringify(obj) uni.navigateTo({ url:'./new-address?value=' + str }) } 在new-address.vue中，接收数据 同时调用获取按钮的方法，接收到的数据传入useradd方法中 从而变更data中控制v-if的值，达到显示需要的按钮， 同时，将数据解构出来，赋值给data中数据，即页面显示的收货地址信息填充为用户之前输入的信息 &lt;!-- 保存地址 --&gt; &lt;view class=\"conServe adcolor\" @click=\"preTion()\" v-if=\"nameadd\"&gt;保存地址&lt;/view&gt; &lt;!-- 修改地址 --&gt; &lt;view class=\"conServe adcolor\" @click=\"preTion()\" v-if=\"!nameadd\"&gt;修改地址&lt;/view&gt; &lt;!-- 删除地址 --&gt; &lt;view class=\"conServe decolor\" @click=\"preTion()\" v-if=\"!nameadd\"&gt;删除地址&lt;/view&gt; // 获取用户从那个按钮点击进来的 useradd(data){ // 修改地址或者删除地址 if(data.value == '001') { this.nameadd = false // 将接收的到数据解构出来存储 let { city,address,mobile,name,_id } = data.data this.city = city this.address = address this.name = name this.mobile = mobile this.id = _id }else { this.nameadd = true } } // e 里边包含了上个组件传递的数据 onLoad(e) { console.log(e,'接收到上个组件的数据'); // JSON.parse(e.value) json字符串还原为js对象 this.useradd(JSON.parse(e.value)) } 更改删除收货地址在new-address.vue中 &lt;!-- 修改地址 --&gt; &lt;view class=\"conServe adcolor\" @click=\"modifyAdd()\" v-if=\"!nameadd\"&gt;修改地址&lt;/view&gt; &lt;!-- 删除地址 --&gt; &lt;view class=\"conServe decolor\" @click=\"deleteAdd()\" v-if=\"!nameadd\"&gt;删除地址&lt;/view&gt; 修改收货地址方法 // 修改收货地址 async modifyAdd(){ new this.$Toast('正在修改中','loading').showloading() //反馈 弹窗 let obj = { id:this.id, city:this.city, address:this.address, name:this.name, mobile:this.mobile, } try{ let modifyadd = await new this.Request(this.Urls.m().modifyaddurl,obj).modepost() console.log(modifyadd,'修改收货地址') if(modifyadd.msg == 'SUCCESS') { new this.$Toast('修改成功').showtoast() //反馈 弹窗 setTimeout(()=&gt;{ uni.navigateBack({ data: 1 }) },200) }else { new this.$Toast(modifyadd.msg,'none').showtoast() //反馈 弹窗 } // 如果出现errcode 就表示没有登录 if(modifyadd.msg.errcode) { // 就需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() uni.hideLoading(); } }catch(e){ //TODO handle the exception } }, 删除收货地址方法 // 删除收货地址 async deleteAdd(){ new this.$Toast('删除中','loading').showloading() //反馈 弹窗 let id = this.id try{ let deleadd = await new this.Request(this.Urls.m().deleaddurl + '?id=' + id).modeget() // console.log(deleadd,'删除收货地址') if(deleadd.msg == 'SUCCESS') { new this.$Toast('删除成功').showtoast() //反馈 弹窗 setTimeout(()=&gt;{ uni.navigateBack({ data: 1 }) },500) }else { new this.$Toast(deleadd.msg,'none').showtoast() //反馈 弹窗 } // 如果出现errcode 就表示没有登录 if(deleadd.msg.errcode) { // 就需要登录 使用ref获取登录组件的节点 然后调用节点下的控制展示组件的方法showing() this.$refs.loginmen.showing() uni.hideLoading(); } }catch(e){ //TODO handle the exception } } 商品订单页选择收货地址提交订单页面 –payment.vue 给 “请选择收货地址” 添加点击事件 @click=”shAddress()**，跳转到我的收货地址 – **my-address.vue组件中 &lt;!-- 收货地址 --&gt; &lt;view class=\"payment-name\" @click=\"shAddress()\"&gt; &lt;view class=\"payment-left-img\"&gt; &lt;image src=\"/static/loading/address-shouhuo.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 收货地址 --&gt; &lt;view class=\"payment-add\" v-if=\"nameadd\"&gt; &lt;text&gt;{{orderdata.name}}&lt;/text&gt; &lt;text&gt;{{orderdata.mobile}}&lt;/text&gt; &lt;text&gt;{{orderdata.city + orderdata.address}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-add\" v-if=\"!nameadd\"&gt;请选择收货地址&lt;/view&gt; &lt;view class=\"payment-right-img\"&gt; &lt;image src=\"/static/loading/shouhuo-jiantou.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; methods:{ // 选择收货地址 shAddress(){ //跳转到我的收货地址 -- myaddress.vue组件中 uni.navigateTo({ url:'../my-address/my-addres', }) } }, my-address.vue组件中，添加点击地址后的事件**@click=”getAdd(item)”**，同时拿到包含收货地址详细信息的item作为参数， 在方法中，调用 **this.$store.commit(‘mutaadd’,item)**，将item传入vuex的mutation中的mutaadd方法中，将item赋值给state中的addordr。 接着uni.navigateBack 返回上一级 payment.vue &lt;!-- 新增收货地址页面 --&gt; &lt;block v-for=\"(item,index) in adddata\" :key=\"index\"&gt; &lt;view class=\"my-address-view\"&gt; &lt;!-- 设置点击地址后的点击事件 --&gt; &lt;view class=\"my-address-name\" @click=\"getAdd(item)\"&gt; &lt;text&gt;{{item.city + item.address}}&lt;/text&gt; &lt;view class=\"my-address-adding\"&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;text&gt;{{item.mobile}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 传值 001表示修改 同时将item传递过去--&gt; &lt;view class=\"my-address-change\" @click=\"chAnge('001',item)\"&gt; &lt;image src=\"/static/loading/genggai.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; // 选中某个收货地址 携带数据返回上一级订单页面 getAdd(item){ // 使用vuex传值 将这item传值到state中 this.$store.commit('mutaadd',item) uni.navigateBack({ data:1 }) }, payment.vue中设置监听器，监听state中addordr是否变化，将变化后的数据（ 即收货地址信息）赋值给 this.orderdata， 最后计算属性中，nameadd()方法，判断 转化为JSON字符串的this.orderdata是否为空，空的话nameadd返回false，否则true。即控制显示的是否显示请选择收货地址还是已经选择的收货地址 watch:{ // 监听vuex的收货地址数据 newValue里边就包含了vuex里的数据 \"$store.state.addordr\"(newValue,oldValue) { console.log(newValue,'监听到的新值'); this.orderdata = newValue.address } }, computed:{ // 是否选择了收货地址 nameadd(){ if(JSON.stringify(this.orderdata) === \"{}\") { return false }else { return true } } } 微信支付获取支付所需数据，以及try{}catch{}的应用payment.vue组件，点击提交订单按钮的点击事件 代码如下： &lt;!-- 底部提交订单 --&gt; &lt;view class=\"place-order\"&gt; &lt;text&gt;合计: ￥{{Totalprice}}&lt;/text&gt; &lt;text @click=\"placeOrder()\"&gt;提交订单&lt;/text&gt; &lt;/view&gt; // 提交订单 async placeOrder(){ // 商品数据 通过对comminfo数据进行map方法遍历，会返回一个新的数组对象 let codata = this.comminfo.map(item =&gt; { let data ={ id:item.id, image:item.image, title:item.title, size:item.size, color:item.color, price:item.price, many:item.many } return data }) // 准备一个对象 将请求需要的参数放入 let dataobj = { consignee:this.orderdata, // 收货地址相关数据 commodity:codata, // 商品相关数据 total_price:this.Totalprice, // 商品总价数据 idcard:this.idcard, // 购物车内所有商品的id相关数据 } // 1.请求统一下单 接口 try{ let wxpayurl = await new this.Request(this.Urls.m().wxpay,dataobj).modepost(); console.log(wxpayurl); if(wxpayurl.msg == \"SUCCESS\") { }else { // throw 用来捕获一个错误 如果try 中出现throw关键词，就会进入catch里面来 throw wxpayurl.msg } }catch(e){ // e就是throw 捕获的错误 new this.$Toast(e,'none').showtoast() //反馈 弹窗 throw e //如果try 中出现throw关键词，此时try catch 后边的代码将不会执行 } // 2.调用微信支付接口 } wx.requestpayment()调起微信付款payment.vue组件中，点击提交订单后。 原本在请求接口时，是调用wxpay接口 – var wxpay = await new this.Request(this.Urls.m().wxpay,dataobj).modepost();但因为个人没有微信商户号，所以这里使用的是虚拟支付接口fictpay –let fictpay = await new this.Request(this.Urls.m().fictpay,dataobj).modepost(); 携带参数完整时， 返回结果是”SUCCESS” methods中方法如下： // 选择收货地址 shAddress(){ uni.navigateTo({ url:'../my-address/my-addres', }) }, // 提交订单 async placeOrder(){ // 商品数据 通过对comminfo数据进行map方法遍历，会返回一个新的数组对象 let codata = this.comminfo.map(item=&gt;{ let data ={ id:item.id, image:item.image, title:item.title, size:item.size, color:item.color, price:item.price, many:item.many, } return data }) // 准备一个对象 将请求需要的参数放入 let dataobj = { consignee:this.orderdata, // 收货地址相关数据 commodity:codata, // 商品相关数据 total_price:this.Totalprice, // 支付总价数据 idcard:this.idcard, // 购物车内所有商品的id相关数据 } // 1.请求统一下单接口 try{ // 微信支付: 统一下单接口 // 因为个人没有认证微信商户号，这里使用的是虚拟支付接口 返回结果是\"SUCCESS\" let fictpay = await new this.Request(this.Urls.m().fictpayurl,dataobj).modepost(); if(fictpay.msg == \"SUCCESS\") { new this.$Toast(fictpay.data,'none').showtoast() //反馈 弹窗 }else { // throw 用来捕获一个错误 如果try 中出现throw关键词，就会进入catch里面来 throw fictpay.msg } }catch(e){ // e就是throw 捕获的错误 new this.$Toast(e,'none').showtoast() //反馈 弹窗 // throw e //如果try 中出现throw关键词，此时try catch 后边的代码将不会执行 } // 2.调用微信支付接口 // 3.查询订单是否支付成功 }, 当拥有微信商户认证时候，发起真正的请求时， 使用 wxpay接口 – var wxpay = await new this.Request(this.Urls.m().wxpay,dataobj).modepost(); methods中方法如下： methods:{ // 选择收货地址 shAddress(){ uni.navigateTo({ url:'../my-address/my-addres', }) }, // 提交订单 async placeOrder(){ // 商品数据 通过对comminfo数据进行map方法遍历，会返回一个新的数组对象 let codata = this.comminfo.map(item=&gt;{ let data ={ id:item.id, image:item.image, title:item.title, size:item.size, color:item.color, price:item.price, many:item.many, } return data }) // 准备一个对象 将请求需要的参数放入 let dataobj = { consignee:this.orderdata, // 收货地址相关数据 commodity:codata, // 商品相关数据 total_price:this.Totalprice, // 支付总价数据 idcard:this.idcard, // 购物车内所有商品的id相关数据 } // 1.请求统一下单接口 try{ // 微信支付: 统一下单接口 var wxpay = await new this.Request(this.Urls.m().wxpay,dataobj).modepost(); if(wxpay.msg == \"SUCCESS\") { // 存储商户订单号和订单id this.outno = wxpayurl.data.out_trade_no this.ide = wxpayurl.data.id new this.$Toast(wxpay.data,'none').showtoast() //反馈 弹窗 }else { // throw 用来捕获一个错误 如果try 中出现throw关键词，就会进入catch里面来 throw wxpay.msg } }catch(e){ // e就是throw 捕获的错误 new this.$Toast(e,'none').showtoast() //反馈 弹窗 throw e //如果try 中出现throw关键词，此时try catch 后边的代码将不会执行即不会调用下边的微信接口 } // 2.调用微信支付接口 try{ // package：属于源码里的关键词 因此这个参数不能解构使用 而是：package:wxpay.data.package // 从真正的微信支付接口中拿到返回结果，这4（5）个数据用于调用微信支付接口时作为参数， let { nonceStr,paySign,signType,timeStamp } = wxpay.data // 使用下方调用支付的方法 wxPay(payment) let wxpay = await this.wxPay({ nonceStr,paySign,signType,timeStamp,package:wxpay.data.package }) console.log(wxpay) }catch(e){ new this.$Toast('支付失败','none').showtoast() //反馈 弹窗 throw e } }, // 调用支付的方法：包装一个promise // payment就是接收到的5个数据，用于调用微信支付接口的参数 wxPay(payment){ return new Promise((resolve,reject) =&gt; { wx.requestpayment({ ...payment, success:res=&gt;{ resolve(res) }, fail:Error=&gt;{ reject(Error) } }) }) } } 查询订单是否支付成功// 3.查询订单是否支付成功 （去微信那边查询是否成功） try{ let dataobj = {outno:this.outno,id:this.ide} let queryorderurl = await new this.Request(this.Urls.m().queryorderurl,dataobj).modepost() if(queryorderurl.data.msg == 'SUCCESS') { new this.$Toast('支付成功').showtoast() //反馈 弹窗 }else { throw '支付失败' } }catch(e){ new this.$Toast(e,'none').showtoast() //反馈 弹窗 } 动态路由跳转详情页在pages.json文件中，将首页排到首位 完成轮播页，点击图片跳转到对应页面功能 在pages/index/sonzhujian/swipers.vue下,添加点击事件 deTails(item._id) deTails( item._id ）这里的 _id 就是通过轮播接口，返回的成功数据中的_id ，表示商品的唯一标识 &lt;swiper-item&gt; //这里的 _id 就是通过轮播接口，返回的成功数据中的_id表示商品的唯一标识 &lt;view class=\"swiper-item\" @click=\"deTails(item._id)\"&gt; &lt;!-- mode 图片裁剪、缩放的模式 --&gt; &lt;img :src=item.image mode=\"aspectFill\"&gt; &lt;/view&gt; &lt;/swiper-item&gt; // 跳转到详情页 deTails(id) { uni.navigateTo({ // 跳转到详情页组件，同时携带商品id参数 url:'../details/details?id=' + id }) } 完成快抢购页，点击图片跳转到对应页面功能 在pages/index/sonzhujian/purchhase.vue下,添加点击事件 deTails(item._id) &lt;view class=\"pur-img\"&gt; &lt;block v-for=\"(item,index) in recomdata[0].image\" :key=\"index\"&gt; &lt;view&gt; &lt;image :src=\"item.img\" mode=\"widthFix\" @click=\"daTails(item._id)\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; // 跳转到详情页 deTails(id) { uni.navigateTo({ // 跳转到详情页组件，同时携带商品id参数 url:'../details/details?id=' + id }) } 完成天猫榜单页，点击图片跳转到对应页面功能 在pages/index/sonzhujian/list.vue下,添加点击事件 deTails(item._id) &lt;block v-for=\"(item, index) in billdata\" :key=\"index\"&gt; &lt;view class=\"menb\" @click=\"deTails(item._id)\"&gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;text&gt;{{ item.title }}&lt;/text&gt; &lt;text&gt;{{ item.want }}人想要&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; // 跳转到详情页 deTails(id) { uni.navigateTo({ // 跳转到详情页组件，同时携带商品id参数 url:'../details/details?id=' + id }) } 完成卡片流页，点击图片跳转到对应页面功能 在pages/commponents/card.vue下,添加点击事件 deTails(item._id) &lt;block v-for=\"(item,index) in commdata\" :key=\"index\"&gt; &lt;view class=\"comm-card\" @click=\"deTails(item._id)\"&gt; &lt;view class=\"comm-img\"&gt;&lt;image :src=\"item.image\" mode=\"aspectFill\" /&gt;&lt;/view&gt; &lt;view class=\"comm-title\"&gt;&lt;text&gt;{{item.title}}&lt;/text&gt;&lt;/view&gt; &lt;view class=\"comm-left\"&gt; &lt;text&gt;{{item.freight}}&lt;/text&gt; &lt;text&gt;预计{{item.Duration}}h发货&lt;/text&gt; &lt;/view&gt; &lt;view class=\"comm-right\"&gt;{{item.Price}}￥&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; // 跳转到详情页 deTails(id) { uni.navigateTo({ // 跳转到详情页组件，同时携带商品id参数 url:'../details/details?id=' + id }) } 完成右上角按钮的返回功能 进入pages/details/details.vue文件 &lt;!-- 返回按钮 --&gt; &lt;view class=\"header-fixed backno\" v-show=\"showAbs\"&gt; &lt;!-- 箭头符号设置的动态的高 --&gt; &lt;view class=\"status_bar\" :style=\"'height: ' + tophight.top + 'px;'\"&gt;&lt;/view&gt; &lt;view class=\"navs-image\" :style=\"'height: ' + tophight.height + 'px;'\" @click=\"pageRe()\" &gt; &lt;image src=\"/static/details/fanhuibai.jpg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; // 返回上级页面 按钮 pageRe(){ uni.navigateBack({ data:1 }) } 同时给top.vue组件中的左上角按钮 也设置点击事件 &lt;view class=\"navs-image\" :style=\" 'height:'+ tophight.height + 'px;'\" @click=\"pageRe()\" &gt; &lt;image src=\"/static/details/fanhuihei.png\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; // 返回上级页面 按钮 pageRe(){ uni.navigateBack({ data:1 }) } 个人中心页面静态布局 &lt;template&gt; &lt;view class=\"my-view\"&gt; &lt;view class=\"my-view-user\"&gt; &lt;view&gt; &lt;image src=\"/static/details/weidenglu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"my-view-name\"&gt; &lt;button plain=\"true\" open-type=\"getUserInfo\" @click=\"getUserInfo()\"&gt;点击登录&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 菜单 --&gt; &lt;view class=\"my-menu\"&gt; &lt;block v-for=\"(item,index) in datas\" :key=\"index\"&gt; &lt;view &gt; &lt;image :src=\"item.img\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;{{item.name}}&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { datas:[ { 'img':'/static/details/daifukuan.svg', 'name':'待付款' }, { 'img':'/static/details/daifahuo.svg', 'name':'待发货' }, { 'img':'/static/details/daishouhuo.svg', 'name':'待收货' }, { 'img':'/static/details/daipingjia.svg', 'name':'待评价' } ], usering:true, userdata:{} } } } &lt;/script&gt; &lt;style scoped&gt; .my-view{ background: linear-gradient(to top, #ff0714 10%, #ff3388 100%); height: 500upx; border-bottom-left-radius: 50upx; border-bottom-right-radius: 50upx; position: relative; } .my-view-user{height: 100upx; display: flex; align-items: center; position: absolute; left: 50upx; top: 170upx; /* width: 100%; */ color: #FFFFFF; } .my-view-user text{display: block;} .my-view-user image{width: 100upx; height: 100upx; border-radius: 50%;} .my-view-user view:nth-child(1){width: 100upx; height: 100upx;} .my-view-name text{font-size: 32upx;} .my-view-name button{border: none;font-size: 32upx; color: #FFFFFF; padding: 0 !important; } .my-view-name{padding-left: 20upx;} .my-menu{height: 200upx; background: #FFFFFF; position: absolute; top: 350upx; left: 35upx; right: 35upx; border-radius: 10upx; /* margin: 0 35upx; */ box-shadow: 0upx 10rpx 10rpx #e9e9e9; display: flex; align-items: center; justify-content: space-around; font-size: 28upx; } .my-menu image{width: 45upx; height: 45upx; display: block; align-self: center; padding-bottom: 10upx; } .my-menu view{ display: flex; flex-direction: column; } &lt;/style&gt; 当本地存在token时候，显示个人信息： 使用v-if 和 v-else来判断头像和个人名称的显示 取出本地token，如果取不到就显示请登录，取到数据吧表示已经登录，则显示个人头像和名称 &lt;view class=\"my-view-user\"&gt; &lt;view&gt; &lt;image v-if=\"usering\" src=\"/static/details/weidenglu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;image v-else :src=\"userdata.avatarUrl\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"my-view-name\"&gt; &lt;button v-if=\"usering\" plain=\"true\" open-type=\"getUserInfo\" @click=\"getUserInfo()\"&gt;点击登录&lt;/button&gt; &lt;text v-else &gt;{{userdata.nickName}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; methods:{ // 取出本地 ifUser(){ let user = uni.getStorageSync('wxuser') console.log(user); if(!user){ this.usering = true }else { this.usering = false this.userdata = user } } }, onShow() { this.ifUser() } 当本地没有token时，点击按钮登录事件 &lt;button v-if=\"usering\" plain=\"true\" open-type=\"getUserInfo\" @click=\"getUserInfo()\"&gt;点击登录&lt;/button&gt; // 引入 微信登录逻辑 import wxLogin from '../../login/login.js' // 触发登录事件 getUserInfo(){ // 显示其他的弹窗 登录时的反馈 弹窗 new this.$Toast('登录中').showloading() /*wx.getUserProfile 获取用户信息。页面产生点击事件 后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo */ //新的登录接口：wx.getUserProfile wx.getUserProfile({ desc: '登录咯' }) .then(res=&gt;{ let {userInfo,errMsg} = res // res中包含用户的个人信息 如昵称,头像等 this.wxusEr(userInfo,errMsg) }) .catch(err=&gt;{ console.log('拒绝登录或登录失败') new this.$Toast('用户取消登录','none').showtoast() //登录时的反馈 弹窗 }) }, // 调用登录 async wxusEr(userInfo,errMsg){ try{ // 微信登录逻辑 let data = await new wxLogin(userInfo,errMsg).loGin() this.ifUser() //登录成功后刷新一下本组件 }catch(e){ //TODO handle the exception } } 订单中心页面需求：点击待付款或者待发货应该跳转到订单中心 在pages/新建 personal文件夹/personal.vue 静态布局 &lt;template&gt; &lt;view&gt; &lt;view class=\"choice-tips\"&gt; &lt;block v-for=\"(item, index) in datas\" :key=\"index\"&gt; &lt;!-- 如果下标index 等于 num值，就让当前下标对应的标签拥有 activetext css属性 --&gt; &lt;text :class=\"{ activetext: index == num }\" @click=\"menubtn(index)\"&gt;{{ item }}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- &lt;view class=\"choice-content\"&gt; &lt;Tobepaid v-if=\"num == 0 ? true : false\"&gt;&lt;/Tobepaid&gt; &lt;Deliverde v-if=\"num == 1 ? true : false\"&gt;&lt;/Deliverde&gt; &lt;Received v-if=\"num == 2 ? true : false\"&gt;&lt;/Received&gt; &lt;Evaluated v-if=\"num == 3 ? true : false\"&gt;&lt;/Evaluated&gt; &lt;/view&gt; --&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 0, datas: ['待付款', '待发货', '待收货', '待评价'] }; }, methods: { menubtn(index) { this.num = index; } }, onLoad(e) { this.num = e.index; } }; &lt;/script&gt; &lt;style&gt; page { background: #eeeeee; } .choice-tips { background: #d9ffe7; display: flex; justify-content: space-around; color: #6d6d6d; font-size: 28upx; position: fixed; top: 0; left: 0; right: 0; } .choice-tips text { height: 70upx; line-height: 70upx; } .activetext { color: #fe0036 !important; border-bottom: 4upx solid #fe0036; } .choice-content { margin-top: 100upx; } &lt;/style&gt; 针对订单中心的四个板块，分别创建子组件 在pages/personal/创建 sonzujian文件夹, 在sonzujian文件夹下新建 待付款组件 tobepaid.vue、待发货组件 delivered.vue、待收货组件 received.vue、待评价组件 evaluated.vue 通过 三元表达式，对num值是否等于index值作判断，从而显示或隐藏子组件 &lt;!-- 展示子组件 --&gt; &lt;view class=\"choice-content\"&gt; &lt;!-- 显示的条件是 num的值是否和当前的index下标对上 --&gt; &lt;Tobepaid v-if=\"num == 0 ? true : false\"&gt;&lt;/Tobepaid&gt; &lt;Delivered v-if=\"num == 1 ? true : false\"&gt;&lt;/Delivered&gt; &lt;Received v-if=\"num == 2 ? true : false\"&gt;&lt;/Received&gt; &lt;Evaluated v-if=\"num == 3 ? true : false\"&gt;&lt;/Evaluated&gt; &lt;/view&gt; // 引入子组件 import tobepaid from './sonzujian/tobepaid.vue' import delivered from './sonzujian/delivered.vue' import received from './sonzujian/received.vue' import evaluated from './sonzujian/evaluated.vue' 获取待付款订单tobepaid 静态布局代码： css样式 引入的是style里的公共样式 没有商户号是无法拿到待付款数据 &lt;template&gt; &lt;!-- 待付款组件 --&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 商品详情 --&gt; &lt;view class=\"payment-commodity\"&gt; &lt;text class=\"order-tips\" v-if=\"item.expire\"&gt;该订单已过期&lt;/text&gt; &lt;text class=\"order-tips\" v-else&gt;等待买家付款&lt;/text&gt; &lt;view class=\"payment-order\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image src=\"iteming.image\" mode=\"aspectFill\"&gt;图片1&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;标题&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:黑色;尺码:L&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥0.6&lt;/text&gt; &lt;text class=\"text-you\"&gt;x2&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;需付款￥1.2&lt;/view&gt; &lt;!-- 付款 --&gt; &lt;view class=\"presonal-payment\"&gt; &lt;text&gt;付款&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 登录界面弹窗 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公共样式 import '../../../style/order.css' export default { data(){ return{ } }, methods:{ // 获取待付款数据 async Tobepaid() { try{ let topebaid = await new this.Request(this.Urls.m().topebaidurl).modeget(); // 如果没有添加购物数据 if(topebaid == 'Not Found') { console.log('没有商户号，不会有待付款数据'); } }catch(e){ } }, }, created() { this.Tobepaid() } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 假如有商户号代码如下 （使用一些假数组数据） &lt;template&gt; &lt;!-- 待付款组件 --&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 商品详情 --&gt; &lt;!-- 遍历商品条数和数据 --&gt; &lt;block v-for=\"(item,index) in topebaid\" :key=\"index\"&gt; &lt;view class=\"payment-commodity\"&gt; &lt;!-- 两种情况：1、订单没有过期时候，俩小时内发起付款没有支付，俩小时内可以再次付款，2、俩小时之后就不能再付款了，商品显示该订单已过期 --&gt; &lt;text class=\"order-tips\" v-if=\"item.expire\"&gt;该订单已过期&lt;/text&gt; &lt;text class=\"order-tips\" v-else&gt;等待买家付款&lt;/text&gt; &lt;!-- 遍历商品里面 因为可能支付时候不止一个商品 --&gt; &lt;block v-for=\"(iteming,indexs) in item.order\" :key=\"indexs\"&gt; &lt;view class=\"payment-order\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"iteming.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{iteming.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{iteming.color}};尺码:{{iteming.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥{{iteming.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{iteming.many}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;需付款￥{{item.total_price}}&lt;/view&gt; &lt;!-- 付款 --&gt; &lt;view class=\"presonal-payment\"&gt; &lt;!-- 如果过期，就显示删除订单 否则可以付款--&gt; &lt;text v-if=\"item.expire\"&gt;删除订单&lt;/text&gt; &lt;text v-else&gt;付款&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 没有订单数据 --&gt; &lt;!-- &lt;ordering ref=\"orderload\"&gt;&lt;/ordering&gt; --&gt; &lt;!-- 登录界面弹窗 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公共样式 import '../../../style/order.css' export default { data(){ return{ topebaid:[ { expire:false, total_price:169, order: [ { color:'5526网面-天空蓝', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:169, size:\"37\", title:\"耐克新款2022 女生白色皮面鞋子高级【店长推荐】\" }, ] }, { expire:true, total_price:200, order: [ { color:'5526网面-渣渣灰', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:200, size:\"41\", title:\"361新款2022 男生灰色皮面鞋子【店长推荐】\" }, ] }, ], } }, methods:{ // 获取待付款数据 async Tobepaid() { try{ let topebaid = await new this.Request(this.Urls.m().topebaidurl).modeget(); // 如果没有添加购物数据 if(topebaid == 'Not Found') { console.log('没有商户号，不会有待付款数据'); } // 如果未登录 调用登录弹窗 if(topebaid.msg.errcode) { this.$refs.loginmen.showing() // 如果登录成功后 }else if(topebaid.msg == 'SUCCESS') { // 没有待付款数据 if(topebaid.data.length == 0) { }else { this.topebaid = topebaid.data } } }catch(e){ } }, }, created() { this.Tobepaid() }, // 接收登录组件传递的值 登录成功后也要刷新数据 mounted() { this.$bus.$on('mycart',res=&gt;{ // 当登录成功后 if(res.cart == 'SUCCESS'){ // 调用方法刷新数据 this.Tobepaid() } }) } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 订单的详情页准备一个没有订单时候，页面的展示效果提示 pages/commponents **下新建 **ordering.vue， 静态布局 &lt;template&gt; &lt;!-- 没有订单数据 --&gt; &lt;view class=\"empty-cart\" v-if=\"emcart\"&gt; &lt;image src=\"http://h.thexxdd.cn/video/tianmao/noorder.png\" mode=\"aspectFit\"&gt;&lt;/image&gt; &lt;text&gt;没有相关订单数据&lt;/text&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ data() { return { emcart: false } }, methods:{ init(od=true){ this.emcart = od } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 在 tobepaid.vue组件中引入， &lt;!-- 没有订单数据 --&gt; &lt;ordering ref=\"orderload\"&gt;&lt;/ordering&gt; 接着开始新建目录 放订单详情，因为详情是对于四个板块都类似布局所以抽出到单独文件夹 pages下新建 order-details文件夹，其下新建order.vue文件，记得去pages.json中注册 静态布局 &lt;template&gt; &lt;!-- 订单详情 --&gt; &lt;view&gt; &lt;view class=\"order-details-view\"&gt; &lt;view&gt;等待买家付款&lt;/view&gt; &lt;image src=\"http://h.thexxdd.cn/video/tianmao/001.webp\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 地址 --&gt; &lt;view class=\"order-details-address\"&gt; &lt;view&gt; &lt;image src=\"/static/loading/address-shouhuo.svg\" mode=\"aspectFit\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"order-details-name\"&gt; &lt;text&gt;马云 10086&lt;/text&gt; &lt;text&gt;四川省成都市 阿里巴巴&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 商品详情 --&gt; &lt;view class=\"payment-commodity pay-border\"&gt; &lt;text class=\"order-tips tips-import\"&gt;&lt;/text&gt; &lt;view class=\"payment-order\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image src=\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;商品标题&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:黑色;尺码:&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥ 100&lt;/text&gt; &lt;text class=\"text-you\"&gt;x1&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;需付款￥100&lt;/view&gt; &lt;/view&gt; &lt;!-- 订单编号 --&gt; &lt;view class=\"order-number\"&gt; &lt;text&gt;订单编号: 123456&lt;/text&gt; &lt;text&gt;创建时间: 2022-07-16&lt;/text&gt; &lt;/view&gt; &lt;!-- 按钮 --&gt; &lt;view class=\"order-details-play\" &gt; &lt;text&gt;右下角按钮&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import '../../style/order.css' import '../../style/order-details.css' export default{ data() { return { values:{}, orderdata:[] } }, } &lt;/script&gt; 然后回到订单中心 personal.vue 设置点击商品跳转到商品详情页，如果订单过期无法点击！ &lt;!-- 不存在订单过期的数据才能点击 --&gt; &lt;view class=\"payment-order\" @click=\"!item.expire &amp;&amp; payDetail()\"&gt; // 跳转到商品详情页 payDetail(){ uni.navigateTo({ url:'../order-details/order' }) } 因为待付款、待发货、待收货三个板块的详情页也有不同之处，所以需要一些数据进行动态传值 // 跳转到商品详情页 payDetail(id){ // 准备一个对象传入 ，不能直接从路径携带过去 let tip = { tips:'等待买家付款', sum:'需付款', show:true, //是否展示付款按钮 text:'付款', id:id } // 将对象数据转化成json字符串 然后传入到跳转的组件里 let value = JSON.stringify(tip) uni.navigateTo({ url:'../order-details/order?value=' + value }) } 商品详情组件中，order.vue 在onload接收数据 // e 接收tobepaid.vue组件 跳转过来时携带的数据 onLoad(e) { // 将数据转化为js对象 let value = JSON.parse(e.value) console.log(value); this.values = value //接收值然后遍历 } tobepaid.vue 组件 完整代码如下： 因为是没有商户号的购买数据，无法拿到相关数据 因此自己创建一个假数组对象当作拿到的tobedetail接口数据 然后将数据进行几次遍历到相应位置上 &lt;template&gt; &lt;!-- 订单详情 --&gt; &lt;view&gt; &lt;view class=\"order-details-view\"&gt; &lt;view&gt;{{values.tips}}&lt;/view&gt; &lt;image src=\"http://h.thexxdd.cn/video/tianmao/001.webp\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 地址 --&gt; &lt;view class=\"order-details-address\"&gt; &lt;view&gt; &lt;image src=\"/static/loading/address-shouhuo.svg\" mode=\"aspectFit\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"order-details-name\"&gt; &lt;block v-for=\"(item,index) in orderdata\" :key=\"index\"&gt; &lt;text&gt;{{item.consignee.name}} {{item.consignee.mobile}}&lt;/text&gt; &lt;text&gt;{{item.consignee.city}} {{item.consignee.address}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 商品详情 --&gt; &lt;block v-for=\"(items,indexs) in orderdata\" :key=\"indexs\"&gt; &lt;view class=\"payment-commodity pay-border\"&gt; &lt;text class=\"order-tips tips-import\"&gt;&lt;/text&gt; &lt;block v-for=\"(itemimg,indexss) in items.order\" :key=\"indexss\"&gt; &lt;!-- 商品详情 --&gt; &lt;view class=\"payment-order\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"itemimg.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{itemimg.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{itemimg.color}};尺码:{{itemimg.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥{{itemimg.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{itemimg.many}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;{{values.sum}}￥{{items.total_price}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 订单编号 --&gt; &lt;view class=\"order-number\"&gt; &lt;block v-for=\"(item,index) in orderdata\" :key=\"index\"&gt; &lt;text&gt;订单编号: {{item.order_number}}&lt;/text&gt; &lt;text&gt;创建时间: {{item.time}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 按钮 --&gt; &lt;view class=\"order-details-play\" v-if=\"values.sum\"&gt; &lt;text&gt;{{values.text}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import '../../style/order.css' import '../../style/order-details.css' export default{ data() { return { // 准备空对象，接收tobepaid.vue组件 跳转过来时携带的数据 values:{}, orderdata:[] } }, methods:{ // 请求商品数据的方法 async tobedetail(id){ try{ let tobedetail = await new this.Request(this.Urls.m().tobedetail + '?id=' + id).modeget(); // 此处因为是没有商户号的购买数据，无法拿到相关数据 // 因此自己创建一个假数组对象当作拿到的tobedetail数据 let tobedetails = [ { consignee:{ address:\"阿里巴巴\", city:\"四川省 成都市 高新区\", mobile:\"15858588888\", name:\"马云\", }, nonceStr:\"yybvvcyP6CDZ08E4\", order:[ { color:'5526网面-天空蓝', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:169, size:\"37\", title:\"耐克新款2022 女生白色皮面鞋子高级【店长推荐】\" }, ], order_number:\"1607585433768778712\", out_trade_no:\"2zmCzfDZe6Zr8rKYCz43AbXEe2Kk2Pcs\", package:\"prepay_id=wx101530337150731019fc4f4e85085f0000\", paySign:\"C0E5435D1E89E2562048740360E37201\", signType:\"MD5\", time:\"2022-07-15 16:46:00\", timeStamp:\"1657874760\", total_price:169, _id:\"5fd1ce998c16885a1972d20b\", } ] tobedetail.data = tobedetails this.orderdata = tobedetail.data }catch(e){ //TODO handle the exception } } }, // e 接收tobepaid.vue组件 跳转过来时携带的数据 onLoad(e) { // 将数据转化为js对象 let value = JSON.parse(e.value) console.log(value); this.values = value // 调用请求方法 this.tobedetail(value.id) } } &lt;/script&gt; 待付款再次付款（上）在public文件夹中新建 payment.js 封装一个类，用于待付款的付款请求 // 用于待付款的付款请求 import request from '../api/api.js' import urls from '../api/request.js' // 待付款 class Payment { constructor(payment) { this.payment = payment } // 1、拉起付款， paySuccess(){ try{ await this.wxPay() }catch(e){ throw e } // 2、查询订单 try{ let queryorder = await new request(urls.m().queryorderurl，{}).modepost(); return queryorder }catch(e){ throw '支付失败' } } // 调用微信支付 wxPay(){ return new Promise((resolve,reject)={ wx.requestPayment({ timeStamp: '', nonceStr: '', package: '', signType: 'MD5', paySign: '', success: res=&gt; { resolve(res) }, fail: Error=&gt; { reject(Error) } }) }) } } module.exports = {Payment} 在待付款组件中添加点击事件， &lt;text v-else @click=\"payMent()\"&gt;付款&lt;/text&gt; 待付款再次付款（下）给方法传值（对象） &lt;text v-else @click=\"payMent({_id:item.id,})\"&gt;付款&lt;/text&gt; // 在付款 payMent(obj){ console.log(obj); } 引入付款类 // 引入付款类 const {Payment} = require('../../../public/payment.js') // 在付款 payMent(obj){ new Payment(obj).paySucc() .then(res=&gt;{ console.log(res); }) .catch(err=&gt;{ console.log(err); }) } 然后去方法类中拿到obj对象参数后，代码如下 // 用于待付款的付款请求 import request from '../api/api.js' import urls from '../api/request.js' // 待付款 class Payment { constructor(payment) { this.payment = payment } // 1、拉起付款， async paySuccess(){ try{ await this.wxPay() }catch(e){ throw e } // 2、查询订单 try{ let queryorder = await new request(urls.m().queryorderurl,{id:this.payment._id,outno:this.payment.out_trade_no}).modepost(); return queryorder }catch(e){ throw '支付失败' } } // 调用微信支付 wxPay(){ return new Promise((resolve,reject)=&gt;{ wx.requestPayment({ timeStamp: 'this.payment.timeStamp', nonceStr: 'this.payment.nonceStr', package: 'this.payment.package', signType: 'this.payment.signType', paySign: 'this.payment.paySign', success: res=&gt; { resolve(res) }, fail: Error=&gt; { reject(Error) } }) }) } } module.exports = {Payment} 此时点击tobepaid组件的付款将会弹出二维码，但是由于我这是假数据，仅仅返回一个无权限的数据。 下一步做在订单详情页的付款按钮的功能 在order.vue组件中，添加点击事件 &lt;!-- 按钮 --&gt; &lt;view class=\"order-details-play\" v-if=\"values.sum\" &gt; &lt;text @click=\"conFirm()\"&gt;{{values.text}}&lt;/text&gt; &lt;/view&gt; // 右下角按钮（付款、确认收货、评价） conFirm(text){ if(text == '付款') { new this.$Toast('正在下单中','none').showloading() //手动 弹窗 new Payment(this.orderdata[0]).paySuccess() .then(res=&gt;{ console.log(res); new this.$Toast('支付成功','none').showtoast() //反馈 弹窗 // 支付成功跳转 uni.redirectTo({ url:'../personal/personal' }) }) .catch(err=&gt;{ console.log(err); setTimeout(()=&gt;{ new this.$Toast('支付失败（无商品号权限）','none').showtoast() //反馈 弹窗 },1000) }) }else if(text == '确认收货'){ }else if(text == '评价') { } } 订单详情页删除订单在待付款组件tobepaid.vue中，有的商品过期，需要删除 准备删除接口 // 删除订单 let deleorder = `${url}deleorder` 给删除按钮添加点击事件 deteOrder（_id） &lt;!-- 付款 --&gt; &lt;view class=\"presonal-payment\"&gt; &lt;!-- 如果过期，就显示删除订单 否则可以付款--&gt; &lt;text v-if=\"item.expire\" @click=\"deteOrder(item._id)\"&gt;删除订单&lt;/text&gt; &lt;text v-else @click=\"payMent({ _id:item._id, timeStamp:item.timeStamp, nonceStr:item.nonceStr, package:item.package, signType:item.signType, paySign:item.paySign, out_trade_no:item.out_trade_no, })\"&gt;付款&lt;/text&gt; &lt;/view&gt; // 删除订单 async deteOrder(id){ try{ let deleorder = await new this.Request(this.Urls.m().deleorder + '?orderid' + id).modeget(); console.log(deleorder,'删除订单'); if(deleorder.msg == 'SUCCESS') { this.Tobepaid() //刷新页面 new this.$Toast('删除成功','none').showtoast() //反馈 弹窗 }else if(deleorder.msg == \"参数填写错误\") { new this.$Toast('删除失败（无商品号权限）','none').showtoast() //反馈 弹窗 } }catch(e){ //TODO handle the exception } } 待发货和待收货**delivered.vue待发货 **组件中， 代码如下: &lt;template&gt; &lt;!-- 待发货组件 --&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 商品详情 --&gt; &lt;block v-for=\"(item,index) in tbdelivered\" :key=\"index\"&gt; &lt;view class=\"payment-commodity\" &gt; &lt;text class=\"order-tips\"&gt;买家已付款&lt;/text&gt; &lt;block v-for=\"(items,indexs) in item.order\" :key=\"indexs\"&gt; &lt;view class=\"payment-order\" @click=\"payDetail(item._id)\"&gt; &lt;!-- 图片 --&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"items.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{items.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{items.color}};尺码:{{items.size}}&lt;/text&gt; &lt;/view&gt; &lt;!-- 单价、数量 --&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥ {{items.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{items.many}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;实付款￥{{item.total_price}}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 没有相关订单 --&gt; &lt;ordering ref=\"orderload\"&gt;&lt;/ordering&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import '../../../style/order.css' export default{ data() { return { tbdelivered:[], } }, methods:{ async Tobepaid(){ try{ let tbdelivered = await new this.Request(this.Urls.m().tbdelivered).modeget(); console.log(tbdelivered,'获取待发货数据'); // 如果未登录 调用登录弹窗 if(tbdelivered.msg.errcode) { this.$refs.loginmen.showing() // 如果登录成功后 }else if(tbdelivered.msg == 'SUCCESS') { // 没有待付款数据 if(tbdelivered.data.length == 0) { // 就提示没有数据 this.$refs.orderload.init() }else { this.tbdelivered = tbdelivered.data } } }catch(e){ } }, // 跳转到商品详情页 payDetail(id){ // 准备一个对象传入 ，不能直接从路径携带过去 let tip = { tips:'买家已经付款', sum:'实付款', show:false, //是否展示付款按钮 text:'付款', id:id } // 将对象数据转化成json字符串 然后传入到跳转的组件里 let value = JSON.stringify(tip) uni.navigateTo({ url:'../order-details/order?value=' + value }) }, }, created() { this.Tobepaid() }, // 登录成功后也要刷新数据 接收登录组件传递的值 mounted() { this.$bus.$on('mycart',res=&gt;{ // 当登录成功后 if(res.cart == 'SUCCESS'){ // 调用方法刷新数据 this.Tobepaid() } }) } } &lt;/script&gt; **received.vue **待收货组件中， 代码如下: ps: 由于待收货接口拿不到数据，这里使用的是待发货的接口 &lt;template&gt; &lt;!-- 待收货组件 --&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 商品详情 --&gt; &lt;block v-for=\"(item,index) in gtbreceived\" :key='index'&gt; &lt;view class=\"payment-commodity\"&gt; &lt;text class=\"order-tips\"&gt;卖家已发货&lt;/text&gt; &lt;block v-for=\"(iteming, indexs) in item.order\" :key='indexs'&gt; &lt;view class=\"payment-order\" @click=\"payDeatil(item._id)\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"iteming.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{iteming.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{iteming.color}};尺码:{{iteming.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥ {{iteming.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{iteming.many}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 价格 --&gt; &lt;view class=\"presonal-Price\"&gt;实付款￥{{item.total_price}}&lt;/view&gt; &lt;!-- 付款 --&gt; &lt;view class=\"presonal-payment\"&gt; &lt;text @click=\"conRece(item._id)\"&gt;确认收货&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 没有相关订单 --&gt; &lt;ordering ref=\"orderload\"&gt;&lt;/ordering&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import '../../../style/order.css' export default{ data() { return { gtbreceived:[], } }, methods:{ // 获取待收货数据 async Tobepaid(){ try{ // 由于待收货接口拿不到数据，这里使用的是待发货的接口 let data = await new this.Request(this.Urls.m().tbdelivered).modeget() console.log(data,'获取待收货数据'); if(data.msg.errcode){ this.$refs.loginmen.showing() }else if(data.msg == 'SUCCESS'){ if(data.data.length == 0){ this.gtbreceived = [] // 当数据为0 时候，要清空页面数据 this.$refs.orderload.init() }else{ this.gtbreceived = data.data } } }catch(e){ //TODO handle the exception } }, // 订单详情页 payDeatil(id){ let tip = {tips:'卖家已发货',sum:'实付款',show:true,text:'确认收货',id} let value = JSON.stringify(tip) uni.navigateTo({ url:'../order-details/order?value=' + value }) }, // 确认收货 async conRece(id){ try{ let conreceipt = await new this.Request(this.Urls.m().conreceipt + '?id=' + id).modeget() if(conreceipt.msg == 'SUCCESS'){ // 刷新数据 this.Tobepaid() new this.$Toast('确认收货成功').showtoast() } }catch(e){ //TODO handle the exception } } }, created() { this.Tobepaid() }, // 小程序的生命周期在子组件不会执行 mounted() { this.$bus.$on('mycart',res=&gt;{ if(res.cart == 'SUCCESS'){ this.Tobepaid() } }) } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 然后点击待收货进入商品详情组件order.vue，对右下角的确认收货作点击事件 是 // 右下角按钮（付款、确认收货、评价） conFirm(text){ if(text == '付款') { new this.$Toast('正在下单中','none').showloading() //手动 弹窗 new Payment(this.orderdata[0]).paySuccess() .then(res=&gt;{ console.log(res); new this.$Toast('支付成功','none').showtoast() //反馈 弹窗 // 支付成功跳转 uni.redirectTo({ url:'../personal/personal' }) }) .catch(err=&gt;{ console.log(err); setTimeout(()=&gt;{ new this.$Toast('支付失败（无商品号权限）','none').showtoast() //反馈 弹窗 },1000) }) }else if(text == '确认收货'){ this.conRece() // 支付成功跳转 uni.redirectTo({ url:'../personal/personal' }) } }, // 确认收货 async conRece(){ try{ let conreceipt = await new this.Request(this.Urls.m().conreceipt + '?id=' + this.values.id).modeget() if(conreceipt.msg == 'SUCCESS'){ // 刷新数据 new this.$Toast('确认收货成功').showtoast() } }catch(e){ //TODO handle the exception } } 待评价使用假数据 &lt;template&gt; &lt;view class=\"payment-view\"&gt; &lt;!-- 商品详情 --&gt; &lt;block v-for=\"(item,index) in tbevaluated\" :key='index'&gt; &lt;view class=\"payment-commodity\"&gt; &lt;text class=\"order-tips\"&gt;交易完成&lt;/text&gt; &lt;view class=\"payment-order\" @click=\"payDeatil(item._id)\"&gt; &lt;view class=\"payment-order-img\"&gt; &lt;image :src=\"item.image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"payment-title\"&gt; &lt;text&gt;{{item.title}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;颜色:{{item.color}};尺码:{{item.size}}&lt;/text&gt; &lt;/view&gt; &lt;view class=\"payment-flex\"&gt; &lt;view class=\"payment-price\"&gt; &lt;text&gt;￥ {{item.price}}&lt;/text&gt; &lt;text class=\"text-you\"&gt;x{{item.many}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格--&gt; &lt;view class=\"presonal-Price\"&gt;实付款￥{{parseFloat((item.price * item.many).toFixed(10))}}&lt;/view&gt; &lt;!-- 去评价 --&gt; &lt;view class=\"presonal-payment\"&gt; &lt;text @click=\"conRece(item._id,item.id,item.size,item.color)\"&gt;去评价&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 没有相关订单 --&gt; &lt;ordering ref=\"orderload\"&gt;&lt;/ordering&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import '../../../style/order.css' export default { data(){ return { // 假数据 tbevaluated:[ { _id:\"5fd1ce998c16885a1972d20b\", //订单号 id:\"5f8bbf2823954733542169a1\", color:'5526网面-天空蓝', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:169, size:\"37\", title:\"耐克新款2022 女生白色皮面鞋子高级【店长推荐】\" }, { _id:\"5fd1ce998c16885a1972d20b\", //订单号 id:\"5f8bbf2823954733542169a1\", color:'5526网面-渣渣灰', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:200, size:\"41\", title:\"361新款2022 男生灰色皮面鞋子【店长推荐】\" }, ] } }, methods:{ // 获取待评价数据 async Tobepaid(){ try{ let data = await new this.Request(this.Urls.m().tbevaluated).modeget() console.log(data,'获取待评价数据'); // 由于没有商户号，待评价接口拿不到数据，这里使用的是假数据当作接口返回的数据 if(data.msg.errcode){ // 如果没有登录 弹出登录框 this.$refs.loginmen.showing() }else if(data.msg == 'SUCCESS'){ if(data.data.length == 0){ // this.tbevaluated = [] // 当数据为0 时候，要清空页面数据 // this.$refs.orderload.init() //展示没有数据的提示 console.log('没有商品号，使用假数据当作接口返回的数据'); } } }catch(e){ //TODO handle the exception } }, // 点击商品跳转到订单详情页 payDeatil(id){ let tip = {tips:'交易完成',sum:'实付款',show:true,text:'去评价',id,evt:'002'} let value = JSON.stringify(tip) uni.navigateTo({ url:'../order-details/order?value=' + value }) }, }, created() { this.Tobepaid() }, // 小程序的生命周期在子组件不会执行 mounted() { this.$bus.$on('mycart',res=&gt;{ if(res.cart == 'SUCCESS'){ this.Tobepaid() } }) } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 然后对点击商品跳转到详情组件的功能实现，通过在跳转的方法payDeatil(id)中，传递的参数多加一个evt，当evt为002，就代表是待评价的组件去往详情页， 然后详情组件中判断evt值进行相应操作 // 请求商品数据的方法 async tobedetail(id,evt='001'){ // 当第二个参数是 evt为001 的时候代表的是 待付款、待发货、待收货的订单详情 // 当第二个参数是 evt为002 的时候代表的是 待评价的订单详情 if(evt == '001') { try{ let tobedetail = await new this.Request(this.Urls.m().tobedetail + '?id=' + id).modeget(); // 此处因为是没有商户号的购买数据，无法拿到相关数据 // 因此自己创建一个假数组对象当作拿到的tobedetail数据 console.log(tobedetail,'我是待付款、待发货、待收货的商品数据'); let tobedetails = [ { consignee:{ address:\"阿里巴巴\", city:\"四川省 成都市 高新区\", mobile:\"15858588888\", name:\"马云\", }, nonceStr:\"yybvvcyP6CDZ08E4\", order: [ { color:'5526网面-天空蓝', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:169, size:\"37\", title:\"耐克新款2022 女生白色皮面鞋子高级【店长推荐】\" }, ], order_number:\"1607585433768778712\", out_trade_no:\"2zmCzfDZe6Zr8rKYCz43AbXEe2Kk2Pcs\", package:\"prepay_id=wx101530337150731019fc4f4e85085f0000\", paySign:\"C0E5435D1E89E2562048740360E37201\", signType:\"MD5\", time:\"2022-07-15 16:46:00\", timeStamp:\"1657874760\", total_price:169, _id:\"5fd1ce998c16885a1972d20b\", } ] tobedetail.data = tobedetails this.orderdata = tobedetail.data }catch(e){ //TODO handle the exception } }else { // 待评价组件的商品详情接口数据 try{ let dtpepage = await new this.Request(this.Urls.m().dtpepage + '?id=' + id).modeget(); // 此处因为是没有商户号的购买数据，拿到是空数据 // 因此自己创建一个假数组对象当作拿到的tobedetail数据 console.log(dtpepage,'我是待评价组件的商品数据'); let tobedetails = [ { consignee:{ address:\"阿里巴巴\", city:\"四川省 成都市 高新区\", mobile:\"15858588888\", name:\"马云\", }, nonceStr:\"yybvvcyP6CDZ08E4\", order: [ { color:'5526网面-天空蓝', image:\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\", many:1, price:169, size:\"37\", title:\"耐克新款2022 女生白色皮面鞋子高级【店长推荐】\" }, ], order_number:\"1607585433768778712\", out_trade_no:\"2zmCzfDZe6Zr8rKYCz43AbXEe2Kk2Pcs\", package:\"prepay_id=wx101530337150731019fc4f4e85085f0000\", paySign:\"C0E5435D1E89E2562048740360E37201\", signType:\"MD5\", time:\"2022-07-15 16:46:00\", timeStamp:\"1657874760\", total_price:169, _id:\"5fd1ce998c16885a1972d20b\", } ] dtpepage.data = tobedetails this.orderdata = dtpepage.data }catch(e){ //TODO handle the exception } } }, 商品评价（上）在evaluated.vue组件中，点击评价后跳转到新的组件中， 在pages/order-details/新建pu-coments.vue文件，同时去page.json注册 静态布局： &lt;template&gt; &lt;view&gt; &lt;!-- 描述 --&gt; &lt;view class=\"pu-coments-input\"&gt; &lt;textarea placeholder=\"宝贝满足你的期待吗？说说它的优点和美中不足的地方吧\" v-model=\"tipsdata\" maxlength=\"200\"/&gt; &lt;/view&gt; &lt;!-- 上传图片 --&gt; &lt;view class=\"Upload-pictures\"&gt; &lt;view class=\"Upload-button\" &gt; &lt;image src=\"/static/loading/uptu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"conteng\"&gt; &lt;view class=\"conteng-img\"&gt; &lt;image src=\"http://h.thexxdd.cn/tianmao/public%5Cuploads%5C1606059327494-4142549.jpg\" mode=\"aspectFill\" class=\"uploadimg\" &gt;&lt;/image&gt; &lt;image src=\"/static/loading/guanbi.svg\" mode=\"widthFix\" class=\"deleteimg\" @click=\"deteImg(index)\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 提交 --&gt; &lt;view class=\"Su-comments\" @click=\"subMit()\"&gt;提交评论&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { } }, methods:{ }, } &lt;/script&gt; &lt;style&gt; page{background: #eeeeee;} .pu-coments-input{background-color: #FFFFFF; height: 350rpx;} .pu-coments-input textarea{width: 100%; color: rgb(0, 0, 0) !important; padding: 10rpx; font-size: 30rpx; height: 350rpx; overflow-y: auto; } .Upload-button{width: 130rpx; height: 130rpx; padding-left: 10rpx; padding-bottom: 5rpx;} .Upload-button image{width: 130rpx; height: 130rpx;} .Upload-pictures{margin: 15rpx;} /* 上传图片 */ .conteng{display: flex;flex-wrap: wrap;} .conteng-img{width: calc(25% - 10rpx*2); height: 150rpx; padding: 10rpx; position: relative; } .conteng-img image{width: 100%; height: 150rpx; border-radius: 6rpx; } .deleteimg{width: 33upx !important; height: 33upx !important; position: absolute; top: 0upx; right: 0upx;} /* 提交评论 */ .Su-comments{background-color: rgb(255, 83, 2); color: #FFFFFF; height: 100rpx; line-height: 100rpx; position: fixed; bottom: 0; right: 0; left: 0; text-align: center; } &lt;/style&gt; 商品评价（下）&lt;template&gt; &lt;view&gt; &lt;!-- 描述 --&gt; &lt;view class=\"pu-coments-input\"&gt; &lt;textarea placeholder=\"宝贝满足你的期待吗？说说它的优点和美中不足的地方吧\" v-model=\"tipsdata\" maxlength=\"200\"/&gt; &lt;/view&gt; &lt;!-- 上传图片 --&gt; &lt;view class=\"Upload-pictures\"&gt; &lt;!-- 使用计算属性 --&gt; &lt;view class=\"Upload-button\" @click=\"uploadImg()\" v-if=\"upbutton\"&gt; &lt;image src=\"/static/loading/uptu.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"conteng\"&gt; &lt;block v-for=\"(item,index) in upimg\" :key=\"index\"&gt; &lt;view class=\"conteng-img\"&gt; &lt;image :src=item mode=\"aspectFill\" class=\"uploadimg\" @click=\"preImage(index,upimg)\"&gt;&lt;/image&gt; &lt;image src=\"/static/loading/guanbi.svg\" mode=\"widthFix\" class=\"deleteimg\" @click=\"deteImg(index)\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 提交 --&gt; &lt;view class=\"Su-comments\" @click=\"subMit()\"&gt;提交评论&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入预览图片js const {Login} = require('../../public/logic.js') export default { data() { return { // 双向绑定的input框文本 tipsdata:'', upimg:[], //准备上传的图片信息 comming:{},//接收上个组件的数据 } }, methods:{ // 上传图片 使用微信的接口 uploadImg(){ wx.chooseMedia({ count: 1, //图片张数 mediaType: ['image','video'], //文件类型 sizeType: ['compressed'], //仅对 mediaType 为 image 时有效，是否压缩所选文件 sourceType: ['album', 'camera'], //图片和视频选择的来源 maxDuration: 30, //拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 60s 之间。不限制相册。 success:(res)=&gt;{ new this.$Toast('等待上传').showloading() //加载提示 console.log(res,'拍摄或从手机相册中选择图片或视频'); this.cloudImg(res.tempFiles[0].tempFilePath) }, fail:(err)=&gt;{ console.log(err) } }) }, // 微信提供 上传图片到服务器方法 cloudImg(image){ wx.uploadFile({ url:'https://meituan.thexxdd.cn/api/potimg', filePath:image, //要上传文件资源的路径 (本地路径) name:'file', //文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容 success:(res)=&gt;{ console.log(res,'上传图片到服务器'); this.upimg.push(JSON.parse(res.data).data) new this.$Toast('上传成功').showtoast() }, fail: (err) =&gt; { console.log(err) } }) }, // 预览图片 preImage(index,upimg){ new Login(index,upimg).previewImg() }, // 删除图片 deteImg(index){ this.upimg.splice(index,1) }, // 提交评论 async subMit(){ new this.$Toast('正在提交','none').showloading() // 拿到评论接口需要的参数 let {_id,id,size,color} = this.comming let obj = {orderid:_id,commid:id,size,color,comment:this.tipsdata,commimage:this.upimg} try{ let data = await new this.Request(this.Urls.m().subcomm,obj).modepost() console.log(data,'提交评论'); if(data.msg == 'SUCCESS'){ new this.$Toast('评论成功','SUCCESS').showtoast() setTimeout(()=&gt;{ uni.redirectTo({ url: '../personal/personal' }); },1000) }else{ new this.$Toast(data.msg,'none').showtoast() } }catch(e){ //TODO handle the exception } } }, //使用计算属性完成 当图片数量达到2时，隐藏上传入口 computed:{ upbutton(){ if(this.upimg.length &gt;= 2){ return false }else{ return true } } }, // 接收上个组件传递的数据 onLoad(e){ this.comming = JSON.parse(e.data) } } &lt;/script&gt; 待评价页面进入商品详情页 order.vue 中的 去评价 功能 }else if(text == '去评价') { let {_id,id,size,color} = this.orderdata[0].order[0] let data = JSON.stringify({_id,id,size,color}) uni.navigateTo({ url:'../order-details/pu-coments?data=' + data }) } 然后打开my文件夹下 my.vue 设置跳转到各个组件详情页方法 // 跳转到各板块组件 --详情页 myIng(index){ uni.navigateTo({ url:'../personal/personal?index=' + index }) } 商品分类商品一级分类sort.vue组件 静态布局 &lt;template&gt; &lt;view class=\"sort-view\"&gt; &lt;!-- 左边 --&gt; &lt;view class=\"sort-left\"&gt; &lt;view class=\"sort-name\" &gt;潮流男装&lt;/view&gt; &lt;/view&gt; &lt;!-- 右边 --&gt; &lt;view class=\"sort-right\"&gt; &lt;view class=\"sort-name sort-title\"&gt;潮流男装&lt;/view&gt; &lt;view class=\"sort-flex\"&gt; &lt;view class=\"sort-goods\" &gt; &lt;image :src=\"iteming.name_image\" mode=\"aspectFill\"&gt;图片&lt;/image&gt; &lt;text&gt;外套&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style scoped&gt; .sort-view { display: flex; } .sort-left { width: 150upx; background: #f8f8f8; height: 100vh; overflow-y: auto; position: fixed; left: 0; bottom: 0; top: 0; } .sort-right { flex: 1; margin-left: 150upx; } .sort-name { height: 80upx; line-height: 80upx; font-size: 28upx; text-align: center; } .activesort { background: #ffffff; } /* right */ .sort-title { text-align: left !important; padding-left: 40upx; font-weight: bold; } .sort-flex { display: flex; flex-wrap: wrap; align-items: center; } .sort-flex image { width: 80upx; height: 100upx; display: block; } .sort-goods text { padding-top: 10upx; } .sort-goods { font-size: 28upx; width: 33.333%; display: flex; flex-direction: column; align-items: center; padding-bottom: 40upx; } &lt;/style&gt; 完整逻辑 &lt;template&gt; &lt;view class=\"sort-view\"&gt; &lt;!-- 左边 --&gt; &lt;view class=\"sort-left\"&gt; &lt;block v-for=\"(item, index) in comclass\" :key=\"index\"&gt; &lt;!-- 动态的背景色：条件是下标值和num相等--&gt; &lt;view class=\"sort-name\" :class=\"{ activesort: index == num }\" @click=\"sortSwitch(index,item.cid)\"&gt;{{ item.sort }}&lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 右边 --&gt; &lt;view class=\"sort-right\"&gt; &lt;block v-for=\"(item, index) in secondclass\" :key=\"index\"&gt; &lt;view class=\"sort-name sort-title\"&gt;{{ item.sort }}&lt;/view&gt; &lt;view class=\"sort-flex\"&gt; &lt;block v-for=\"(iteming, indexs) in item.secon_classif\" :key=\"indexs\"&gt; &lt;view class=\"sort-goods\"&gt; &lt;image :src=\"iteming.name_image\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;text&gt;{{ iteming.name }}&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { comclass: [], //左侧一级数据 secondclass: [], //右侧二级数据 num: 0 }; }, methods: { // comclass // 请求商品一级分类接口 async sortRequest() { try { let comclass = await new this.Request(this.Urls.m().comclass).modeget(); console.log(comclass, '商品一级接口'); this.comclass = comclass.data; // 进入页面默认请求选中的分类下的商品 this.seCond(comclass.data[0].cid); } catch (e) { //TODO handle the exception } }, // 选中左侧菜单项 sortSwitch(index,cid) { this.num = index; this.seCond(cid) //每次点击左侧都会有不同的cid参数传入 二级请求方法 }, // 请求商品二级分类接口 async seCond(cid) { try { let secondclass = await new this.Request(this.Urls.m().secondclass + '?cid=' + cid).modeget(); console.log(secondclass, '商品二级接口'); this.secondclass = secondclass.data; } catch (e) {} } }, created() { this.sortRequest(); } }; &lt;/script&gt; 商品二级分类在pages下新建 class-goods文件夹，在其下新建goods.vue文件 静态布局如下： &lt;template&gt; &lt;view&gt; &lt;!-- 排序 --&gt; &lt;view class=\"condition-view\"&gt; &lt;view&gt; &lt;text&gt;全部&lt;/text&gt; &lt;image src=\"\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt; &lt;text&gt;销量&lt;/text&gt; &lt;image src=\"\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt; &lt;text&gt;价格&lt;/text&gt; &lt;image src=\"/static/details/jiantou.svg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view style=\"height: 70rpx;\"&gt;&lt;/view&gt; &lt;!-- 商品 --&gt; &lt;Commodity :commdata=\"commdata\"&gt;&lt;/Commodity&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return {}; }, methods: {} }; &lt;/script&gt; &lt;style&gt; page { background: #f4f4f4; } .condition-view { background: #ffffff; height: 70upx; font-size: 28upx; display: flex; align-items: center; justify-content: space-around; position: fixed; top: 0; left: 0; right: 0; } .condition-view image { width: 25upx; height: 25upx; } .condition-view text { padding-right: 8upx; } .condition-view view { display: flex; align-items: center; color: #999; } .active { color: #dd2727 !important; } .admining { transform: rotate(180deg); } &lt;/style&gt; 在sort.vue组件中，点击商品携带俩个参数到商品分类goods.vue组件中 // 点击商品跳转到分类详情页 sortIng(cid,name){ let data = JSON.stringify({cid,name}) uni.navigateTo({ url:'../class-goods/goods?data=' + data }) } goods.vue组件中，onLoad（e）接收俩参数 &lt;template&gt; &lt;!-- 二级分类详情组件 --&gt; &lt;view&gt; &lt;!-- 排序 --&gt; &lt;view class=\"condition-view\"&gt; &lt;block v-for=\"(item,index) in sorting\" :key=\"index\"&gt; &lt;view :class=\"{active : index == num}\" @click=\"sortImg(index)\"&gt; &lt;text &gt;{{item.text}}&lt;/text&gt; &lt;image :src='item.image'&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;view style=\"height: 70rpx;\"&gt;&lt;/view&gt; &lt;!-- 商品 --&gt; &lt;Card :commdata=\"commdata\"&gt;&lt;/Card&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' export default { components:{ Card, }, data() { return { num:0, querydata:{}, //查询值 sorting:[ { text:'全部', image:'', }, { text:'销量', image:'', }, { text:'价格', image:'/static/details/jiantou.svg', } ], commdata:[], //二级分类下的商品数据 }; }, methods: { sortImg(index){ this.num = index }, // 进入页面后执行的 查询二级分类下的商品 async goodsRequest(){ let {cid,name} = this.querydata let id = '?cid=' + cid + '&amp;name=' + name console.log(id); try{ let queryclass = await new this.Request(this.Urls.m().queryclass + id).modeget() console.log(queryclass,'二级分类下的商品') // 将接口拿到的数据 传递给卡片流组件 this.commdata = queryclass.data }catch(e){ console.log(e) } } }, onLoad(e) { // 接收sort组件传递进来的数据并保存到data中 this.querydata = JSON.parse(e.data) console.log(this.querydata); this.goodsRequest() } }; &lt;/script&gt; 默认展示的是全部的商品，接下来完成排序查询 按销量、按价格查询商品思路： 通过切换按钮时，下标不同，就触发不同的请求方法 下标为0 全部 按钮执行 goodsRequest( )方法 下标为1 销量 按钮执行 goodsRequest( )方法 下标为2 价格 按钮执行 goodsRequest( )方法 sortImg(index){ this.num = index // 当下标为0 即处于全部按钮 调用全部商品接口 if(index == 0) { this.goodsRequest() // 当下标为1 即处于 销量 按钮 }else if (index == 1) { // 每次点击销量按钮 值都会改变 1 或者 -1 --即升序或者降序排列 this.savo = this.savo == 1 ? -1 : 1 this.qsFun('001',this.savo) // 当下标为2 即处于 价格 按钮 }else if (index == 2) { this.rotate = this.rotate == true ? false : true this.pri = this.pri == 1 ? -1 : 1 this.qsFun('002',this.pri) } }, good.vue完整代码 &lt;template&gt; &lt;!-- 二级分类详情组件 --&gt; &lt;view&gt; &lt;!-- 排序 --&gt; &lt;view class=\"condition-view\"&gt; &lt;block v-for=\"(item,index) in sorting\" :key=\"index\"&gt; &lt;view :class=\"{active : index == num}\" @click=\"sortImg(index)\"&gt; &lt;text &gt;{{item.text}}&lt;/text&gt; &lt;image :src='item.image' :class=\"{admining : rotate}\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;view style=\"height: 70rpx;\"&gt;&lt;/view&gt; &lt;!-- 商品 --&gt; &lt;Card :commdata=\"commdata\"&gt;&lt;/Card&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; // 引入公用的组件 --懒加载卡片 import Card from '../commponents/card.vue' // node.js 的 qs模块 const qs = require('querystring') export default { components:{ Card, }, data() { return { num:0, querydata:{}, //查询值 sorting:[ { text:'全部', image:'', }, { text:'销量', image:'', }, { text:'价格', image:'/static/details/jiantou.svg', } ], commdata:[], //二级分类下的商品数据 savo:1, // 按销量默认为1 代表升序 pri:1, // 按价格 rotate:false, //箭头默认朝下 }; }, methods: { sortImg(index){ this.num = index // 当下标为0 即处于全部按钮 调用全部商品接口 if(index == 0) { this.goodsRequest() // 当下标为1 即处于 销量 按钮 }else if (index == 1) { // 每次点击销量按钮 值都会改变 1 或者 -1 --即升序或者降序排列 this.savo = this.savo == 1 ? -1 : 1 this.qsFun('001',this.savo) // 当下标为2 即处于 价格 按钮 }else if (index == 2) { this.rotate = this.rotate == true ? false : true this.pri = this.pri == 1 ? -1 : 1 this.qsFun('002',this.pri) } }, // 进入页面后执行的 查询二级分类下的商品 async goodsRequest(){ let {cid,name} = this.querydata let id = '?cid=' + cid + '&amp;name=' + name console.log(id); try{ let queryclass = await new this.Request(this.Urls.m().queryclass + id).modeget() this.commdata = queryclass.data console.log(this.commdata,'二级分类下的商品数据') }catch(e){ console.log(e) } }, // 查询商品（按销量、价格） qsFun(spvalue,number){ let id = '?cid=' + this.querydata.cid + '&amp;name=' + this // qs.stringify 把一个参数对象格式化为字符串 获得参数 param const param = qs.stringify({ cid:this.querydata.cid, name:this.querydata.name, spvalue,spvalue, number,number, }) console.log(param,'查询商品（按销量、按价格）'); this.queryCod(param) }, // 调用查询商品接口 async queryCod(param){ try{ let querycod = await new this.Request(this.Urls.m().querycod + '?' + param).modeget() console.log(querycod,'查询商品（按销量、按价格）'); this.commdata = querycod.data }catch(e){ //TODO handle the exception } } }, onLoad(e) { // 接收到分类组件传递来的第一级分类数据 this.querydata = JSON.parse(e.data) console.log(this.querydata,'接收到分类组件传递来的第一级分类数据'); this.goodsRequest() } }; &lt;/script&gt; 购物车pages/shopping/shopping.vue组件中 静态布局代码如下： &lt;template&gt; &lt;view&gt; &lt;view class=\"shopp-view\"&gt; &lt;view class=\"manage-tli\"&gt;完成&lt;/view&gt; &lt;view style=\"margin-bottom: 150rpx;\"&gt; &lt;view class=\"shopp-goods\"&gt; &lt;!-- 商品 --&gt; &lt;view class=\"shopp-goods-view\"&gt; &lt;view class=\"shopp-chick\"&gt; &lt;!-- &lt;image src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; --&gt; &lt;image src=\"/static/details/weixuan.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"shopp-chick-img\"&gt; &lt;image src=\"\" mode=\"scaleToFill\"&gt;图片1&lt;/image&gt; &lt;/view&gt; &lt;view class=\"shopp-chick-gight\"&gt; &lt;view class=\"shopp-chick-right\"&gt; &lt;view&gt;标题&lt;/view&gt; &lt;view class=\"shopp-chick-sku\"&gt; &lt;text&gt;尺码;&lt;/text&gt; &lt;text&gt;颜色&lt;/text&gt; &lt;image src=\"/static/details/jiantou.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格 --&gt; &lt;view class=\"shopp-price\"&gt; &lt;view&gt;¥100&lt;/view&gt; &lt;view class=\"shopp-price-nums\"&gt; &lt;view&gt;-&lt;/view&gt; &lt;view&gt;0&lt;/view&gt; &lt;view&gt;+&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 底部结算 --&gt; &lt;view class=\"settlement-view\"&gt; &lt;view class=\"settlement-img\"&gt; &lt;image src=\"/static/details/weixuan.svg\" mode=\"widthFix\" &gt;&lt;/image&gt; &lt;!-- &lt;image v-if=\"selectall\" src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\" @click=\"selectAll('deall')\"&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &lt;view class=\"settlement-tips\"&gt; &lt;view class=\"total-view\"&gt; &lt;text&gt;总价合计:&lt;/text&gt; &lt;text&gt;¥ 100&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"settlement-money\"&gt;结算&lt;/view&gt; &lt;!-- &lt;view class=\"settlement-money\"&gt;删除&lt;/view&gt; --&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- sku组件--&gt; &lt;Addtocart ref=\"addto\" :skudata=\"skudata\"&gt;&lt;/Addtocart&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 购物车没有数据的提示--&gt; &lt;view class=\"empty-cart\" v-if=\"!emcart\"&gt; &lt;image src=\"/static/loading/kongcart.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;购物车竟然是空的&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { emcart: true }; } }; &lt;/script&gt; &lt;style&gt; page { background: #f2f2f2; } .shopp-view { margin: 0 10upx; } .manage-tli { font-size: 28upx; color: #6b6b6b; height: 80upx; line-height: 80upx; text-align: right; } /* 商品 */ .shopp-goods { font-size: 28upx; /* height: 340upx; */ background: #ffffff; border-radius: 10upx; padding: 20upx 10upx; margin-bottom: 15rpx; } .shopp-goods-Coupon { height: 70upx; /* background: #4CD964; */ display: flex; align-items: center; justify-content: flex-end; } .shopp-chick { width: 45upx; height: 200upx; display: flex; flex-direction: column; justify-content: center; } .shopp-chick image { width: 45upx; height: 45upx; } .shopp-chick-img { width: 200upx; height: 200upx; padding: 0 15upx; } .shopp-chick-img image { width: 100%; height: 100%; border-radius: 8upx; } .shopp-chick-gight view:nth-child(1) { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } .shopp-chick-right image { width: 20upx; height: 20upx; padding-left: 8upx; } .shopp-chick-sku { font-size: 25upx; color: #999999; height: 50upx; background: #f9f9f9; display: inline-flex; align-items: center; margin: 17upx 0; padding: 0 20rpx; border-radius: 5rpx; } .shopp-price { display: flex; align-items: center; justify-content: space-between; height: 50upx; /* background: #9ACD32; */ } .shopp-price view:nth-child(1) { color: #f75807; font-weight: bold; } .shopp-price-nums { display: flex; align-items: center; border: 1px solid #f9f9f9; width: 200upx; border-radius: 10upx; } .shopp-price-nums view { font-weight: bold; width: 90upx; height: 50upx; line-height: 50upx; text-align: center; } .shopp-price-nums view:nth-child(2) { border-left: 1px solid #f9f9f9; border-right: 1px solid #f9f9f9; padding: 0 10upx; } .shopp-goods-view { display: flex; } .shopp-chick-gight { flex: 1; } .Special-rate { color: #ff5000; display: flex; align-items: center; height: 50upx; font-weight: bold; } /* 结算 */ .settlement-view { font-size: 28upx; background: #ffffff; height: 90upx; border-top: 1px solid #f2f2f2; position: fixed; bottom: 0; left: 0; right: 0; display: flex; align-items: center; justify-content: space-between; } .settlement-img { width: 45upx; height: 45upx; } .settlement-img image { width: 45upx; height: 45upx; padding-left: 20upx; } .total-view { display: flex; align-items: center; justify-content: center; } .total-view text:nth-child(1) { font-size: 30upx; } .total-view text:nth-child(2) { font-weight: bold; color: #ff4401; padding-left: 10upx; } .settlement-money { background: #fe0036; height: 90upx; line-height: 90upx; width: 220upx; text-align: center; font-size: 30upx; color: #ffffff; } .settlement-tips { text-align: center; } &lt;/style&gt; 拉取购物车数据&lt;template&gt; &lt;view&gt; &lt;view class=\"shopp-view\" v-if=\"emcart\"&gt; &lt;view class=\"manage-tli\" @click=\"adMinis()\"&gt;{{editdata}}&lt;/view&gt; &lt;view style=\"margin-bottom: 150rpx;\"&gt; &lt;block v-for=\"(item,index) in mycarturl\" :key=\"index\"&gt; &lt;view class=\"shopp-goods\"&gt; &lt;!-- 商品 --&gt; &lt;view class=\"shopp-goods-view\"&gt; &lt;!-- 选中的圆圈样式 --&gt; &lt;view class=\"shopp-chick\"&gt; &lt;!-- 选中图标 --&gt; &lt;image v-if=\"item.choice\" src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;!-- 未选中图标 --&gt; &lt;image v-else src=\"/static/details/weixuan.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"shopp-chick-img\"&gt; &lt;image :src=\"item.image\" mode=\"scaleToFill\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"shopp-chick-gight\"&gt; &lt;view class=\"shopp-chick-right\"&gt; &lt;view&gt;{{item.title}}&lt;/view&gt; &lt;view class=\"shopp-chick-sku\"&gt; &lt;text&gt;{{item.size}}&lt;/text&gt; &lt;text&gt;{{item.color}}&lt;/text&gt; &lt;image src=\"/static/details/jiantou.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 价格 --&gt; &lt;view class=\"shopp-price\"&gt; &lt;view&gt;¥{{item.price}}&lt;/view&gt; &lt;view class=\"shopp-price-nums\"&gt; &lt;view&gt;-&lt;/view&gt; &lt;view&gt;{{item.many}}&lt;/view&gt; &lt;view&gt;+&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 底部结算 --&gt; &lt;view class=\"settlement-view\"&gt; &lt;view class=\"settlement-img\"&gt; &lt;image src=\"/static/details/weixuan.svg\" mode=\"widthFix\" &gt;&lt;/image&gt; &lt;!-- &lt;image v-if=\"selectall\" src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\" @click=\"selectAll('deall')\"&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &lt;view class=\"settlement-tips\" v-show=\"settips\"&gt; &lt;view class=\"total-view\"&gt; &lt;text&gt;总价合计:&lt;/text&gt; &lt;text&gt;¥ 100&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"settlement-money\" v-show=\"settips\"&gt;结算&lt;/view&gt; &lt;view class=\"settlement-money\" v-show=\"!settips\"&gt;删除&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- sku组件--&gt; &lt;Addtocart ref=\"addto\" :skudata=\"skudata\"&gt;&lt;/Addtocart&gt; &lt;!-- 登录界面 --&gt; &lt;loginpage ref=\"loginmen\"&gt;&lt;/loginpage&gt; &lt;!-- 购物车没有数据的提示--&gt; &lt;view class=\"empty-cart\" v-if=\"!emcart\"&gt; &lt;image src=\"/static/loading/kongcart.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;text&gt;购物车竟然是空的&lt;/text&gt; &lt;/view&gt; &lt;!-- 使用 全局引入的登录弹窗 组件--&gt; &lt;showmodal ref=\"show\"&gt;&lt;/showmodal&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { emcart: true, mycarturl:[], //购物车数据 editdata:'管理', settips:true, //默认展示右下角 结算还是删除 }; }, methods:{ // 获取购物车数据 async ShoppingRequest() { let mycarturl = await new this.Request(this.Urls.m().mycarturl).modeget() console.log(mycarturl,'获取到的购物车数据'); if(mycarturl.msg.errcode ) { // 401 表示没有方法权限或者没有登录 使用 全局引入的登录弹窗 组件里的方法 // 登陆这里传值过去 'coll' this.$refs.show.showing('coll') }else if(mycarturl.msg == 'SUCCESS'){ // 购物车没数据的情况 if(mycarturl.data.length != 0) { this.mycarturl = mycarturl.data // 显示提示 this.emcart = true }else { this.emcart = false } } }, // 管理、完成与删除的切换 adMinis(){ this.editdata = this.editdata == '管理'? '完成' : '管理' if(this.editdata == '完成'){ // 要不是趁年轻 this.settips = false }else if(this.editdata == '管理'){ this.settips = true } } onShow(){ this.ShoppingRequest() }, mounted() { // 当登录成功后刷新页面 this.$bus.$on('mycart',res =&gt; { // res就是收到的值 这里是来自于loain-oage.vue中的 cart: \"SUCCESS\" console.log(res,'我是收到的data') if(res.cart == 'SUCCESS') { // 如果登录成功就 获取收货地址 this.ShoppingRequest() } }) } }; &lt;/scrip 计算已选中的合计总价// 获取购物车数据 async ShoppingRequest() { let mycarturl = await new this.Request(this.Urls.m().mycarturl).modeget() console.log(mycarturl,'获取到的购物车数据'); if(mycarturl.msg.errcode ) { // 401 表示没有方法权限或者没有登录 使用 全局引入的登录弹窗 组件里的方法 // 登陆这里传值过去 'coll' this.$refs.show.showing('coll') }else if(mycarturl.msg == 'SUCCESS'){ // 购物车有数据的情况 if(mycarturl.data.length != 0) { this.mycarturl = mycarturl.data //获取数据 this.coselect()// 计算价格 this.emcart = true //不展示提示 // 购物车没有数据的情况 }else { this.emcart = false // 显示提示 } } }, // 计算单个商品总价 coselect(){ // 过滤出数组中 choice为 true的对象 filter会将目标对象放到新数组中 let filselect = this.mycarturl.filter(item =&gt; item.choice) // 取出被选中的 数组中的的总价 this.mapselect = filselect.map(item =&gt; item.total_price) }, 结算和删除按钮的功能 通过计算属性，当勾选长度为0，没有勾选数据就返回一个disable值为false computed:{ //计算总价之和 total(){ // 判断是否有勾选的数据 if(this.mapselect.length == 0) { return {price:0,disable:false} //返回一个总价 值为0 }else { let numdata = 0 this.mapselect.forEach((item)=&gt;{numdata += item}) return {price:parseFloat((numdata).toFixed(10)),disable:true} //解决浮点数 } } }, &lt;view class=\"settlement-money\" v-show=\"settips\" @click=\"total.disable &amp;&amp; semEnt()\"&gt;结算&lt;/view&gt; &lt;view class=\"settlement-money\" v-show=\"!settips\" @click=\"total.disable &amp;&amp; deLece()\"&gt;删除&lt;/view&gt; // 结算 semEnt(){ console.log('结算'); }, // 删除 delece(){ }, 单个商品选中和取消选中&lt;!-- 选中的圆圈样式 --&gt; &lt;view class=\"shopp-chick\"&gt; &lt;!-- 选中图标 --&gt; &lt;image v-if=\"item.choice\" @click=\"seLect(item._id,'unchecked')\" 1 src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\"&gt; &lt;/image&gt; &lt;!-- 未选中图标 --&gt; &lt;image v-else @click=\"seLect(item._id,'select')\" src=\"/static/details/weixuan.svg\" mode=\"widthFix\"&gt; &lt;/image&gt; &lt;/view&gt; // 单个商品选中或取消 async seLect(id,nums){ new this.$Toast('请求中','none').showloading() try{ let selecting = await new this.Request(this.Urls.m().selecting,{id:id,nums:nums}).modepost() console.log(selecting,'单个商品选中或取消'); this.ShoppingRequest() uni.hideLoading() }catch(e){ //TODO handle the exception } } 购物车加减商品数量&lt;!-- 价格 --&gt; &lt;view class=\"shopp-price\"&gt; &lt;view&gt;¥{{item.price}}&lt;/view&gt; &lt;view class=\"shopp-price-nums\"&gt; //当商品数量为1的时候静止点击减按钮 &lt;view @click=\"item.many === 1 ? false : true &amp;&amp; reDuce(item._id,item.many,item.price)\"&gt;-&lt;/view&gt; &lt;view&gt;{{item.many}}&lt;/view&gt; &lt;view @click=\"pLus(item._id,item.many,item.price)\"&gt;+&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; //结算后边的数字 由 many 控制 &lt;view class=\"settlement-money\" v-show=\"settips\" @click=\"total.disable &amp;&amp; semEnt()\"&gt;结算{{(mapselect.length)}}&lt;/view&gt; &lt;view class=\"settlement-money\" v-show=\"!settips\" @click=\"total.disable &amp;&amp; deLece()\"&gt;删除&lt;/view&gt; // 加减商品数量请求 async shoppingNumber(id,many,price){ new this.$Toast('请求中','none').showloading() try{ let pridec = await new this.Request(this.Urls.m().pride,{id:id,many:many,price:price}).modepost() this.ShoppingRequest() uni.hideLoading() }catch(e){ //TODO handle the exception } }, // 减 reDuce(id,many,price){ many -- this.shoppingNumber(id,many,price) }, // 加 pLus(id,many,price){ many ++ this.shoppingNumber(id,many,price) }, 全选和取消全选思路：在计算属性中，添加一个方法： 判断之前过滤出选的中商品的数组长度 如果等于了购物车里数据长度 就表示全选了所有商品 // 控制全选和取消全选 selectall(){ // 判断之前过滤出选中了的商品的数组的长度 如果等于了购物车里数据长度 就表示全选了所有商品 if(this.mapselect.length === this.mycarturl.length) { return true }else { return false } } 将计算属性返回的方法布尔值通过v-if分别绑定给未全选和全选。 同时给按钮（圆圈）添加点击事件，在点击事件中发起请求，并刷新页面 &lt;view class=\"settlement-img\"&gt; &lt;!-- 未全选 --&gt; &lt;image v-if=\"!selectall\" @click=\"quanxuan('seall')\" src=\"/static/details/weixuan.svg\" mode=\"widthFix\" &gt; &lt;/image&gt; &lt;!-- 全选 --&gt; &lt;image v-if=\"selectall\" @click=\"quanxuan('deall')\" src=\"/static/details/xuanzhong.svg\" mode=\"widthFix\" &gt; &lt;/image&gt; &lt;/view&gt; // 全选商品 async quanxuan(idft) { new this.$Toast('请求中','none').showloading() try{ let selectall = await new this.Request(this.Urls.m().selectall + '?idft=' + idft).modeget() console.log(selectall,'全选商品'); this.ShoppingRequest() uni.hideLoading() }catch(e){ } } 删除购物车商品点击删除按钮，删除选中的商品 由接口可知，删除请求需要携带的参数是已经勾选的商品_id，所以将已经勾选的商品数组中的 _id单独 拿出存放到新数组中 &lt;view class=\"settlement-money\" v-show=\"!settips\" @click=\"total.disable &amp;&amp; deLece()\"&gt;删除 &lt;/view&gt; data() { return { emcart: true, mycarturl:[], //购物车数据 editdata:'管理', settips:true, //默认展示右下角 结算还是删除 mapselect:[], //存放已勾选单个商品的总价 cartdele:[], //存放已经被勾选的商品 _id }; }, // 计算单个商品总价 coselect(){ // 过滤出数组中 choice为 true的对象 即已经勾选的商品 filter会将目标对象放到新数组中 let filselect = this.mycarturl.filter(item =&gt; item.choice) // 取出被选中的 数组中的的总价 this.mapselect = filselect.map(item =&gt; item.total_price) // 将已经被勾选的商品, 购物车_id 单独存放出来 this.cartdele = filselect.map(item =&gt; item._id) }, // 删除 async deLece(){ new this.$Toast('请求中','none').showloading() try{ let cartdelete = await new this.Request(this.Urls.m().cartdelete,{arrid:this.cartdele}).modepost() console.log(cartdelete,'购物车删除商品'); this.ShoppingRequest() uni.hideLoading() }catch(e){ } } 购物车重选sku颜色尺码（上）思路：公共组件addtocart.vue，就是之前写好的sku组件，因此要引用到shopping.vue组件中，然后展示到页面中使用 &lt;!-- sku组件--&gt; &lt;!-- 为什么是skudata 因为 sku组件中 props接收父组件的 键值对k名称就是skudata --&gt; &lt;Addtocart ref=\"addto\" :skudata=\"skudata\"&gt;&lt;/Addtocart&gt; // sku组件 引用到shopping.vue组件中 import Addtocart from '../commponents/addtocart.vue' // 弹出sku组件 直接弹出组件是没数据的因此要调用 相关接口 normsFun(id){ try{ let mycarturl = await new this.Request(this.Urls.m().mycarturl).modeget() }catch(e){ //TODO handle the exception } }, 然后给相应的位置添加点击事件，同时携带商品id传入请求方法中，同时通过ref控制sku组件中的showCou（）方法，将001传入，001代表的是 // 弹出sku组件 直接弹出组件是没数据的因此要调用 相关接口 async normsFun(id){ try{ let cartsku = await new this.Request(this.Urls.m().cartsku + '?id=' + id ).modeget() console.log(cartsku,'弹出sku组件'); this.skudata = cartsku.data this.$refs.addto.showCou('001') // 显示组件 }catch(e){ //TODO handle the exception } }, 在sku组件中，001表示调用001表示购物车重选 &lt;!-- 确定按钮 --&gt; &lt;!-- 利用计算属性 如果两个未选中静止使用确定按钮 --&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '001'\" @click=\"skumen.ban &amp;&amp; detErmine()\"&gt;确定&lt;/view&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '002'\" @click=\"skumen.ban &amp;&amp; detErmine()\"&gt;确定&lt;/view&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '003'\" @click=\"skumen.ban &amp;&amp; purChase()\"&gt;确定&lt;/view&gt; // 被其他组件调用显示sku组件 mean 等于 002代表加入购物车 003代表直接购买 001表示购物车重选 showCou(mean){ this.mean = mean this.couponif = true }, 难点1：当在购物车组件中点击sku时候，展示的效果应该和购物车所选好的尺码颜色等信息相同 思路：点击事件携带的参数，再加上从购物车获取到的本条商品的一些信息传递到sku组件 在购物车组件中，点击normsFun方法，携带相关参数，使用id发起请求，将请求结果cartsku.data 和normsFun点击事件拿到的商品_id 尺码 颜色 商品数量一起传递到 sku组件addtocart中。 &lt;!-- 点击调出sku组件 --&gt; &lt;view class=\"shopp-chick-sku\" @click=\"normsFun(item.id,item.id,item.size,item.color,item.many)\"&gt; &lt;text&gt;{{item.size}}&lt;/text&gt; &lt;text&gt;{{item.color}}&lt;/text&gt; &lt;image src=\"/static/details/jiantou.svg\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; // 弹出sku组件 直接弹出组件是没数据的因此要调用 相关接口 async normsFun(id,_id,size,color,many){ try{ // 购物车页面重选sku接口 let cartsku = await new this.Request(this.Urls.m().cartsku + '?id=' + id ).modeget() console.log(cartsku,'购物车弹出的sku组件'); this.skudata = cartsku.data //得到商品sku展示的所以商品尺码 颜色等信息 let obj = {sku:this.skudata,size,color,_id,many} // 这里重新组合一个对象，传递到sku组件中用于修改弹出的商品信息 this.$refs.addto.showCou('001',obj) // 显示组件同时传递 obj对象 }catch(e){ //TODO handle the exception } } sku组件addtocart，showCou方法的第二个参数，接收了数据，解构数据后进行了如下操作 // 被其他组件调用显示sku组件 mean 等于 002代表加入购物车 003代表直接购买 001表示购物车重选 showCou(mean,obj={}){ this.mean = mean if(mean == '001') { // 解构接收到的值 let {sku,size,color,_id,many} = obj // 将这些值 替代sku组件中的值 this._id = _id // 购物车选中的商品 _id this.momany = many // 购物车选中的商品数量 // 使用findIndex 方法，对购物车弹出的sku所展示的第0项商品信息进行遍历，找出尺码和购物车点击的尺码一样的下标 // findIndex() 方法对数组中存在的每个元素执行一次函数，返回该符合数组元素的索引 否则返回 -1 this.sizenum = sku[0].findIndex(item =&gt; item == size) // 获取在购物车页面点击商品尺码哪里，已经展示的尺码对应的下标 并赋值给sku页面 所展示已经选中的尺码 this.colornum = sku[1].findIndex(item =&gt; item.color == color) // 获取在购物车页面点击商品尺码哪里，已经展示的颜色对应的下标 并赋值给sku页面 所展示已经选中的颜色 this.colorvalue = color //这里是值下方的监听方法，监听到colorvalue值改变后进行改变颜色 this.sizevalue = size //同上监听方法 } this.couponif = true } 购物车重选sku颜色尺码（下）难点：当用户从购物车点进sku组件时，重新选择了商品尺码和颜色后， 点击事件命名为 modifySku 传入修改sku请求接口需要的参数 data 发起请求 &lt;!-- 确定按钮 --&gt; &lt;!-- 利用计算属性 如果两个未选中静止使用确定按钮 --&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '001'\" @click=\"skumen.ban &amp;&amp; modifySku()\"&gt;确定&lt;/view&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '002'\" @click=\"skumen.ban &amp;&amp; detErmine()\"&gt;确定&lt;/view&gt; &lt;view class=\"determine coup-anim\" v-if=\"mean == '003'\" @click=\"skumen.ban &amp;&amp; purChase()\"&gt;确定&lt;/view&gt; // 购物车修改sku async modifySku(){ let {image,price} = this.attribute let data = { id:this._id, skuid:this.id, size:this.sizevalue, color:this.colorvalue, image, price, many:this.momany, } console.log(data); try{ // 购物车修改sku接口 let skubase = await new this.Request(this.Urls.m().skubase,data).modepost(); console.log(skubase,'购物车修改sku接口'); if(skubase.msg == 'SUCCESS') { this.hideCou() //隐藏sku组件 this.$bus.$emit('mycart',{cart:skubase.msg})// 刷新购物车 } }catch(e){ //TODO handle the exception } }, 购物车结算思路：在购物车组件 shopping.vue 中，需要勾选了商品才能结算 提前在计算总价方法中存储已经勾选的商品数据，将其传递到付款组件中，注意因为JSON.parse识别不到某些特殊字符，因此使用 encodeURIComponent、decodeURIComponent方式 // 计算单个商品总价 (已经勾选的商品 filselect ) coselect(){ // 过滤出数组中 choice 为 true的对象 即已经勾选的商品 filter会将目标对象放到新数组中 let filselect = this.mycarturl.filter(item =&gt; item.choice) // 取出被选中的 数组中的的总价 this.mapselect = filselect.map(item =&gt; item.total_price) // 将已经被勾选的商品, 购物车_id 单独存放出来 this.cartdele = filselect.map(item =&gt; item._id) // 存储已经勾选的商品数据 this.settlement = filselect }, // 结算 semEnt(){ console.log('结算'); // 数组，对象转换成字符串才能携带值 let cartdata = JSON.stringify(this.settlement) console.log(cartdata); // 跳转到下单页面 uni.navigateTo({ url:'../payment-page/payment?cartdata=' + encodeURIComponent(cartdata), }) }, 在付款组件，payment.vue中接收值 // e就是路径上携带的值 来自于addtocart组件 purChase方法 onLoad(e){ let cartdataing = decodeURIComponent(e.cartdata) // 将JSON字符串转化为js对象 this.comminfo = JSON.parse(cartdataing) // 合计支付总价计算 numdata默认为0，使用forEach遍历 let numdata = 0 JSON.parse(cartdataing).forEach(item=&gt;{ numdata += item.total_price }) // 合计总价 小数点两位数 this.Totalprice = Price(numdata) // 将需补0的数据传入方法 }, 由于支付接口要求：如果是购物车商品结算，需要把购物车中每个商品的_id作为一个数组字符串存储起来，否则填写空数组 如果支付成功后，购物车里就删除这个商品id的商品 // e就是路径上携带的值 来自于addtocart组件 purChase方法 onLoad(e){ let cartdataing = decodeURIComponent(e.cartdata) //接收json字符串 this.comminfo = JSON.parse(cartdataing) // 将JSON字符串转化为js对象 console.log(this.comminfo ); let numdata = 0 // 合计支付总价计算 numdata默认为0，使用forEach遍历 JSON.parse(cartdataing).forEach(item=&gt;{ numdata += item.total_price }) // 合计总价 小数点两位数 this.Totalprice = Price(numdata) // 将需补0的数据传入方法 // 存储购物车来的数据的商品_id // _id 都在数组 this.comminfo 里边 有可能不止一个商品 因此要 筛选取出 let _id = JSON.parse(cartdataing).filter(item =&gt; item._id) this.idcard = _id.map(item =&gt; item._id) }, 同时，当提交订单支付成功后，应该跳到待发货界面， 2-3步，因为没有商品号，所以注释掉，使用的虚拟支付接口 // 提交订单 async placeOrder(){ // 触发下单按钮后的提示 new this.$Toast('正在下单中','none').showloading() //手动 弹窗 // 商品数据 通过对comminfo数据进行map方法遍历，会返回一个新的数组对象 let codata = this.comminfo.map(item=&gt;{ let data ={ id:item.id, image:item.image, title:item.title, size:item.size, color:item.color, price:item.price, many:item.many, } return data }) // 准备一个对象 将请求需要的参数放入 let dataobj = { consignee:this.orderdata, // 收货地址相关数据 commodity:codata, // 商品相关数据 total_price:this.Totalprice, // 支付总价数据 idcard:this.idcard, // 购物车内所有商品的id相关数据 } // 1.请求统一下单接口 try{ // 微信支付: 统一下单接口 // var wxpay = await new this.Request(this.Urls.m().wxpay,dataobj).modepost(); // 因为个人没有认证微信商户号，这里使用的是虚拟支付接口 返回结果是\"SUCCESS\" let fictpay = await new this.Request(this.Urls.m().fictpayurl,dataobj).modepost(); if(fictpay.msg == \"SUCCESS\") { // 存储商户订单号和订单id // this.outno = wxpayurl.data.out_trade_no // this.ide = wxpayurl.data.id setTimeout(()=&gt;{ new this.$Toast(fictpay.data,'none').showtoast() //反馈 弹窗 // 关闭当前下单页面，跳转到代发货页面 uni.redirectTo({ url:'../personal/personal?index=' + 1 }) },300) } }catch(e){ // e就是throw 捕获的错误 // throw 用来捕获一个错误 //如果catch 中出现throw关键词，此时try catch 后边的代码将不会执行 即不会调用下边的微信接口 new this.$Toast(e,'none').showtoast() //反馈 弹窗 throw e } // 2.调用微信支付接口 // try{ // package：属于源码里的关键词 // 从真正的微信支付接口中拿到返回结果，这五个数据用于调用微信支付接口时作为参数， // let { nonceStr,paySign,signType,timeStamp } = wxpay.data // 使用下方调用支付的方法 // await this.wxPay({ nonceStr,paySign,signType,timeStamp,package:wxpay.data.package }) // }catch(e){ // new this.$Toast('支付失败','none').showtoast() //反馈 弹窗 // uni.redirectTo({ // url:'../personal/personal?index=' + 0 // }) // throw e // } // 3.查询订单是否支付成功 （去微信那边查询是否成功） // try{ // let dataobj = {outno:this.outno,id:this.ide} // let queryorderurl = await new this.Request(this.Urls.m().queryorderurl,dataobj).modepost() // if(queryorderurl.data.msg == 'SUCCESS') { // new this.$Toast('支付成功').showtoast() //反馈 弹窗 // uni.redirectTo({ // url:'../personal/personal?index=' + 1 // }) // } // }catch(e){ // new this.$Toast(e,'none').showtoast() //反馈 弹窗 // } }, 项目优化在首页，点击商品后，应该出现一个正在加载的图标 在pages下新建 full-loading.vue 组件， &lt;template&gt; &lt;view class=\"full-loading\" v-if=\"Loading\"&gt; &lt;image src=\"/static/loading/loadtmall.gif\" mode=\"widthFix\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ data() { return { Loading: true } }, methods:{ init(value = false){ this.Loading = value } } } &lt;/script&gt; &lt;style scoped&gt; .full-loading{ position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: #fff; z-index: 999; } .full-loading image{width: 100rpx; height: 100rpx; } &lt;/style&gt; 再取main.js中引入 // 页面加载loading import loading from 'pages/commponents/full-loading.vue' Vue.component('full-loading',loading) 最后在想要加上加载效果的页面上如下添加 &lt;!-- 页面加载 --&gt; &lt;full-loading ref=\"fullload\"&gt;&lt;/full-loading&gt; // 取消loading组件的加载效果 this.$refs.fullload.init() THE END","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://wuzimo233.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"小程序","slug":"小程序","permalink":"https://wuzimo233.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Axios新版学习大纲","slug":"15-Axios新版学习大纲","date":"2022-06-16T03:12:00.000Z","updated":"2022-06-16T03:36:19.652Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://wuzimo233.github.io/posts/16.html","excerpt":"","text":"Axios入门HTTP相关MDN文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview HTTP请求报文请求行格式: method url 例如: GET/product_detail?id=2 或 POST / login 请求头（一般有多个请求头）Host: www.baidu.com Cookie: BAIDUID=AD3B0FA706E;BIDUPSID=AD3B0FA706; Content-Type: applicartion/x-www-from-urlencoded 或者 application/json 请求体 (get没有)username=tom&amp;pwd=123 {“username”:”tom”,”pwd”:123} HTTP响应报文响应行格式： status status Text 例如： 200 OK 或 404 Not Found 响应头（一般有多个）Content-Type：text/html;charset=utf-8 Set-Cookie:BD_CK_SAM=1;PATH=/ 响应体html/json/js/css/图片 常见的状态码200 OK 请求成功.。一般用于GET/POST请求 201 Created 已创建。成功请求并创建了新的资源 401 Unauthorized 未授权/请求用户的身份证 404 Not Found 服务器无法根据客户端请求找到资源 500 internal Serve Error 服务器内部错误，无法完成请求 请求方式与请求参数请求方式GET（索取）：从服务端读取数据 —– 查（R –Retrieve） POST（交差）：向服务端添加新数据 —– 增（C –Create） PUT：更新服务端已经存在的数据 —— 改（U –Update） DELETE：删除服务器端数据 —— 删（D –Delete） 请求参数query参数（查询字符串参数） 参数包含在请求地址中，格式为:/xxxx?name=tom&amp;age=18 敏感数据不要用query参数，因为参数是地址的一部分，比较危险 备注：query参数又称为查询字符串参数，编码方式为urlencoded params参数 参数包含在请求地址中，格式如下： http://localhost:3000/add_person/tom/18 敏感数据不要用params参数，因为参数是地址的一部分，比较危险 请求体参数（body） 参数包含在请求体中，可通过浏览器开发工具查看 常用的两种格式： 格式一：urlencoded格式 例如：name=tom&amp;age=18 对于请求头：Content-Type：application/x-www-from-urlencoded ​ 格式二：json格式 ​ 例如：{“name”:”tom”,”:age”:12} ​ 对应请求头：Content-Type：application/json 特别注意： GET请求不能携带请求体参数，因为GET请求没有请求体 理论上一次请求可以随意使用上述3种类型参数中的任何一种，甚至一次请求的3个参数可以用3种形式携带，但一般不这样做 一般来说我们有一些”约定俗成”的规矩: (1):例如 from 表单发送 post 请求时，自动使用请求体参数，用urlencoded编码 ​ (2):例如 jQuery 发送ajax-post请求时，自动使用请求体参数，用urlencoded编码 开发中请求到底发给谁？用什么方式？ 携带什么参数？ —要参考项目的API接口文档 API相关API的分类REST API（restful 风格的 API） 发送请求进行 CRUD（增查改删） 哪个操作由请求方式来决定 同一个请求路径可以进行多个操作 请求方式会用到 GET / POST / PUT / DELETE const express = require('express') // 实例一个app服务对象 const app = express() app.get('/person',(req,res)=&gt;{ res.send('一些人的数据给你了') }) app.post('/person',(req,res)=&gt;{ res.send('你成功的添加了一个人') }) app.put('/person',(req,res)=&gt;{ res.send('你成功的修改了一个人') }) app.post('/person',(req,res)=&gt;{ res.send('你成功的删除了一个人') }) app.listen(8090,(error)=&gt;{ if(!error) console.log('服务器开启成功了'); }) 非 REST API (restless 风格的 API) 请求方式不决定请求的 CRUD 操作 一个请求路径只对应一个操作 一般只有 GET / POST // 早些年都这么写，两个请求有4个路径 --不能清晰表达要干嘛 const express = require('express') // 实例一个app服务对象 const app = express() app.get('/get_person',(req,res)=&gt;{ res.send('一些人的数据给你了') }) app.post('/add_person',(req,res)=&gt;{ res.send('你成功的添加了一个人') }) app.post('/update_person',(req,res)=&gt;{ res.send('你成功的修改了一个人') }) // 请求方式不决定请求的 CRUD 操作 app.post('/delete_person',(req,res)=&gt;{ res.send('你成功的删除了一个人') }) app.listen(8090,(error)=&gt;{ if(!error) console.log('服务器开启成功了'); }) 使用 json-server 搭建 REST APIjson-server是什么？ 用来快速搭建REST API 风格的工具包 使用 json-server 在线文档：http:github.com/typicode/json-serrver 下载：npm install -g json-server - 目标根目录下创建数据库 **json** 文件：**db.json** { \"posts\": [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" } ], \"comments\": [ { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 } ], \"profile\": { \"name\": \"typicode\" } } - 启动服务器执行命令：json-server --watch db.json (watch可以省略 db可以改为任意喜欢的名字) #### 使用浏览器访问测试 http://localhost:3000/posts http://localhost:3000/comments http://localhost:3000/profile #### 使用postmon接口测试 **json-server服务器注意：** - postmon测试中发送PUT请求，能在请求体携带id参数（或者使用params携带id），不能用query参数携带id - postmon测试中发送DELETE请求，只能使用params携带参数（json-server模拟的服务器，id都得通过params携带，其他有请求体就用请求体，没有就正常使用params或者query） #### 一般 http 请求与 ajax 请求 - ajax请求是一种特别http请求 - 对服务器端来说，没有任何区别，区别在浏览器端 - 浏览器端发请求：只有XHR或fetch发出得才是ajax请求。其他所有得都是非ajax请求 - 浏览器端接收到响应 ​ （1） 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说得自动刷新/跳转页面 ​ （2）ajax 请求：浏览器不会对界面进行任何更新操作，只是调用监视得回调函数传入响应相关数据 ## axios的理解和使用 ### axios是什么 1.前端最流行的ajax请求库 2.react/vue官方都推荐使用axios发ajax请求 3.文档：https://github.com/axios/axios ### axios特点 1.基于Promise的异步ajax请求库 2.浏览器端/node端都可以使用 3.支持请求/响应拦截器 4.支持请求取消 5.请求/响应数据转换 6.批量发送多个请求 ### 使用axios发送ajax请求 - 终端打开准备好的server文件夹里使用api-doc工具制作的api文档 - 新建 '1_axios的基本使用.html' 文件，同时新建一个js文件夹存放axios.mini.js文件,引入到html里 **准备按钮、文本框** ```html &lt;button id=\"btn1\"&gt;点我获取所有人&lt;/button&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn2\"&gt;点我获取某个人&lt;/button&gt; &lt;input id=\"person_id\" type=\"text\" placeholder=\"请输入一个人的id\"&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn3\"&gt;点我添加一个人&lt;/button&gt; &lt;input id=\"person_name\" type=\"name\" placeholder=\"请输入一个人的名字\"&gt; &lt;input id=\"person_age\" type=\"age\" placeholder=\"请输入一个人的年龄\"&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn4\"&gt;点我更新一个人&lt;/button&gt; &lt;input id=\"person_update_id\" type=\"text\" placeholder=\"请输入一个人的id\"&gt; &lt;input id=\"person_update_name\" type=\"text\" placeholder=\"请输入名字\"&gt; &lt;input id=\"person_update_age\" type=\"text\" placeholder=\"请输入年龄\"&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=\"btn5\"&gt;点我删除一个人&lt;/button&gt; &lt;input id=\"person_delete_id\" type=\"text\" placeholder=\"请输入删除的id\"&gt; 获取按钮、文本框 const btn1 = document.getElementById('btn1') const btn2 = document.getElementById('btn2') const btn3 = document.getElementById('btn3') const personId = document.getElementById('person_id') const personName = document.getElementById('person_name') const personAge = document.getElementById('person_age') const btn4 = document.getElementById('btn4') const btn5 = document.getElementById('btn5') const personUpdateId = document.getElementById('person_update_id') const personUpdateName = document.getElementById('person_update_name') const personUpdateAge = document.getElementById('person_update_age') const personDeleteId = document.getElementById('person_delete_id') 获取所有人的信息 —发送GET请求 —不携带参数 // 获取所有人的信息 ---发送GET请求 ---不携带参数 btn1.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/persons', //请求地址 method: 'GET', //请求方式 }).then( (response) =&gt; { console.log('请求成功了',response.data)}, (error) =&gt; { console.log('请求失败了',error) } ) // 精简版 axios.get('http://localhost:5000/persons').then( response =&gt; {console.log('请求成功了',response.data)}, error =&gt; {console.log('请求失败了',error)} ) } // 如果只想获取到成功的值 可以使用await 方法更简单 btn1.onclick = async() =&gt; { const result = await axios.get('http://localhost:5000/persons') console.log(result.data) } 使用axios发送其他请求发送GET请求获取某个人—发送GET请求—携带query参数 //获取某个人---发送GET请求---携带query参数 btn2.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/person', method: 'GET', params: { id: personId.value }//此处写的是params，但携带的是query参数 }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { '请求失败了', error } ) // 精简版 axios.get('http://localhost:5000/person', { params: { id: personId.value } }).then( response =&gt; { console.log('成功了', response.data); }, error =&gt; { console.log('失败了', error); } ) } 发送POST请求添加一个人—发送POST请求—携带json编码参数 或 urlencoded编码 btn3.onclick = ()=&gt; { axios({ // 完整版 url:'http://localhost:5000/person', method:'POST', data:{name:personName.value,age:personAge.value} //携带请求体参数（json编码） }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { console.log('请求失败了', error); } ) // 精简版 axios.post('http://localhost:5000/person',`name=${personName.value}&amp;age=${personAge.value}`).then( // axios.post('http://localhost:5000/person',{name:personName.value,age:personAge.value}).then( response =&gt; {console.log('请求成功了',response.data)}, error =&gt; {console.log('请求失败了',error)} ) } 发送PUT请求 更新一个人—发送PUT请求—携带json编码参数 或 urlencoded编码 btn4.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/person', method: 'PUT', data: { id:personUpdateId.value, name:personUpdateName.value, age:personUpdateAge.value }, }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { console.log('请求失败了', error); } ) //精简版 axios.put('http://localhost:5000/person',{ id:personUpdateId.value, name:personUpdateName.value, age:personUpdateAge.value }).then( response =&gt; { console.log('请求成功了', response.data) }, error =&gt; { console.log('请求失败了', error) } ) } 发送DELETE请求删除一个人—发送DELETE请求—携带params参数 btn5.onclick = ()=&gt; { axios({ url:`http://localhost:5000/person/${personDeleteId.value}`, method:'DELETE', }).then( (response)=&gt;{console.log('请求成功了',response.data);}, (error)=&gt;{console.log('请求失败了',error);} ) } 结论 axios调用的返回值是Promise实例 成功的值叫response，失败的值叫error axios成功的值是一个axios封装的response对象，服务器返回的真正数据在response.data中 携带query参数时，编写的配置项叫做params 携带params参数时，就需要自己手动拼在url中 axios常用配置项新建‘2_axios常用配置项.html’文件，引入‘axios.min.js’ &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //给axios配置默认属性 axios.defaults.timeout = 2000 axios.defaults.headers = {school:'atguigu'} axios.defaults.baseURL = 'http://localhost:5000' btn.onclick = ()=&gt;{ axios({ url:'/persons', //请求地址 method:'GET',//请求方式 //params:{delay:3000},//配置query参数 //data:{c:3,d:3},//配置请求体参数(json编码) //data:'e=5&amp;f=6',//配置请求体参数(urlencoded编码) //timeout:2000,//配置超时时间 //headers:{school:'atguigu'} //配置请求头 //responseType:'json'//配置响应数据的格式(默认值) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; axios常用语法新建’3_axios.create方法.html‘，引入‘axios.min.js’ axios.create(config) 根据指定配置创建一个新的axios, 也就是每个新axios都有自己的配置 新axios只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 为什么要设计这个语法? 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样 &lt;button id=\"btn3\"&gt;点我获取笑话信息&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn3 = document.getElementById('btn3') // 创建一个新的axios const axios2 = axios.create({ timeout:3000, //headers:{name:'tom'}, baseURL:'https://api.apiopen.top/api' }) //给原axios配置默认属性 axios.defaults.timeout = 2000 axios.defaults.headers = {school:'atguigu'} axios.defaults.baseURL = 'http://localhost:5000' btn3.onclick = ()=&gt;{ axios2({ url:'/getImages', method:'GET' }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; 拦截器函数/ajax请求/请求的回调函数axios请求拦截器 1.是什么？ 在真正发请求前执行的一个回调函数 2.作用： 对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等 新建’4_axios中的拦截器.html‘，引入‘axios.min.js’ &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //请求拦截器 axios.interceptors.request.use((config)=&gt;{ console.log('请求拦截器1执行了'); // 如果时间戳是偶数 就加上请求头 if(Date.now() % 2 === 0){ config.headers.token = 'atguigu' } console.log(config); return config }) btn.onclick = ()=&gt;{ axios.get('http://localhost:5000/persons').then( response =&gt; {console.log('成功了',response.data)}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; axios响应拦截器 1.是什么？ 得到响应之后执行的一组回调函数 2.作用： 若请求成功，对成功的数据进行处理 若请求失败，对失败进行统一的操作 &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //响应拦截器 axios.interceptors.response.use( response =&gt; { console.log('响应拦截器成功的回调执行了',response); if(Date.now() % 2 === 0) { return response.data } else { return '时间戳不是偶数，不能给你数据' } }, error =&gt; { console.log('响应拦截器失败的回调执行了'); alert(error); return new Promise(()=&gt;{}) } ) btn.onclick = async ()=&gt;{ const result = await axios.get('http://localhost:5000/persons2') console.log(result); } &lt;/script&gt; ​ 取消请求&lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const {CancelToken} = axios //CancelToken能为一次请求“打标识” let cancel btn.onclick = async()=&gt;{ axios({ url:'http://localhost:5000/test1?delay=3000', cancelToken:new CancelToken((c)=&gt;{ //c是一个函数，调用c就可以关闭本次请求 cancel = c }) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } btn2.onclick = ()=&gt;{ cancel() } &lt;/script&gt; 取消请求和拦截器配合使用 &lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') // axios里面有个isCancel方法专门用于判断错误，还是用户取消请求导致的不合理。使用{}取出isCancel const {CancelToken,isCancel} = axios //CancelToken能为一次请求“打标识” let cancel btn.onclick = async()=&gt;{ // 每次点击按钮的时候都问一下外边是否有cancel 有没有值 if(cancel){ cancel() } axios({ url:'http://localhost:5000/test1?delay=3000', cancelToken:new CancelToken((c)=&gt;{ //c是一个函数，调用c就可以关闭本次请求 cancel = c }) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; { if(isCancel(error)){ //如果进入判断，证明：是用户取消了请求 console.log('用户取消了请求，原因是：',error.message); }else{ console.log('失败了',error); } } ) } btn2.onclick = ()=&gt;{ cancel('任性，就是不要了') } &lt;/script&gt; &lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const {CancelToken,isCancel} = axios //CancelToken能为一次请求“打标识” let cancel axios.interceptors.request.use((config)=&gt;{ if(cancel) cancel('取消了') config.cancelToken = new CancelToken((c)=&gt; cancel= c) return config }) axios.interceptors.response.use( response =&gt; {return response.data}, error =&gt; { if(isCancel(error)){ //如果进入判断，证明：是用户取消了请求 console.log('用户取消了请求，原因是：',error.message); }else{ console.log('失败了',error); } return new Promise(()=&gt;{}) } ) btn.onclick = async()=&gt;{ const result = await axios.get('http://localhost:5000/test1?delay=3000') console.log(result); } btn2.onclick = ()=&gt;{ cancel('任性，就是不要了') } &lt;/script&gt; 批量的发送请求&lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') btn.onclick = async()=&gt;{ axios.all([ axios.get('http://localhost:5000/test1'), axios.get('http://localhost:5000/test2?delay=3000'), axios.get('http://localhost:5000/test3'), ]).then( response =&gt; {console.log(response);}, error =&gt; {console.log(error);} ) } &lt;/script&gt; ​","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise新版学习大纲","slug":"14-Promise新版学习大纲","date":"2022-06-16T03:10:00.000Z","updated":"2022-06-16T03:36:14.576Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://wuzimo233.github.io/posts/15.html","excerpt":"","text":"Promise准备函数对象与实例对象​ 1.函数对象: 将函数作为对象使用时, 简称为函数对象。 ​ 2.实例对象: new 构造函数或类产生的对象, 我们称之为实例对象。 //函数对象 function Person (name,age){ this.name = name this.age = age } Person.a = 1 //将Person看成一个对象 这是给它添加一个a属性并且赋值为1 //实例对象 --p1是Person的实例对象 const p1 = new Person('老刘',18) console.log(p1); 注意：每一个函数对象有一个不可修改的属性叫name Person.name = 'tom' //这是错误的 因为name值是函数的名（Person） 回调函数的分类什么是回调？​ —①我们定义的函数，②我们没有调用，③最终函数执行了。 两种回调函数同步的回调函数:​ 理解: 立即在主线程上执行, 不会放入回调队列中。 ​ 例子: 数组遍历相关的回调函数 / Promise的executor函数 异步的回调函数:​ 理解: 不会立即执行, 会放入回调队列中以后执行（等主线程忙完） ​ 例子: 定时器回调 / ajax（成功、失败时）的回调 //演示同步的回调函数 let arr = [1,3,5,7,9] arr.forEach((item)=&gt;{ console.log(item); }) console.log('主线程的代码'); //演示异步的回调函数 setTimeout(()=&gt;{ console.log('@'); },2000) console.log('主线程'); 错误类型的说明 js中错误类型有详细的划分，这里进一步理解 JS 中的错误 (Error) 和错误处理 mdn文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error 错误的类型​ Error: 所有错误的父类型 （当发生错误时，将显示下方的子错误类型） ​ ReferenceError: 引用的变量不存在 ​ TypeError: 数据类型不正确 ​ RangeError: 数据值不在其所允许的范围内–死循环 ​ SyntaxError: 语法错误 //演示：ReferenceError: 引用的变量不存在 console.log(a); //演示：TypeError: 数据类型不正确 //（声明一个demo常量，并且赋值一个函数，demo函数是能够被调用的，值是undefined，然后undefined再调用函数,当然显示类型不正确） const demo = ()=&gt;{} demo()() //演示：RangeError: 数据值不在其所允许的范围内 //(声明一个变量demo并赋值一个函数给他，同时函数内部再调用自己（递归函数），然后执行demo函数，然后无限的执行就会超出栈范围) const demo = ()=&gt;{demo()} demo() //演示：SyntaxError: 语法错误 console.log(1; js中的错误处理​ 捕获错误: try{}catch(){} ​ 抛出错误: throw error 如何捕获一个错误？ try中放可能出现错误的代码，一旦出现错误立即停止try中代码的执行，调用catch，并携带错误信息 try { console.log(1); console.log(a); //js引擎捕获到错误 console.log(2); } catch (error) { console.log('代码执行出错了,错误的原因是：',error); } js中的错误处理_抛出错误 //如何抛出一个错误 function demo(){ const date = Date.now() if(date % 2 === 0){ console.log('偶数，可以正常工作'); }else{ throw new Error('奇数，不可以工作！') } } try { demo() } catch (error) { debugger; console.log('@',error); } 错误对象 message属性: 错误相关信息 stack属性: 记录信息 //演示：ReferenceError: 引用的变量不存在 console.log(a); //演示：TypeError: 数据类型不正确 const demo = ()=&gt;{} demo()() //演示：RangeError: 数据值不在其所允许的范围内 const demo = ()=&gt;{demo()} demo() //演示：SyntaxError: 语法错误 console.log(1; Promise的理解和使用Promise是什么？抽象表达:​ (1).Promise是一门新的技术(ES6提出的) ​ (2).Promise是 JS 中异步编程的新方案 ** (旧方案是谁? –**纯回调：只靠回调函数解决（ajax）) 具体表达:​ (1).从语法上来说: Promise是一个内置构造函数 ​ (2).从功能上来说: Promise的实例对象可以用来 封装一个异步操作，并可以获取其成功/失败的值 总结： Promise不是回调函数，是一个内置的构造函数，是程序员自己new调用的。 new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数 –该函数将在构造这个新Promise对象过程中，被构造函数执行 每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected) 每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending) executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收 ​ 1.调用resolve函数会： ​ (1).让Promise实例状态变为成功(fulfilled) ​ (2).可以指定成功的value –resolve(‘ok’) ​ 2.调用reject函数会： ​ (1).让Promise实例状态变为失败(rejected) ​ (2).可以指定失败的reason –reject(‘失败的原因’) &lt;script type=\"text/javascript\"&gt; //创建一个Promise实例对象 const p = new Promise((resolve,reject)=&gt;{ // resolve('ok') reject('失败的原因') // console.log(resolve); console.log(reject); }) console.log('@',p); //一般不把Promise实例做控制台输出 @ Promise {&lt;rejected&gt;: 'ok'} &lt;/script&gt; Promise的基本使用重要语法​ new Promise(executor) 构造函数 ​ Promise.prototype.then 方法 基本编码流程​ 1.创建Promise的实例对象(pending状态), 传入executor函数 ​ 2.在executor中启动异步任务（定时器、ajax请求） ​ 3.根据异步任务的结果，做不同处理： ​ 3.1 如果异步任务成功了： ​ 我们调用resolve(value), 让Promise实例对象状态变为成功(fulfilled),同时指定成功的value ​ 3.2 如果异步任务失败了： ​ 我们调用reject(reason), 让Promise实例对象状态变为失败(rejected),同时指定失败的reason ​ 4.通过then方法为Promise的实例指定成功、失败的回调函数，来获取成功的value、失败的reason ​ 注意：then方法所指定的：成功的回调、失败的回调，都是异步的回调。 关于状态的注意点：​ 1.三个状态: ​ pending: 未确定的——初始状态 ​ fulfilled: 成功的——调用resolve()后的状态 ​ rejected: 失败的——-调用reject()后的状态 ​ 2.两种状态改变 ​ pending ==&gt; fulfilled ​ pending ==&gt; rejected ​ 3.状态只能改变一次！！ ​ 4.一个promise指定多个成功/失败回调函数, 都会调用吗? &lt;script&gt; // 1.声明变量p，将Promise实例对象赋值给它,并且里边传入一个执行器函数executor --里边有两个参数resolve、reject const p = new Promise((resolve,reject)=&gt;{ // 2.函数体 setTimeout(() =&gt; { resolve('我是服务器返回的数据') reject('我是一些错误信息') }, 2000); }).then( // 3.成功和失败后的回调 (value)=&gt;{console.log('成功了',value);}, //成功的回调-异步 (reason)=&gt;{console.log('失败了',reason);} //失败的回调-异步 ) console.log('@'); &lt;/script&gt; Promise与ajax配合使用&lt;!-- ajax配合使用 --&gt; &lt;script&gt; const p = new Promise((resolve,reject)=&gt;{ // 真正开启一个异步任务 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt;{ if(xhr.readyState === 4) { //readyState为4代表接收完毕，接收的可能是：服务器返回的成功数据、服务器返回的错误 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ resolve(xhr.response) }else { reject('请求出错') } } } xhr.open('GET','https://api.apiopen.top/api/sentences') // !!将服务器数据转为json格式 xhr.responseType = 'json' xhr.send() }) p.then( (value)=&gt;{console.log('成功了1',value);}, //成功的回调-异步 (reason)=&gt;{console.log('失败了1',reason);} //失败的回调-异步 ) console.log('@'); &lt;/script&gt; Promise封装ajax请求需求： 每次请求都要输入很多数据比较麻烦因此定义一个 sendAjax() 函数，对xhr的 GET 请求进行封装： 1.该函数接收两个参数：url(请求地址)、data(参数对象) 2.该函数返回一个Promise实例 ​ (1).若ajax请求成功,则Promise实例成功,成功的value是返回的数据。 ​ (2).若ajax请求失败,则Promise实例失败,失败的reason是错误提示。 正常使用promise发送一个ajax请求： // 1.声明变量p，将Promise实例对象赋值给它,并且里边传入一个执行器函数executor --里边有两个参数resolve、reject const p = new Promise((resolve, reject) =&gt; { // 2.实例化 xhr const xhr = new XMLHttpRequest() // 3.绑定监听 xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) resolve(xhr.response) else reject('请求出错') } } xhr.open('GET', 'https://api.apiopen.top/api/getImages?page=0&amp;size=10') xhr.responseType = 'json' xhr.send() }) p.then( (value) =&gt; { console.log('成功了1', value); }, //成功的回调-异步 (reason) =&gt; { console.log('失败了1', reason); } //失败的回调-异步 ) console.log('@'); 使用函数封装后： // 1.定义函数，并准备俩参数接收地址和参数（data是参数对象） function sendAjax(url, data) { // 2.准备一个promise实例 const p = new Promise((resolve,reject) =&gt; { // 3.实例化 xhr const xhr = new XMLHttpRequest() // 4.绑定监听 xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject('请求出了问题'); } } } // 5.整理参数 --需将 page=0&amp;size=10 这种形式转化为 {page:0,size:10}这种形式才能放进地址中作为参数 let str = '' for (let key in data) { str += `${key}=${data[key]}&amp;` } str = str.slice(0, -1) xhr.open('GET', url + '?' + str) xhr.responseType = 'json' xhr.send( }) return p const x = sendAjax('https://api.apiopen.top/api/getImages',{page:0,size:10}) x.then( (data)=&gt;{console.log('成功了',data);}, (reason)=&gt;{console.log('失败了',reason);} ) 封装ajax请求（纯回调方式）需求： 定义一个sendAjax函数，对xhr的get请求进行封装 该函数接收4个参数：url(请求地址)、data(参数对象)、success(成功的回调)、error(失败的回调) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;封装一个简单的ajax(纯回调)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; function sendAjax(url,data,success,error){ //实例xhr const xhr = new XMLHttpRequest() //绑定监听 xhr.onreadystatechange = ()=&gt;{ if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) success(xhr.response); else error('请求出了点问题'); } } //整理参数 let str = '' for (let key in data){ str += `${key}=${data[key]}&amp;` } str = str.slice(0,-1) xhr.open('GET',url+'?'+str) xhr.responseType = 'json' xhr.send() } sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ console.log('成功了',response); }, (err) =&gt;{console.log('第1次失败了',err);} ) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Promise的APIPromise构造函数:new Promise (executor) {} executor函数: 是同步执行的，(resolve, reject) =&gt; {}resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。说明: **excutor函数会在Promise内部立即同步调用,**异步代码放在excutor函数中。 Promise.prototype.then方法:Promise实例.then(onFulfilled,onRejected)onFulfilled: 成功的回调函数 (value) =&gt; {}onRejected: 失败的回调函数 (reason) =&gt; {}特别注意(难点)：then方法会返回一个新的Promise实例对象 验证then的返回值 //验证：then方法会返回一个新的Promise实例对象。(暂且不研究返回的这个新Promise实例状态怎么变化) const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(100) },1000) }) const x = p.then( value =&gt; {console.log('成功了',value);}, reason =&gt;{console.log('失败了',reason);} ) console.log('50'); console.log(x); // pomise {&lt;pending&gt;} Promise.prototype.catch方法: Promise实例.catch(onRejected)onRejected: 失败的回调函数 (reason) =&gt; {}说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected) //Promise.prototype.catch方法 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject(100) },1000) }) p.then( value =&gt; {console.log('成功了1',reason);}, reason =&gt; {console.log('失败了1',reason);} ) p.catch( reason =&gt; {console.log('失败了2',reason);} ) Promise.resolve方法: Promise.resolve(value)说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象备注：当状态为rejected是因为value的值可能是： (1)非Promise值 – 100、’abc’、{}、[] (2)Promise值 – Promise实例（此时值是传入的promise实例，值成功或者失败） 例子：Promise.resolve方法生成了一个状态为失败的Promise对象实例 p //Promise.resolve const p0 = Promise.reject(-100) const p = Promise.resolve(p0) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.reject方法: Promise.reject方法(reason)说明: 用于快速返回一个状态必为rejected的Promise实例对象 例子：Promise.reject方法即使传入一个状态为成功的Promise对象实例值也是失败的 即失败的原因是那个成功的promise对象实例 //Promise.reject const p0 = Promise.resolve(100) const p = Promise.reject(p0) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.all方法:Promise.all(promiseArr)promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。 //Promise.all const p1 = Promise.resolve('a') const p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('b') //有一个失败了就直接失败。 },500) }) const p3 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('c') },2000) }) const x = Promise.all([p1,p2,p3]) x.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.race方法:Promise.race(promiseArr)promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。 //Promise.race const p1 = Promise.reject('a') const p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('b') },500) }) const p3 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('c') },2000) }) const x = Promise.race([p3,p1,p2]) x.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise的几个关键问题：如何改变Promise实例的状态？ 执行resolve(value): 如果当前是pending就会变为fulfilled 执行reject(reason): 如果当前是pending就会变为rejected 执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected &lt;script type=\"text/javascript\" &gt; const p = new Promise((resolve,reject)=&gt;{ console.log(a); //浏览器引擎抛异常 // throw 900 //编码抛异常 }) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) &lt;/script&gt; 改变Promise实例的状态和指定回调函数谁先谁后? 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 //先指定回调，后改变状态（最常见） const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },4000) }) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) 如何先改状态再指定回调? 延迟一会再调用then() //先改状态，后指定回调 const p = new Promise((resolve,reject)=&gt;{ resolve(100) }) setTimeout(()=&gt;{ p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) },2000) Promise实例什么时候才能得到数据? 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 then如何链式调用？Promise实例.then()返回的是一个【新的Promise实例】 它的值和状态由什么决定? 简单表达: 由then()所指定的回调函数执行的结果决定 详细表达: 如果then所指定的回调返回的是非Promise值a: ​ 那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a 如果then所指定的回调返回的是一个Promise实例p: ​ 那么【新Promise实例】的状态、值，都与p一致 如果then所指定的回调抛出异常: ​ 那么【新Promise实例】状态为rejected, reason为抛出的那个异常 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },1000) }) p.then( value =&gt; {console.log('成功了1',value); return Promise.reject('a')}, reason =&gt; {console.log('失败了1',reason);} ).then( value =&gt; {console.log('成功了2',value);return true}, reason =&gt; {console.log('失败了2',reason); return 100} ).then( value =&gt; {console.log('成功了3',value);throw 900}, reason =&gt; {console.log('失败了3',reason); return false} ).then( value =&gt; {console.log('成功了4',value);return -100}, reason =&gt; {console.log('失败了4',reason);} ) 纯回调会引起的问题？如下：可以发现代码非常的混乱，不利于查阅，且当再多发几次的请求后更加难以查阅 // 调用之前封装好的 sendAjax函数 sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调1 console.log('第一次成功了',response) sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调2 console.log('第二次成功了' ,response) sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调3 console.log('第三次成功了',response) }, (err) =&gt;{ // 失败的回调3 console.log('第三次失败了',err); } ) }, (err) =&gt;{ // 失败的回调2 console.log('第二次失败了',err); } ) }, (err) =&gt;{ // 失败的回调1 console.log('第1次失败了',err); } ) 使用then的链式调用解决回调地狱注意：then方法会返回一个新的Promise实例对象 但是因为其成功的value回调里还返回了 sendAjax()方法，该方法的返回值也是Promise实例对象，所以then返回的新Promise实例的状态、值，都与sendAjax()方法返回的promise一致 （详情见上方 ‘then如何链式调用‘ ） // 调用之前封装好的 sendAjax函数 （详情见上方 'Promise封装ajax请求'） //发送第1次请求 sendAjax('https://api.apiopen.top/api/getImages',{page:0}) /* 注意：then方法会返回一个新的Promise实例对象 但是因为其成功 的value回调里还返回了 sendAjax()方法，该方法的返回值也是 Promise实例对象，所以then返回的新Promise实例的状态、值， 都与sendAjax()方法返回的promise一致 （详情见上方 'then如何链式调用' ） */ .then( value =&gt; { console.log('第1次请求成功了',value); //发送第2次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第1次请求失败了',reason);} ) .then( value =&gt; { console.log('第2次请求成功了',value); //发送第3次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第2次请求失败了',reason);} ) .then( value =&gt; {console.log('第3次请求成功了',value);}, reason =&gt; {console.log('第3次请求失败了',reason);} ) 中断Promise链原因： 代码同上的时候，假如将发送第1次请求的地址写错后，第二次、第三次依然会因为种种原因继续执行。 思路： 当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。 办法: 在失败的回调函数中返回一个pendding状态的Promise实例。在每次reason后加上 ‘ return new Promise(()=&gt;{}) ’ 这样then返回的promise实例对象状态是pending就不会执行后边的value和reason 代码如下： .then( value =&gt; { console.log('第1次请求成功了',value); //发送第2次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第1次请求失败了',reason);return new Promise(()=&gt;{})} ) .then( value =&gt; { console.log('第2次请求成功了',value); //发送第3次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第2次请求失败了',reason);return new Promise(()=&gt;{})} ) .then( value =&gt; {console.log('第3次请求成功了',value);}, reason =&gt; {console.log('第3次请求失败了',reason);} ) Promise的错误穿透 当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调, 前面任何操作出了错误, 都会传到最后失败的回调中处理了 备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。 原理：底层帮我们在then里补上了一个失败的回调 reason =&gt; {throw reason} 又因为then所指定的回调抛出异常，那么新Promise实例状态为rejected, reason为抛出的那个异常 //另一个例子演示错误的穿透 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject(-100) },1000) }) p.then( value =&gt; {console.log('成功了1',value);return 'b'}, reason =&gt; {throw reason}//底层帮我们补上的这个失败的回调 ) .then( value =&gt; {console.log('成功了2',value);return Promise.reject(-108)}, reason =&gt; {throw reason}//底层帮我们补上的这个失败的回调 ) .catch( // reason =&gt; {throw reason} reason =&gt; {console.log('失败了',reason)} ) Promise的优势优势： 指定回调函数的方式更加灵活: ​ 旧的: 必须在启动异步任务前指定（如之前用jQuery封装的get请求，需要提前写好成功和失败的回调） ​ promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定) 支持链式调用, 可以解决回调地狱问题 ​ (1)什么是回调地狱： ​ 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件 ​ (2)回调地狱的弊病： ​ 代码不便于阅读、不便于异常的处理 ​ (3)一个不是很优秀的解决方案： ​ then的链式调用 ​ (4)终极解决方案： ​ async/await（底层实际上依然使用then的链式调用） async/await的使用 注意: ​ await必须写在async函数中, 但async函数中可以没有await ​ 如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try…catch来捕获处理 const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('a') }, 1000) }) const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('b') }, 2000) }) const p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('c') }, 4000) }) // async function demo() { /*当Promise实例对象p状态为失败时， 一旦try中的代码发生了抛异常， 将会携带异常来到catch，此时err就是抛出的'a' */ //（记得前边加分号） ; (async () =&gt; { // try中放可能存在错误的代码 try { const result1 = await p1 console.log('成功了', result1); const result2 = await p2 console.log('成功了', result2); const result3 = await p3 console.log('成功了', result3); } catch (error) { console.log('失败了',error); } })() await的应用（解决链式调用）//准备好一个 Promise封装好的发送ajax get请求的函数 --sendAjax(url,data) (async()=&gt;{ try { // 如果wait右侧的表达式为Promise实例对象，await后的返回值是promise成功的值 const result1 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第1次请求成功了',result1); const result2 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第2次请求成功了',result2); const result3 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第3次请求成功了',result3); } catch (error) { console.log(error); } })() async与await的规则 async修饰的函数 ​ 函数的返回值为promise对象 ​ Promise实例的结果由async函数执行的返回值决定 await表达式 ​ await右侧的表达式一般为Promise实例对象, 但也可以是其它的值 ​ (1).如果表达式是Promise实例对象, await后的返回值是promise成功的值 ​ (2).如果表达式是其它值, 直接将此值作为await的返回值 //测试async async function demo(){ const result = await p1 console.log(result); } demo() await原理 若我们使用async配合await这种写法： 1.表面上不出现任何的回调函数 2.但实际上底层把我们写的代码进行了加工，把回调函数“还原”回来了。 3.最终运行的代码是依然有回调的，只是程序员没有看见。 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },4000) }) async function demo(){ //程序员“轻松”的写法 const result = await p console.log(result); console.log(100); console.log(200); } demo() console.log(1); //浏览器翻译后的代码 /* p.then( result =&gt; { console.log(result); console.log(100); console.log(200); }, ) */ 宏队列与微队列宏队列:[宏任务1，宏任务2…..] –如主线程上定时器就是宏任务 微队列:[微任务1，微任务2…..] –promise实例对象的then方法内就是微任务 规则：每次要执行宏队列里的一个任务之前，先看微队列里是否有待执行的微任务 1.如果有，先执行微任务 2.如果没有，按照宏队列里任务的顺序，依次执行 //代码一 setTimeout(()=&gt;{ console.log('timeout') },0) Promise.resolve(1).then( value =&gt; console.log('成功1',value) ) Promise.resolve(2).then( value =&gt; console.log('成功2',value) ) console.log('主线程') // 控制台结果 主线程 成功1 1 成功2 2 timeout //代码二 setTimeout(()=&gt;{ console.log('timeout1') }) setTimeout(()=&gt;{ console.log('timeout2') }) Promise.resolve(1).then( value =&gt; console.log('成功1',value) ) Promise.resolve(2).then( value =&gt; console.log('失败2',value) ) // 控制台结果 成功1 1 失败2 2 timeout1 timeout2 //代码三 setTimeout(()=&gt;{ console.log('timeout1') Promise.resolve(5).then( value =&gt; console.log('成功了5') ) }) setTimeout(()=&gt;{ console.log('timeout2') }) Promise.resolve(3).then( value =&gt; console.log('成功了3') ) Promise.resolve(4).then( value =&gt; console.log('成功了4') ) // 控制台结果 成功了3 成功了4 timeout1 成功了5 timeout2 经典面试题典型的先指定回调后改变状态 以下代码的执行流程： 首先可以判断是先指定回调再改变状态 主线程上的代码在飞速运行，new Promise后瞬间开始执行代码。然后执行器函数excuter是同步的回调函数，由于同步的回调函数不会往回调队列里边进，主线程上直接执行这些代码，瞬间开启一个定时器，那么setTimeout所指定的回调不是马上推入队列（除非到点了），而是放到浏览器的定时器管理模块，到点后定时器管理模块把setTimeout所指定的回调再推向宏队列，当主线程任务完成后才执行setTimeout所指定的回调。 再来看主线程，new Promise在主线程上使用后，执行器函数也是在主线程上执行，定时器setTimeout内置函数也是在主线程上飞速的执行完毕（而最重要的是setTimeout其里边的函数体需要到点后再推向队列），然后主线程开始执行p.then(),这其中有成功和失败的两个函数参数，是挂在实例自身上了。可以理解为只要是Promise实例对象，那么一出生身上就有个类似 P.list = []的结构，于是这里把成功和失败的回调推向这个里边（不是推向队列，因为还不知到上方状态的结果，除非是知道状态才去调用成功/失败的回调）一旦setTimeout内函数体从宏队列拉出执行，才发现状态是否成功。然后去自身找到之前缓存的成功/失败的回调。 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ // 函数体 resolve('ok') },1000) }) p.then( (value)=&gt;{console.log(value);}, (reason)=&gt;{console.log(reason);} ) 典型的先改状态后指定回调 /* 典型的先改状态后指定回调 这个Promise实例对象一出生瞬间变为成功的状态，然后指定回调。即成功后直接把成功的回调推向了微队列。 （记住要执行的时候才进队列，等着主线程将它勾出来去执行） */ const p = new Promise((resolve,reject)=&gt;{ resolve('ok') }) p.then( (value)=&gt;{console.log(value);}, (reason)=&gt;{console.log(reason);} ) 面试题 判断出控制台的输出结果？ 注意：分析方法的注释是按照1~9顺序排列 // 1、立马反应setTimeout立即调用，但是不能进主线程而是进宏队列 宏队列保存 0 setTimeout(()=&gt;{ console.log('0'); },0) // 2、当主线程执行到此时，控制台输出 1，并且new一个Promise 判断出它是一个同步的回调 立刻马上输出1 且瞬间状态切换为成功 new Promise((resolve,reject)=&gt; { console.log('1'); resolve() // 3、状态成功后执行 .then()方法里的回调，但是！！这是属于异步回调，需要先推入微队列 微队列保存 2 }).then(()=&gt;{ /* 6、主线程分析完后,接着开始分析微队列 此时将2输出到控制台，此刻控制台为 1、7、2 此时微队列抹去 2 又 new了一个Promise，执行器在主线程运行马上输出3，同时resolve()将状态变为成功了 此刻控制台为 1、7、2、3 状态成功后，在.then()方法里有一个为其指定得成功得回调 ，!!注意这个回调也先得推入微队列,即把4所在 回调推入微队列.此时队列保存8、4 下一个.then()也是为左侧.then()返回得新Promise实例对象指定得回调,但是前一个实例的状态是由4所在 的回调来定义,而4目前还未执行，所以5就挂在了自身上不推入队列 此刻当前花括号内代码执行完毕,程序默认给Promise返回的值为undefined */ console.log('2'); new Promise((resolve,reject)=&gt; { console.log('3'); resolve() }).then(()=&gt;{ /* 9、接着将4所在的回调拉入主线程执行 输出4 此刻控制台为 1、7、2、3、8、4 如果4所在的回调执行了,那么就说明所在的.then的状态就敲定了,返回undefined 因为.then()左侧有了结果,就把 5 推入微队列 ,此时微队列保存6、5 接着将6(所在的回调)拿出队列,推入主线程,此刻控制台为 1、7、2、3、8、4、6 接着将5(所在的回调)拿出队列,推入主线程,此刻控制台为 1、7、2、3、8、4、6、5 最后 把宏队列的0(所在的回到)推入主线程,此刻控制台为 1、7、2、3、8、4、6、5、0 */ console.log('4'); }).then(()=&gt;{ console.log('5'); }) /* 4、这里的.then()不会推入队列，是因为它左侧的Promise实例还没有执行没有返回出结果，这里当然不能执 行，而是暂存放到左侧Promise实例身上 */ }).then(()=&gt;{ /* 7、因为.then左侧返回undefined,所以新Promise实例状态为成功, 成功的value为undefined 因为.then()左侧有了结果,就把 6 推入微队列 ,此时队列保存8、4、6 */ console.log('6'); }) /* 5、又 new了一次Promise 此时控制台先输出 1、7 ，因为直接改变状态为成功，意味着要去调用后边 的.then()方法，当然得先把.then()方法推向微队列 此时队列保存 2 8 */ new Promise((resolve,reject)=&gt;{ console.log('7') resolve() }).then(()=&gt;{ // 8、接着将8从队列拉出,此刻控制台为 1、7、2、3、8 此时队列保存4、6 console.log('8'); }) 包管理器的对比：仅用cnpm的仓库地址 使用yarn的命令 偶尔yarn网络不好，使用npm","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"AJAX新版学习大纲","slug":"13-AJAX新版学习大纲","date":"2022-06-16T03:08:00.000Z","updated":"2022-06-16T03:36:07.277Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://wuzimo233.github.io/posts/14.html","excerpt":"","text":"AJAX 入门AJAX 简介 AJAX全称为Asynchronous Javascript And XML，就是异步的 JS 和 XML。 通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：页面无刷新获取数据。 AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 ajax也是属于原生js的http请求，可以说是一种特殊的http请求。 在以往提交表单一般是这样子 &lt;body&gt; &lt;form action=\"https://www.baidu.com\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"pad\"&gt; &lt;!-- button按钮会触发表单的提交 --&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; XML简介 XML：可扩展标记语言 XML：被设计用来 传输和存储数据 比方说客户端（client）与 服务器（serve）前后台进行数据交互的时候，你想获取十条新闻，服务器就要给你十条新闻，那么关键是用的什么方式给你？ 于是服务器可以用XML这种字符串形式给你，XML本质就是字符串，不过有很多的规矩。 XML和HTML类似都是可扩展的标记语言，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据 例：用xml表示学生数据 &lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/student&gt; 可以发现体积较大了 现在已被JSON取代 例：用JSON表示学生数据 {\"name\":\"孙悟空\",\"age\":18,gender:\"男\"} AJAX 的特点AJAX 的优点 可以 **无需刷新页面与服务端进行通信 **获取数据 允许你根据用户事件来更新部分页面内容（例如淘宝鼠标移动到某个区域页面不刷新，但是部分区域内容更新） AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题（同源）–面试高频问题 SEO不友好（爬虫获取不到信息） AJAX 的使用核心对象:XMLHttpRequestAJAX的所有操作都是通过该对象进行的 搭建测试ajax的服务器新建任意名的文件夹（最好不用数字开头，不能有大写字母） 接着使用 yarn init （或者 npm init）将当前项目文件夹变成符合npm规范的包 使用 yarn express 安装express 项目文件夹下新建一个serve.js用来当作服务器 // 1. 引入express const express = require('express') // 2.创建一个app实例对象 const app = express() // 4.配置一个路由 （比如想响应get请求，就起一个 'test_get' 的名字 ,里面有两个对象，请求和响应） app.get('/test_get',(request,response)=&gt;{ // 函数体 response.send('hello_test_get!!!') }) // 3.绑定监听 端口号（一般4位数字） + 回调（err是错误对象，如果没有错误对象就证明服务器开启成功） app.listen(8080,(err)=&gt; { if(!err) console.log('测试ajax请求的服务器开启成功了'); }) 启动服务器（三种方式）：node serve / nodemon .\\serve.js / 使用第三方插件 Code Runner（右键 点击Run Code开启，快捷键 ctrl+alt+m 关闭服务） 浏览器地址栏输入查看：localhost:8080/test_get (浏览器默认是get请求) ajax小试牛刀ajax也是属于原生js的http请求，可以说是一种特殊的http请求。 项目根目录新建文件夹src，下新建 ‘1_ajax小试牛刀.html’文件，右键文件使用vscode的Live Server打开 //... &lt;style&gt; #content { width: 300px; height: 100px; border: 1px solid black; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是测试：ajax小试牛刀&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 2.指定发送请求的：method、url xhr.open('GET','http://localhost:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当点击按钮后控制台会报错，出现经典的跨域问题。（如果提示有…the serve responded with a status of 404 :5050/favicon.ico:1 (Not Found) 那么需要找一个ico图片放到项目文件根目录下即可） 解决跨域： 服务器中暴露静态资源 // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 4.配置一个路由 （比如想响应get请求，就起一个 'test_get' 的名字 ,里面有两个对象，请求和响应） app.get('/test_get',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get了'); response.send('hello_test_get!!!') }) // 3.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/1_ajax小试牛刀.html'); } }) 在html文件中将发送请求的url改成 ‘ http://127.0.0.1:8080/test_get ‘，然后不使用vscode的Live Server打开，而是复制到浏览器使用serve.js的 ‘http://127.0.0.1:8080/1_ajax小试牛刀.html’ 地址，同时要看到请求是否成功需要借助xhr的状态state来将xhr.response的结果返回给div中 &lt;h3&gt;该页面是测试：ajax小试牛刀&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xhr的5种状态（了解）复制’1_ajax小试牛刀.html’文件，改名为‘2_xhr的5种状态.html’，其他步骤和1文件类似方法打开 注意服务器需要再写一行 //方便复制 // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/1_ajax小试牛刀.html'); console.log('http://127.0.0.1:8080/2_xhr的5种状态.html'); //方便复制 } }) 页面html文件代码如下： //... &lt;h3&gt;该页面是测试：xhr的5种状态.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // xhr实例对象在实例出来的那一刻就是0,随着请求变化不断变化 /* xhr内部有5种状态,5种状态值分别为:0、1、2、3、4 0:实例出来的那一刻就是0,初始状态 1:open已经调用,但是send没有调用,此时可以修改请求头内容 2:send已经调用了,已经无法修改请求头 3:已经回来部分数据,小的数据会在此阶段一次性接收完毕,较大的数据有待进一步接收,响应头回来了. 4:数据全部接收完毕 // getAllResponseHeaders获取所有响应头 */ xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 1) { // xhr的请求头api setRequestHeader //配置请求头:请求头中增加 key:value // xhr.setRequestHeader('demo',123) // alert('@') } if(xhr.readyState === 2) { // xhr.setRequestHeader('demo',123) //配置请求头:报错 因为2阶段无法修改请求头了 } if(xhr.readyState === 3) { console.log('3时接收到的数据',xhr.response); console.log('3时接收到的响应头',xhr.getAllResponseHeaders()); } if(xhr.readyState === 4 &amp;&amp; (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：请求成功的判断最好详细一点 if(xhr.readyState === 4 &amp;&amp; (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)){ ​ //...... } ajax的get请求（掌握）复制’2_xhr的5种状态.html’文件，改名为‘3_ajax_get请求.html’，其他步骤和2文件类似方法打开 页面html文件代码: //... &lt;h3&gt;该页面是测试：ajax_get请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } // 2.指定发送请求的：method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数的urlencoded编码形式 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET','http://127.0.0.1:8080/test_get?name=老刘&amp;age=18') //携带query参数 xhr.open('GET','http://127.0.0.1:8080/test_get2/老刘/18') //携带params参数 // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码 // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应GET请求 -query参数 app.get('/test_get',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get了--携带的query参数是：',request.query); response.send('hello_test_get!!!') }) // 3.响应GET请求 -params参数 app.get('/test_get2/:name/:age',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get2了--携带的params参数是：',request.params); response.send('hello_test_get2!!!') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/3_ajax_get请求.html'); } }) ajax的post请求（掌握）复制’3_ajax_get请求.html’文件，改名为‘4_ajax_post请求.html’，其他步骤和3文件类似方法打开 页面html文件代码如下： //... &lt;h3&gt;该页面是测试：ajax_post请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的POST请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } // 2.指定发送请求的：method、url、参数 // post 可以携带query params参数 和请求体body（body有两种编码形式 urlencoded 、json） // xhr.open('POST','http://127.0.0.1:8080/test_post?name=tom&amp;age=18') // 携带query参数 xhr.open('POST','http://127.0.0.1:8080/test_post') // 不带参数 (参数放到下方请求体发送) // 追加响应头用于标识携带请求体参数的编码形式 --urlencoded 形式 // xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded') // 追加响应头用于标识携带请求体参数的编码形式 --json 形式 xhr.setRequestHeader('Content-type','application/json') // 3.发送请求 （post请求可以携带query、params参数，但是一般不带，而是放到请求体里面） 请求体里用urlencoded / json编码形式 const person = { name:'老刘', age:18 } // xhr.send('name=老刘&amp;age=18') //携带 urlencoded 编码形式的请求体参数 xhr.send(JSON.stringify(person)) //携带 json 编码形式的请求体参数 --使用JSON.stringify()方法将对象转为json格式 } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码： // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 使用中间件express.urlencoded() 解析urlencoded编码形式的请求体参数 // 简单说：如果想用express框架接收post请求所携带的请求体参数，需要借助中间件 express.urlencoded app.use(express.urlencoded({extended:true})) // 使用中间件解析json编码形式的请求体参数 app.use(express.json()) // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应POST请求 -请求体参数(后端需要占位符) app.post('/test_post',(request,response)=&gt;{ console.log('有人请求test_post了,携带的请求体参数是:',request.body); response.send('hello_test_post!!!') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/4_ajax_post请求.html'); } }) git相关操作克隆仓库 例：在一个名为student_ajax文件夹右键打开Git Bush Here 使用 git clone ‘仓库地址’，拿到公司代码 （此时克隆下来的文件里面有.git文件夹，该文件夹里边配置的是克隆的远程仓库的地址） 本地环境yarn 下载依赖 git add * –将文件放到暂存区 git commit -m ‘描述干啥事情了’ –对刚才的操作进行注释 目前文件仅在本地git仓库里，还需要推送到线上仓库 git push origin master 当线上主线文件更新了之后，支线需要下载主线的最新版本，使用 git pull origin master 拉取代码 那么这样拉取后本地文件将被线上文件覆盖，所以建议单独新建个文件夹存放克隆的的仓库，每次线上有更新就拉取代码到本地该文件夹里 借助vscode去操作git ajax解析json数据（了解）推荐安装FeHelper(前端助手)插件到浏览器。 新建’5_ajax_解析json数据.html’ 页面html文件代码如下： // ... &lt;h3&gt;该页面是：解析json数据.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') btn.onclick = ()=&gt; { // 1.实例化xhr对象 const xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); // 将json格式解析成对象 然后使用解构赋值 // 因为不知道后端那边的数据格式，假如后端是对象，直接使用JSON.parse（）就会报错 在3下方使用 xhr.responseType = 'json'解决 const {name,age,sex} = (xhr.response) content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person') // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 4.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码： // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 使用中间件express.urlencoded() 解析urlencoded编码形式的请求体参数 // 简单说：如果想用express框架接收post请求所携带的请求体参数，需要借助中间件 express.urlencoded app.use(express.urlencoded({extended:true})) // 使用中间件解析json编码形式的请求体参数 app.use(express.json()) // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应get请求 app.get('/get_person',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'老刘',age:'18',sex:'女'} response.send(JSON.stringify(person)) //response.send('hello') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/5_ajax_解析json数据.html'); } }) 连续解构赋值&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 例子 想要得到c ？？ let obj = { a:1, b:{ c:2, }, } // 方法1 --标准的解构赋值得到 2 // const {c} = (obj.b) // console.log(c); / // 方法2 --连续解构赋值 // const {b:{c}} = obj // console.log(c); // 得到 2 // 新需求不喜欢用c名称，改为value // 连续解构赋值 + 重命名 const {b:{c:value}} = obj console.log(value); // 得到 2 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 处理IE浏览器-get请求缓存问题（了解）协商缓存 –一般浏览器中，当页面第一次向服务器发起请求后，服务器返回数据给页面，在控制台终端Network中可以看到请求的状态码是200。此时，当服务器中的数据更新（改变）后，页面第二次向服务器发起请求，页面数据随之变化，但是第三次点击按钮，控制台终端的状态码显示304（因为这次和上一次请求的地址都没有变化，浏览器会认为返回的信息依然和之前一样，但还是会问一问服务器，数据是否有变化，此时若服务器返回没有变化，那么浏览器会从自己缓存中读取数据，304就出现了） 所以也叫协商缓存。 但是！IE浏览器，在遇到该问题时候非常武断，直接不问服务器直接拿之前的数据给页面用。–IE的强缓存机制 解决方式：加上了时间戳参数，忽悠IE浏览器每次的请求地址不同。即使服务器接口没有参数，默认不处理请求来的参数。 // 指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person?t='+Date.now()) 请求异常与超时的处理新建’ 7_ajax请求的异常与超时处理.html ‘文件 页面html文件代码如下： &lt;h3&gt;该页面是：ajax请求的异常与超时处理.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') btn.onclick = function(){ // 1.实例化xhr对象 const xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay?t='+Date.now()) // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 网络不好的处理 --配置出错的回调 xhr.onerror = ()=&gt;{ alert('请求出错了，可能当前网络不稳定请稍后再试'); } //超时时间 --这个api意思是仅请求2秒，2秒后没有数据返回就取消请求 xhr.timeout = 2000 // 超时后的回调 xhr.ontimeout = () =&gt; { alert('网速不给力，请切换网络'); } // 4.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码 // 3.响应get请求 --延时响应 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} // 3秒后返回数据 setTimeout(()=&gt;{ response.send(JSON.stringify(person)) },3000) }) ajax取消请求（掌握）新建 ’ 8_ajax取消请求.html ‘ 页面html文件代码如下： // ... &lt;h3&gt;该页面是：ajax取消请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const content = document.getElementById('content') let xhr btn.onclick = function(){ // 1.实例化xhr对象 xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay?t='+Date.now()) // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 网络不好的处理 --配置出错的回调 xhr.onerror = ()=&gt;{ alert('请求出错了，可能当前网络不稳定请稍后再试'); } //超时时间 --这个api意思是仅请求2秒，2秒后没有数据返回就取消请求 xhr.timeout = 2000 // 超时后的回调 xhr.ontimeout = () =&gt; { alert('网速不给力，请切换网络'); } // 4.发送请求 xhr.send() // xhr.abort() //这里只要发送请求的次数多还是有概率会取消不了 } //点击第二个按钮后触发取消请求 btn2.onclick = function() { xhr.abort() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 3.响应get请求 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} response.send(JSON.stringify(person)) 如何避免用户发送重复请求（掌握）新建 ’ 9_避免多次重复请求.html ‘ 页面html文件代码如下： 思路：点击按钮前，定义一个isLoading变量 代码执行顺序：当第一次点击按钮后，先判断isLoading变量，为假就取消。然后实例化xhr，指定发送请求的格式参数，发送请求，接着关键一点就是将isLoading变量变为真，（这样当下次点击按钮时候，isLoading变量为真就会取消下次的请求）然后判断服务器那边的状态码将isLoading变量变为假。 // ... &lt;h3&gt;该页面是：避免多次重复请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') let xhr // 声明一个变量，假如它为真代表正在发送请求中，就可以在之后取消请求 let isLoading // 每次点击按钮 xhr将被重新实例化，即每次都被替换成新的xhr对象 btn.onclick = function(){ // 这里代表第一次点击按钮 由于isLoading为undefin 所以不会取消请求 if(isLoading) xhr.abort() // 1.实例化xhr对象 xhr = new XMLHttpRequest() // 4. 这是判断服务器那边的状态码 （绑定监听） xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { isloading = false; console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 2.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay') // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 3.发送请求 xhr.send() isLoading = true } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码: // 3.响应get请求 --延时响应 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} // 3秒后返回数据 setTimeout(()=&gt;{ response.send(JSON.stringify(person)) },3000) }) jQuery封装的ajax（了解）新建 ‘10_jquery封装的ajax.html’ 打开浏览器 –下载好jquerymini.js放到文件中引入 页面html文件代码如下： // ... &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是：jQuery封装的ajax.html&lt;/h3&gt; &lt;button id=\"btn1\"&gt;点我发送请求（jQuery-ajax-get）&lt;/button&gt; &lt;button id=\"btn2\"&gt;点我发送请求（jQuery-ajax-post）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn1 = $('#btn1') const btn2 = $('#btn2') const content = $('#content') btn1.click(() =&gt; { // 使用jQyuery发送get请求 --完整版写法 $.ajax({ url: 'http://127.0.0.1:8080/test_jquery_get', //请求地址 method: 'GET', //请求方式 --不写的话默认也是get data: { school: '麻省理工学院' }, //携带的数据 dataType: 'json', //配置响应数据格式 --将服务器拿到的json数据类型转换成对象 timeout:'2000', //指定超时的时间 // 成功的回调函数 success: (result, responseText, xhr) =&gt; { //第二个参数 responseText --代表本次响应（成功与否）的文字 第三个参数是xhr console.log(result, responseText, xhr); content.append(`&lt;div&gt;汽车名：${result.name},价格：${result.price}&lt;/div&gt;`) }, // 失败的回调 error: (xhr) =&gt; { //里边可以有 xhr参数 console.log('请求出错了'); } }) // 使用jQyuery发送get请求 携带query参数 --简版写法 // 如果是params请求 /test_jquery_get/bilibili // $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ // console.log(data); // },'json') }) btn2.click(() =&gt; { // 使用jQyuery发送 post请求 --完整版写法 $.ajax({ url: 'http://127.0.0.1:8080/test_jquery_post', //请求地址 method: 'POST', //请求方式 --不写的话默认也是get data: { school: '麻省理工学院' }, //携带的数据 dataType: 'json', //配置响应数据格式 --将服务器拿到的json数据类型转换成对象 timeout:'2000', //指定超时的时间 // 成功的回调函数 success: (result, responseText, xhr) =&gt; { //第二个参数 responseText --代表本次响应（成功与否）的文字 第三个参数是xhr console.log(result, responseText, xhr); content.append(`&lt;div&gt;汽车名：${result.name},价格：${result.price}&lt;/div&gt;`) }, // 失败的回调 error: (xhr) =&gt; { //里边可以有 xhr参数 console.log('请求出错了'); } }) // 使用jQyuery发送post请求 携带query参数 --简版写法 // 如果是params请求 /test_jquery_post/bilibili //$.post('http://127.0.0.1:8080/test_jquery_post',{school: '麻省理工学院' },(data)=&gt;{ //console.log(data); //content.append(`&lt;div&gt;汽车名：${data.name},价格：${data.price}&lt;/div&gt;`) //},'json') }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码 // 响应GET请求 --为jQuery准备： 接收query参数 如果是params参数 --'/test_jquery_get/:school' console.log('有人请求test_jquery_get了',request.params); app.get('/test_jquery_get',(request,response)=&gt;{ console.log('有人请求test_jquery_get了',request.query); const car= {name:'马自达.阿特兹',price:'25w'} response.send(JSON.stringify(car)) }) // 响应POST请求 --为jQuery准备： 响应体：request.body app.post('/test_jquery_post',(request,response)=&gt;{ console.log('有人请求test_jquery_post了',request.body); const car= {name:'马自达.阿特兹',price:'25w'} response.send(JSON.stringify(car)) }) 演示回调地狱（了解）新建 ’ 11_演示回调地狱.html ‘ &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;11_演示回调地狱.html&lt;/title&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是：演示回调地狱.html（看代码）&lt;/h3&gt; &lt;h3&gt;需求：点击按钮1之后发送一条请求，成功后发第二条，第二条成功后再发第三条，&lt;/h3&gt; &lt;button id=\"btn1\"&gt;点我发送请求（jQuery-ajax-get）&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; const btn1 = $('#btn1') btn1.click(() =&gt; { // 使用jQyuery发送get请求 携带query参数 --简版写法 $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); },'json') },'json') },'json') }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 跨域问题与同源策略总结：为什么有跨域问题？ 原因是浏览器为了安全，而采用的同源策略。 浏览器中有一个ajax引擎，只要xhr请求必须走ajax引擎，ajax引擎听一个叫同源策略的话，当前后端的端口不同时，浏览器阻止页面收到请求。 什么是同源策略？ 同源策略是由Netscape（网景公司）提出的一个著名安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。 Web是构建同源策略协议基础之上的，浏览器只是针对同源策略的一种实现。 所谓同源是指：协议、域名（IP），端口必须要完全相同。 ​ 即：协议、域名（IP）、端口都相同，才能算是在同一个域里 备注：规则举例如下（假设已有网站地址为：http://study.cn 不写端口号时，http会使用默认的） 请求地址： 形式 结果 http://study.cn/test/a.html 协议、域名、端口均相同 成功 http://study.cn/user/a.html 协议、域名、端口均相同 成功 http://a.study.cn/user/a.html 域名不同 失败 http://study.cn:8080/tset/a.html 域名不同 失败 http://study.cn/user/a.html 协议、域名、端口均相同 成功 https://study.cn/tset/a.html 协议不同 失败 没有同源策略的危险场景：危险场景： ​ 有一天，你刚睡醒，收到一封邮件，说你的银行账号有风险，赶紧点进www.yinghang.com改密码。你着急的赶紧点击进去，还是熟悉的银行登陆界面，你果断输入账号密码后，还没准备看里边的余额，睡眼朦胧的你想起了平时访问的银行网站是 www.yinhang.com,不是现在访问这个。随后你收到短信，钱没了，这个钓鱼网站做了什么呢？ 大概是如下思路： 新建 ’ 12_演示没有同源策略的危险场景.html ‘ &lt;iframe id=\"baidu\" src=\"https://www.baidu.com\"&gt;&lt;/iframe&gt; &lt;script type=\"text/javascript\"&gt; const iframe = window.frames['baidu'] const inputNode = iframe.document.getElementById('输入铭感信息的input的id') console.log(inputNode.value); &lt;/script&gt; 非同源受到哪些限制？ Cookie不能读取； DOM无法获得； Ajax请求不能获取数据； JSONP解决跨域（掌握）JSONP是什么 JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求 同源策略限制了xhr、Cookie、DOM，但是在网页有一些标签具有跨域能力，比如：img, link, iframe, scriptJ。SONP就是利用script标签的跨域能力来发送请求的 新建文件‘13_jsonp解决跨域.html’ 代码如下： 一切的前提是定义了demo()，当点击按钮后创建一个script节点并且src属性为请求的地址，将节点放入页面，最后在给window添加demo方法。 解决的原理是绕开了xhr，借助script标签发请求不收同源策略的限制。有一种前端定义函数，后端调用函数的感觉。 &lt;body&gt; &lt;!-- 这里的jquery可以发送跨域请求 --因为是在script的src下支持跨域 --&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = document.getElementById('btn') btn.onclick = () =&gt; { // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） scriptNode.src = 'http://localhost:8080/test_jsonp' // 3.将节点放入页面 document.body.appendChild(scriptNode) // 4.准备好一个函数 window.demo = (a) =&gt; { console.log(a); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应get请求 --为jsonp跨域准备 app.get('/test_jsonp',(request,response)=&gt;{ const person = {name:'tpm',age:18} // 想将一个对象变成字符有两种方式： // 1、toString() 方法 但是人类一般接受不了 --demo([object object]) // 2、JSON.stringify() 方法 response.send(`demo(${JSON.stringify(person)})`) }) 完善JSONP优化： 1、 假如前端的函数名更改了，后端也要更改一次就很麻烦 –需要优化写法 2、前边每次点击按钮都会动态创建了一个script标签 –需要移除已经使用过的script节点 页面代码： &lt;body&gt; &lt;!-- 这里的jquery可以发送跨域请求 --因为是在script的src下支持跨域 --&gt; &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，用jsonp解决问题&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = document.getElementById('btn') btn.onclick = () =&gt; { // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） 这里的key使用callback命名是因为前端请求，后端返回的数据是一段可以执行的js代码，这段代码触发了peiqi函数的调用 scriptNode.src = 'http://localhost:8080/test_jsonp?callback=peiqi' // 3.将节点放入页面 document.body.appendChild(scriptNode) // 4.准备好一个函数 window.peiqi = (a) =&gt; { console.log(a); } // 5.（优化）移除已经使用过的script节点 document.body.removeChild(scriptNode) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应get请求 --为jsonp跨域准备 app.get('/test_jsonp',(request,response)=&gt;{ const {callback} = request.query const person = [{name:'tpm',age:18},{name:'jery',age:'16'}] // 这样写的优势是前端的函数名随便更改，后端这里不需要改 response.send(`${callback}(${JSON.stringify(person)})`) }) JSONP面试问题：JSON 和 JSONP有关系吗？有一定关系，但是他俩是两回事儿。JSON是一种存储和交互的一种格式，JSONP是后端一种解决跨域的方式。他俩的关系是因为后端返回数据的时候，必须将数据变为JSON字符串。 用JSONP去解决跨域也是用到了xhr对吗？不对，JSONP解决跨域根本没用到xhr JSONP解决跨域有什么缺点？后端需要配合前端去拿到callback函数名，后端需要配合前端将数据变成JSON格式，后端需要配合前端写成函数调用的形式，简单来说前后端都挺麻烦。 jQuery封装的JSONP（了解）用jQuery去发送一个JSONP请求： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;14_jQuery封装的JSONP.html&lt;/title&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，用jQuery封装的JSONP解决&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = $('#btn') btn.click(()=&gt;{ $.getJSON('http://localhost:8080/test_jsonp?callback=?',{},(data)=&gt;{ console.log(data); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CORS （后端技术）解决跨域（掌握）CORS 是什么？​ CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 怎么工作的？​ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。 CORS 的使用新建 ‘ 15_测试cors解决跨域.html ’文件 代码如下： // ... &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，测试cors解决跨域&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); console.log(xhr.getAllResponseHeaders()); } } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ​ 主要是服务端的设置： // 3.响应GET请求 -可以接收query 参数 request,response --请求、响应对象 app.get('/test_get',(request,response)=&gt;{ console.log('有人请求test_get了--携带的query参数是：',request.query); response.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500') // 只允许这个 http://127.0.0.1:5500 网站进行跨域请求 response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 // response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 // 这里设置一句话，检查是否有人请求了 response.send('hello_test_get!!!') }) 发送 put 请求新建文件 ‘16_ajax_put请求.html’ 文件代码为： // ... &lt;h3&gt;该页面是测试：ajax_put请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的PUT请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } xhr.open('PUT','http://127.0.0.1:8080/test_put') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应 put请求 app.put('/test_put',(request,response) =&gt; { response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.send('hello_tset_put') }) 假如此时使用 open with live serve打开文件，将会显示跨域问题，即仅仅如上设置服务端是没有解决 put请求的跨域问题 –(预请求失败) 因为get、put属于http里的简单请求，不存在嗅探请求（也叫预请求 –在请求真正发出之前要进行一个预请求的动作 预解析 –在代码真正执行之前有人扫了一遍代码），put和delete有预请求这种嗅探请求。同时复杂请求可以检查服务器的性能，使用HTTP的OPTIONS方法，因此目前服务端没有写这个方法就会失败。所以可以在服务端的put请求之前再写一个options请求 // 预请求的方式 app.options('/test_put',(request,response)=&gt;{ response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Methods','*') // 预请求 这里代表哪些请求可以跨域 '*'代表任何请求都可以 response.send('我性能很好') }) // 响应 put请求 app.put('/test_put',(request,response) =&gt; { response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.send('hello_tset_put') }) 总结：掌握的需要掌握，了解的需要了解","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"Vuex学习","slug":"12-Vuex学习","date":"2022-05-26T07:00:00.000Z","updated":"2022-06-16T03:36:01.192Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://wuzimo233.github.io/posts/13.html","excerpt":"","text":"Vuex学习1、Vuex是什么？1.介绍 ​ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 2.说明： ​ Vuex是vue组件之间数据传递的方式，任意组件都可以使用-类似大仓库 一般来说某个组件要用数据，可以调用Render读取Vuex中的数据，然后使用Dispatch调用Actions修改页面的数据，当然还有许多其他步骤，这只是最经典的动作（先读再操作）。Actions操作后会利用中间转接人Mutations去修改State， 2、安装Vuex 安装： cnpm install vuex --save 目前默认安装的是Vue3的vuex4版本，vue2需要安装指定版本，我使用的npm i vuex@3.6.2 main.js 全局引入 import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) ​ 3.创建store仓库​ 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state) ​ Vuex 和单纯的全局对象有以下两点不同： ​ 1. Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 ​ 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation 最简单的 Store import Vue from 'vue' import App from './App.vue' import router from './router' // 1.引入Vuex import Vuex from 'vuex' Vue.config.productionTip = false // 2.使用Vuex Vue.use(Vuex) // 3.创建Vuex仓库 const store = new Vuex.Store({ // 4.共享的数据 state:{ user:'admin', } }) new Vue({ router, // 5.仓库放到（挂载）Vue实例上去 store, render: h =&gt; h(App) }).$mount('#app') 3、Vuex核心概念State1.介绍：​ 1. Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。 ​ 2.说明：state就是存储数据仓库 容器 2.获取state数据1、this 直接获取​ this.$store.state.xxx ​ 假如某个组件想获取刚才定义在Vuex中store仓库里state中的user数据，就可以通过this下的$store来找到 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', created(){ console.log(this); console.log(this.$store.state.user); //'admin' } } &lt;/script&gt; 2、mapState 辅助函数获取了解三个使用方式：三个辅助函数使用方法，不必掌握因为比较麻烦且不能复用计算属性 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; &lt;p&gt;mapState辅助函数 箭头函数 写法获取state数据：{{ user1 }}&lt;/p&gt; &lt;p&gt;mapState辅助函数 字符串 写法获取state数据：{{ user2 }}&lt;/p&gt; &lt;p&gt;mapState辅助函数 普通函数方法 写法获取state数据：{{ user3 }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.导入辅助函数 import { mapState } from 'vuex' export default { name: 'Home', data(){ return { msg:'你好', } }, // 2.使用计算属性获取state方法---了解 computed:mapState({ // 方式1、箭头函数写法（代码更简练） user1:state=&gt;state.user, // 方式2、传字符串参数 'count' 等同于 `state =&gt; state.count` user2:'user', // 方式3、为了能够使用 `this` 获取局部状态，必须使用常规函数 user3(state) { return state.user+'----'+this.msg; } }), } &lt;/script&gt; 需要掌握的使用方式：&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; // 4.直接使用 &lt;p&gt;mapState辅助函数 字符串数组写法 获取state数据：{{ user }}--{{ count }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.导入辅助函数 import { mapState } from 'vuex' export default { name: 'Home', data(){ return { msg:'你好', } }, // 2.使用计算属性获取state方法---掌握 computed:{ //3.mapState 传一个字符串数组方法 ——名称要和vuex仓库里的数据名一致 因为是数据所以放在计算属性里 注意别和data里数据名重复 ...mapState(['user','count',]), }, } &lt;/script&gt; 当然直接把vuex放到main.js中不合适，可以单独在项目根下创建一个叫做store文件夹，里面创建一个index.js的文件 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 5.共享的数据 state:{ user:'admin', count:100, } }) // 6.导出 export default store 最后再在main.js中导入引入store import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ //路由挂载到vue实例 router, // 仓库放到（挂载到）Vue实例 store, render: h =&gt; h(App) }).$mount('#app') Mutations1.介绍​ 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation​ Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 2.语法4-2 处定义一个mutations对象，里面包含想修改state数据的方法 mutations里的方法有两个参数，比如 addCount(state,payload) –其中state是固定的state数据，payload是要携带的参数可以省略(参数可以是对象、字符串、数字) 无参数版 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{ user:'admin', count:100, }, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{ addCount(state){ state.count ++ }, reduceCount(state) { state.count -= 10 } }, }) // 5.导出 export default store 有参数版 mutations:{ addCount(state,num){ //增加了一个参数需要在使用的组件里添加具体参数 state.count += num }, reduceCount(state,{num}) { state.count -= num } }, }) --------------------------------------以下是其他组件需要使用muaations时携带参数的方法----------------------------------------------- &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', methods:{ add(){ // 使用commit()方法调用mutations里的方法去修改state数据 同时将参数10代入 this.$store.commit('addCount',10) //即当前每次点击增加10 }, reduce(){ this.$store.commit('reduceCount',{ num:8 }) } }, } &lt;/script&gt; 3.操作方法：1、直接操作mutations直接使用commit()方法调用mutations里的方法去修改state数据 在需要修改的组件里使用 this.$store.commit(state,payload) –state是定义在mutations里的方法名，payload是参数需要看mutations里的方法是否可以省略 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', methods:{ add(){ // 注意：不能直接修改 仓库不会同步视图 // this.$store.state.count = 200 // 使用commit()方法调用mutations里的方法去修改state数据 this.$store.commit('addCount',) }, reduce(){ this.$store.commit('reduceCount',) } }, } &lt;/script&gt; 2、辅助函数操作&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add2\"&gt;辅助函数+&lt;/button&gt; &lt;button @click=\"reduce2\"&gt;辅助函数-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.引入辅助函数 import { mapMutations } from 'vuex' export default { name: 'Home', methods:{ // 2.mapMutations 是方法所以放在methods里 ...mapMutations(['addCount','reduceCount']), add2(){ // 3.操作辅助函数 this.addCount(20) }, reduce2(){ this.reduceCount({ num:20 }) } }, } &lt;/script&gt; 3、Mutation 必须是同步函数一条重要的原则就是要记住 mutation 必须是同步函数 4、 Mutation 需遵守 Vue 的响应规则 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 1. 最好提前在你的 store 中初始化好所有所需属性。 1. 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, ‘newProp’, 123), 或者 以新对象替换老对象。例如，利用对象展开运算符 (opens new window)我们可以这样写： state.obj = { …state.obj, newProp: 123 } mutations:{ addCount(state,num){ state.count += num }, reduceCount(state,{num}) { state.count -= num }, // 修改已经存在的属性 changeUserinfo(state,payload){ state.userinfo.uname = payload.uname }, // 添加数据 addUserinfo(state,payload){ // 直接增加属性 数据会修改 但是视图不同步 // state.userinfo.love = payload.love; // 解决方式： // 1.提前定义好属性 // 2.Vue.set(obj,'属性','值') // 3.{...} // 4.Object.assign() Vue.set(state.userinfo,'love',payload.love) } }, 组件中使用： 当添加一个没有存在的属性 state会添加成功但是页面不会显示，因为对象里的属性地址是没有改变的vue检测不到 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;p&gt;获取userinfo数据:{{userinfo}}&lt;/p&gt; &lt;button @click=\"addobj\"&gt;对象添加一个不存在的属性&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState } from \"vuex\" export default ({ computed:{ ...mapState(['userinfo']) }, methods:{ change(){ // 直接修改state数据 this.$store.commit('changeUserinfo',{ uname:'zimo' }) }, // 当添加一个没有存在的属性 state会添加成功但是页面不会显示，因为对象里的属性地址是没有改变的vue检测不到 addobj(){ this.$store.commit('addUserinfo',{ love:'擦擦擦' }) } } }) &lt;/script&gt; 5、 使用常量替代 Mutation 事件类型使用常量替代 mutation中 事件类型（即方法的名称）在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 首先在store下新建js文件，里边写一个对象暴露出去 /* * 定义mutations事件类型：函数名称 定义常量 */ export const ADDCOUNT = 'ADDCOUNT'; 在需要用到mutations的组件里这样使用 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;button @click=\"add2\"&gt;辅助函数+&lt;/button&gt; &lt;button @click=\"reduce2\"&gt;辅助函数-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 辅助函数 import { mapState,mapMutations } from 'vuex' //1. 导入常量js import { ADDCOUNT, } from '../store/mutation-types.js' export default { name: 'Home', computed:{ ...mapState(['user','count',]), }, methods:{ // 2.辅助函数里也改成定义的常量名 ...mapMutations([ADDCOUNT,'reduceCount']), add(){ // 3.使用commit()方法调用mutations里的方法也要改为常量名 this.$store.commit(ADDCOUNT,10) }, reduce(){ this.$store.commit('reduceCount',{ num:8 }) }, add2(){ //4. 其他直接使用辅助函数＋的地方也改为常量名 this.ADDCOUNT(20) }, reduce2(){ this.reduceCount({ num:20 }) } }, } &lt;/script&gt; Action1、介绍​ Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 2、例子注册一个简单的 action： action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) 3、操作Action1.直接获取actionsthis.$store.dispatch('actions里的函数名') 2.辅助函数获取actions// 1.引入mapActions辅助函数 import { mapActions } from 'vuex' export default { // ... //2.在方法里面调用 methods: { ...mapActions(['increment']), add() { //3.使用辅助函数里的方法 this.increment(100) } } } 4、实际上手练习1.定义actions对象首先在vuex文件下定义actions对象（4-3），准备一个异步函数，第一个参数context与 store 实例具有相同方法和属性，第二个参数是因为mutstions里减法函数需要一个对象参数num，使用context.commit()方法，第一个参数是mutations里的方法名称，第二个参数是接收上边传递的参数 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{ count:100, }, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{ reduceCount(state,{num}) { state.count -= num }, }, // 4-3. actions操作异步 执行mutations actions:{ // 定义函数-异步 asyncReduceCount(context,payload) { //模拟异步请求 5秒后操作上面的mutations里的减法函数 reduceCount setTimeout(()=&gt;{ context.commit('reduceCount',payload) },2000) } } }) // 5.导出 export default store 2.在组件上使用1、组件里直接调用actions 使用this.$store.dispatch（'想要调用的actions里的方法名称',’需要传递的num值‘） &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h3&gt;操作actions&lt;/h3&gt; &lt;p&gt;vuex-count:{{$store.state.count}}&lt;/p&gt; &lt;button @click=\"jian\"&gt;actions 直接调用&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default ({ methods:{ jian(){ this.$store.dispatch('asyncReduceCount',{ num:10 }); } } }) &lt;/script&gt; 2、组件里使用辅助函数方法调用actions 例子1 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h3&gt;操作actions&lt;/h3&gt; &lt;p&gt;vuex-count:{{$store.state.count}}&lt;/p&gt; &lt;button @click=\"jian2\"&gt;actions 辅助函数调用&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {mapActions } from \"vuex\" export default ({ methods:{ ...mapActions(['asyncReduceCount']), jian(){ //直接调用actions this.$store.dispatch('asyncReduceCount',{ num:10 }); }, jian2(){ // 辅助函数方法调用actions this.asyncReduceCount({num:20}) } } }) &lt;/script&gt; 例子2 组件获取state里的用户名 安装一下axios cnpm i axios - S 然后在vuex文件下store仓库的代码如下 const store = new Vuex.Store({ state:{ //1.定义一个空的用户名 user:'', }, mutations:{ // 2.定义一个修改state的user函数 changeUser(state,uname){ state.user = uname }, }, actions:{ // 3.定义一个异步请求--用户名的函数 getUser(context){ axios.get('http://iwenwiki.com/api/blueberrypai/getIndexBanner.php') .then(res =&gt; { console.log(res.data.banner[0].title); // 4.数据获取成功后，解析出来想要的数据格式 --再利用mutations来修改状态state // 5.操作-mutations可以使用contxet.commit('要操作的方法名','其他参数')来修改用户名 context.commit('changeUser',res.data.banner[0].title) }) } } }) 在组件里的代码如下 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;p&gt;用户名:{{user}}&lt;/p&gt; &lt;button @click=\"getUser1\"&gt;获取用户名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapActions } from \"vuex\" export default ({ computed:{ ...mapState(['userinfo','user']) }, methods:{ ...mapActions(['asyncReduceCount','getUser']), getUser1(){ this.getUser() }, } }) &lt;/script&gt; Getter1、介绍​ Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。对数据缓存和过滤处理。 2、如何访问1.直接获取getters​ this.$store.getters.属性 2.辅助函数访问import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount','anotherGetter']) } } 3、例子const store = new Vuex.Store({ state:{ user:'', }, mutations:{ }, actions:{ }, getters:{ userName:state=&gt;{ return state.user +'vip用户' } } }) 其他组件使用 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h4&gt;getters使用&lt;/h4&gt; &lt;p&gt;用户名:{{user}}&lt;/p&gt; &lt;p&gt;新的用户名直接读取：{{$store.getters.userName}}&lt;/p&gt; &lt;p&gt;新的用户名辅助函数读取：{{userName}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //1. 导入辅助函数 import { mapState,mapActions,mapGetters } from \"vuex\" export default ({ // 2.计算属性中使用辅助函数 computed:{ ...mapState(['userinfo','user']), ...mapGetters(['userName']) }, }) &lt;/script&gt; 总结1、vuex仓库数据 state getters1.state 获取：​ 1、直接获取 ​ this.$store.state.xx ​ 2、辅助函数获取 //引入辅助函数... import { mapState } from \"vuex\" computed:{ ...mapState(['','',...]) } 2.getters获取:​ 1、直接获取​ this.$store.getters.xx ​ 2、辅助函数获取 //引入辅助函数... import { mapGetters } from \"vuex\" computed:{ ...mapGetters(['','',...]) } 2、操作修改state –mutations actions1.mutations操作​ 1、直接获取​ this.$store.commit(‘函数名字’,’参数’) ​ 2、辅助函数获取 //引入辅助函数... import { mapMutations } from \"vuex\" computed:{ ...mapMutations(['','',...]) } 2.actions操作​ 1、直接获取​ this.$store.dispatch(‘函数名字’,’参数’) ​ 2、辅助函数获取 //引入辅助函数... import { mapActions } from \"vuex\" computed:{ ...mapActions(['','',...]) } Modules1、介绍：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块 简单来说store还有一个modules属性对象里面可以单独存储入：用户信息、城市数据、购物车数据、搜索数据等等 2、命名空间:​ 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。 3、modules的使用：4-5 处写一个modules对象，添加一个模块名称的属性对象，里面可以包含state，mutations，actions，getters // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' import { ADDCOUNT } from './mutation-types.js' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{}, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{}, // 4-3. actions操作异步 执行mutations actions:{}, // 4-4. getters 处理state数据进行加工 getters:{}, // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:{ // 开启了命名空间 让actions mutations getters的作用域是当前的模块下而不是挂载到全局 namespaced:true, state:{ cityName:'成都', }, mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 也可以写成这种格式 getCity({commit},city) getCity(context,city){ context.commit('changeCity',city) } } }, } }) // 5.导出 export default store 在需要用到的模块组件下使用： &lt;template&gt; &lt;div&gt; &lt;h2&gt;城市模块的使用&lt;/h2&gt; &lt;h4&gt;state&lt;/h4&gt; &lt;p&gt;当前城市--直接读取：{{this.$store.state.cityModule.cityName}}&lt;/p&gt; &lt;p&gt;当前城市--辅助函数读取：{{cityName}}&lt;/p&gt; &lt;h4&gt;mutations&lt;/h4&gt; &lt;button @click=\"getCity1\"&gt;修改城市城名&lt;/button&gt; &lt;button @click=\"getCity2\"&gt;辅助函数修改城市城名&lt;/button&gt; &lt;h4&gt;actions&lt;/h4&gt; &lt;button @click=\"updateCity1\"&gt;actions-修改城市城名&lt;/button&gt; &lt;button @click=\"updateCity2\"&gt;actions-辅助函数修改城市城名&lt;/button&gt; &lt;h4&gt;getters&lt;/h4&gt; &lt;!-- getters这里不能直接打点调用下面的方法，而是用中括号加引号 --&gt; &lt;p&gt;getters--获取数据：cityVal:{{this.$store.getters['cityModule/cityVal']}}&lt;/p&gt; &lt;p&gt;getters--辅助函数获取数据：cityVal:{{this.cityVal}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapMutations,mapActions,mapGetters } from 'vuex' export default { methods:{ ...mapMutations('cityModule',['changeCity']), ...mapActions('cityModule',['getCity']), getCity1(){ // 1、直接获取模块下的mutations this.$store.commit('cityModule/changeCity','南京') }, getCity2(){ // 2、辅助函数获取模块下的mutations下的changeCity方法 this.changeCity('南京') }, updateCity1(){ //1、直接使用actions模块下的getCity方法 this.$store.dispatch('cityModule/getCity','北京') }, updateCity2(){ // 2、辅助函数获取模块下的actions的getCity this.getCity('北京') } }, computed:{ // ...mapState('模块名称',['模块里的变量']) ...mapState('cityModule',['cityName']), ...mapGetters('cityModule',['cityVal']) } } &lt;/script&gt; 4、带命名空间的模块内访问全局内容1.在getter对象里的四个参数如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:{ // 开启了命名空间 让actions mutations getters的作用域是当前的模块下而不是挂载到全局 namespaced:true, state:{ cityName:'成都', }, getters:{ cityVal:state=&gt;{ return state.cityName + '好去处' }, // getGlobalCity方法 --getter数据处理的时候，获取全局的getters state数据 getGlobalCity(state,getters,rootState,rootGetters){ // state 获取当前模块的状态-state // getters 获取当前模块的所有的getterrs // rootState 获取根上的state数据 可以获取其他模块的数据 // rootGetters 获取根上所有的getters 全局的和所有模块的getters console.log(state,getters,rootState,rootGetters); } }, mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 也可以写成这种格式 getCity({commit},city) getCity(context,city){ context.commit('changeCity',city) }, // 注意：局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 ！ getGlobalCityAction(context){ console.log(context); } } }, } 组件中使用 如下， // 同时局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 &lt;template&gt; &lt;div&gt; &lt;h4&gt;模块内访问全局的数据state getters&lt;/h4&gt; &lt;button @click=\"getGetters\" &gt;访问getters&lt;/button&gt; &lt;button @click=\"getGlobalCityAction1\" &gt;访问局部模块的context对象&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapMutations,mapActions,mapGetters } from 'vuex' export default { methods:{ ...mapMutations('cityModule',['changeCity']), ...mapActions('cityModule',['getCity','getGlobalCityAction']), getGetters(){ // console.log(this.getGlobalCity); this.getGlobalCity }, getGlobalCityAction1(){ this.getGlobalCityAction() } }, computed:{ // ...mapState('模块名称',['模块里的变量']) ...mapState('cityModule',['cityName']), ...mapGetters('cityModule',['cityVal','getGlobalCity']) } } &lt;/script&gt; 2.{ root: true } 第三参数需要在全局命名空间内分发 (触发) action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可 actions方法接收一个context对象，使用context.commit()方法能操作mutation，第一个参数是mutations里的方法名称，第二个参数是接收上边传递的参数,所以当第三个参数是{ root: true } 的时候，将可以访问到全局下的mutation，同理dispatch下能访问到全局下的action里的xx方法 解释：就是在命名的模块内想要访问全局的actions或者mutaitons里面的函数 语法：actions里面: context.commit(‘changeUser’,null,{root:true}) 例如：在命名的模块下，如果对象想访问全局的actions 或者是全局的mutations 都是可以的 // modules 模块 分类存储很多信息 modules:{ mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 // context对象里面包含了={dispatch:'',commit:'',state:'',getters:'',rootState:'',rootGetters:''} getGlobalCityAction(context){ console.log(context); // 如果对象想访问全局的actions 或者是全局的mutations 都是可以的 这里访问全局的mutations方法修改全局state数据 context.commit('changeUser','局部修改全局的user',{root:true}) } } }, ！！注意：1、commitactions里的方法能够使用commit去调用mutations里的方法， actions方法接收一个context对象，使用context.commit()方法能操作mutation，第一个参数是mutation里的方法名称，第二个参数是接收上边传递的参数, 2、dispatch能够使用dispatch调用action里面的方法 项目结构1、规则虽然vuex设计并不限制你的代码结构，但是，它规定了一些需要遵守的规则： ​ a: 应用层级的状态应该集中到单个 store 对象中。（所有的数据都要在 new Vuex.Store中）​ b: 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。（想改state数据只能通过mutation的方法去修改）​ c: 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。 2、项目结构实例通过上方的学习后会发现vuex文件已经有一百多行代码，看起来较为麻烦。vuex设计了只需将 action、mutation 和 getter 分割到单独的文件。 项目结构示例 └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 在store文件夹下新建state 、mutations 、actions 、getterrs 后辍为.js的文件，模块文件需要单独在store下新建modules文件夹放入各个 模块名.js,然后将原store里的代码移动过去，并暴露出来，重新将项目分割后如下: // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 拆分后：引入state mutations actions getterrs 和命名空间模块cityModule、loginModule import state from './state' import mutations from './mutations' import actions from './actions' import getters from './getters' import cityModule from './modules/cityModule' import loginModule from './modules/loginModule' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:state, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:mutations, // 4-3. actions操作异步 执行mutations actions:actions, // 4-4. getters 处理state数据进行加工 getters:getters, // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:cityModule, // 2、例：存用户的数据 loginModule:loginModule, } }) // 5.导出 export default store","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wuzimo233.github.io/tags/Vuex/"}]},{"title":"Uni-app学习","slug":"11-Uni-app学习","date":"2022-05-04T15:17:00.000Z","updated":"2022-06-16T03:35:57.945Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://wuzimo233.github.io/posts/12.html","excerpt":"","text":"前置条件 有vue基础 什么是uni-app uni-app 是DCloud公司打造的一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。 HTML结构(简单了解) View容器–类似于div text文本–包裹文本 swiper–轮播图 img–图片 video–视频 button–按钮 CSS样式 属性 字体 大小 布局：float 选择器 class 取值与单位 px color rpx 自动根据屏幕大小比例进行适配 盒子模型 margin:外边距 padding:内边距 border:边框 弹性盒子模型 更好的布局","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wuzimo233.github.io/tags/uni-app/"}]},{"title":"Vue-图书管理案例","slug":"10-Vue图书管理案例","date":"2022-04-26T04:00:00.000Z","updated":"2022-06-16T03:35:50.634Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://wuzimo233.github.io/posts/11.html","excerpt":"","text":"前置条件 安装Visual Studio Code（代码编辑器） 电脑已安装node.js 配置好vue相关文件 开始构建 电脑任意位置新建文件夹命名为”Vue-图书管理” 新建文件index.html 并创建基本html结构 因为是局部使用vue ，需要cdn方式引入Vue &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; 开始 new vue实例 并赋值为vm，在其内部构建 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ }, methods:{ } }) &lt;/script&gt; 将data里放入图书的数组数据 data:{ books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"20512\", }, { id: 4, name: \"西游记\", price: \"212\", }, ], }, 布局基本html样式 &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\"&gt;编辑&lt;/a&gt; | &lt;a href=\"\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 增加添加图书功能 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ obj:{ id:'', name:'', price:'', }, newobj:'', num:'', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ submit(){ // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.o // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newob // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, } }) &lt;/script&gt; 编辑图书功能 &lt;body&gt; &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\" :disabled=\"isDisabled\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\" :disabled=\"noSubmit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"##\" @click.prevent=\"editor(index)\"&gt;编辑&lt;/a&gt; | &lt;a href=\"##\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip= false; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ noSubmit:false, //禁止提交按钮的状态 isDisabled:false, //默认可以点击 indexData:'', //存储index标识 obj:{ id:'', name:'', price:'', }, newobj:'', num:'2', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ // 提交按钮 submit(){ // 判断是否是提交新数据还是修改旧数据 if(this.isDisabled) { //编辑功能: // 方法 1： 获取index 找操作的行元素 修改它 // console.log('编辑'); // console.log('编辑的当前行',this.books[this.indexData]); // this.books[this.indexData].name = this.obj.name // this.books[this.indexData].price = this.obj.price // 方法 2： 找id 获取编辑的id == books里面的id // 使用方法 some 查找原数组里是否有某元素 如果有返回true // ele 可以获取books数组的每一项 this.books.some( (ele) =&gt; { if( ele.id == this.obj.id){ //这个ele就是编辑的数据 ele.name = this.obj.name ele.price = this.obj.price return true } }) // 释放禁止按钮 this.isDisabled = false; }else { //添加功能 // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.obj // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newobj) } // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, // 编辑按钮 editor(index){ //1 获取当前行的数据 渲染到文本框中 console.log(this.books[index]); // this.obj.id = this.books[index].id // this.obj.name = this.books[index].name // this.obj.price = this.books[index].price this.obj = this.books[index] // 2. 编辑的时候--编号禁止操作 this.isDisabled = true; // 3. 存储index下标---目的：提交的时候 修改的是哪个数据用 this.indexData = index; } }, //侦听器 watch:{ \"obj.name\":function(val){ console.log('监听了数据变化',val); var flag = this.books.some(ele =&gt; { return ele.name == val }) if(flag) { this.noSubmit = true alert('已经存在相同名称书籍') } else { this.noSubmit = false } } } }) &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"}]},{"title":"Vue路由拦截","slug":"09-Vue登录拦截案例","date":"2022-04-20T17:28:00.000Z","updated":"2022-06-16T03:35:46.873Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://wuzimo233.github.io/posts/9.html","excerpt":"","text":"路由拦截案例：从零开始创建一个新的项目安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve 配置路由组件 配置路由组件 – login登录界面 layout-布局界面（首页-新闻-我的） 简单说就是 layout组件里包含首页、新闻、我的 等界面，而在login组件里包含登录，且login和layout是平级的关系 删除HomeView.vue里的默认信息改名为Home，添加 首页 AboutView.vue组件改名About，里面 h1信息This is an about page改为 我的 添加News.vue组件，添加h1新闻界面 在views下新建Login组件，添加h1登录界面 在views下新建Layout组件 配置路由router下的index.js","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"}]},{"title":"TEST","slug":"test","date":"2022-04-20T08:15:00.000Z","updated":"2022-04-20T17:27:34.667Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://wuzimo233.github.io/posts/10.html","excerpt":"","text":"使用hexo发布文章遇到的问题使用两个花括号报错","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"JS进阶学习","slug":"08-JS进阶学习","date":"2022-04-18T13:53:00.000Z","updated":"2022-06-16T03:35:43.223Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://wuzimo233.github.io/posts/8.html","excerpt":"","text":"ES6高级待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue进阶知识学习","slug":"06-Vue进阶学习","date":"2022-04-18T13:42:00.000Z","updated":"2022-06-16T03:35:35.680Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://wuzimo233.github.io/posts/6.html","excerpt":"","text":"该页面假设你已经阅读过了组件基础。如果你还对组件不太了解，推荐你先阅读它。 注册局部组件 创建一个组件Mycomp.vue 在需要用到的地方引入：import Mycomp from './components/Mycomp.vue' 注册组件export default { name: 'App', components: { Mycomp } } 使用组件在 template &lt;Mycomp&gt;&lt;/Mycomp&gt; 组件组成 template 视图 script 逻辑 style 样式 全局组件 注册全局组件 在Vue对象身上有个Vue.component() 注册全局组件 在所有的组件中 不需要引入 可以直接使用 语法：Vue.component(‘my-component-name’, { // ... 选项 ... }) 代码演示 // import Vue from 'vue'//运行时：vue.runtime.js import Vue from 'vue/dist/vue' /注册全局组件(放到main.js) // Vue.component('组件名称',{内容配置}) Vue.component('my-comp',{ //视图 template :template作为属性使用 必须vue.js （完整版的vue.js） 默认引入-运行时-vue.runtime.js template:'&lt;div&gt; &lt;h2&gt;我是一个全局组件&lt;/h2&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/div&gt;', //数据 data(){ return { msg:'hello vue全局组件' } }, //方法 methods:{ } }) 全局组件–可以挂载创建好的局部组件 注册全局import MyBanner from ‘./components/MyBanner.vue’// Vue.component(‘MyBanner’,MyBanner)Vue.component(MyBanner.name,MyBanner) 组件中的data为什么是函数答案避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。 computed和watch的区别action 与 mutation 的区别 mutation 是同步更新， $watch 严格模式下会报错 action 是异步操作，可以获取数据后调用 mutation 提交最终数据 Vue 组件通讯有哪几种方式父传子通过props传递父亲提供数据通过属性 props传给儿子；儿子通过 $on 绑父亲的事件，再通过 $emit 触发自己的事件（发布订阅）利用父子关系 $parent 、 $children 子传父在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。父组件： &lt;child @receive = ‘receive’ /&gt;子组件: this.$emit(‘receive’,’传递的数据’) 兄弟组件传值通过中央通信 let bus = new Vue()prop 验证，和默认值 v-for 为什么要加 keyv-model 原理怎样理解 Vue 的单向数据流Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。 虚拟 DOM 是什么 有什么优缺点 谈一下对 vuex 的个人理解vuex是什么Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 怎么使用vuexvuex中有几个核心属性，分别是什么？ 一共有5个核心属性，分别是: state 唯一数据源,Vue 实例中的 data 遵循相同的规则 getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值. mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发 action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作 module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。 路由页面管理（vue-router）什么是vue-router怎么使用vue-router怎么定义vue-router的动态路由？怎么获取传过来的动态参数？vue-router 路由钩子函数是什么 执行顺序是什么路由拦截方法待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"}]},{"title":"JS基础知识","slug":"07-JS基础学习","date":"2022-04-17T17:00:00.000Z","updated":"2022-06-16T03:35:39.267Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://wuzimo233.github.io/posts/7.html","excerpt":"","text":"JavaScript基础知识点了解 JavaScriptJavaScript是什么 JavaScript是一种运行在客户端（浏览器）高级的、解释型的编程语言的，实现人机交互效果 由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持 JavaScript乍一听与Java在名字上相似，但其实是雷锋与雷锋塔、老婆和老婆饼的关系hhh 一般简称JS，以下都以JS称呼 JS的作用（做什么） 网页特效 （监听用户的一些行为让网页做出对应的反馈） 表单验证 （针对表单数据的合法性进行判断） 数据交互 （获取后台的数据，渲染到前端页面） 服务端编程（node.js） JS的组成（有什么）JS 是由ECMAScript和WebApi 组成。WebApi又由DOM（页面文档对象模型）和BOM（浏览器对象模型）构成 ECMAScript是由网景的布兰登·艾克开发的一种脚本语言的标准化规范；最初命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript[1]。 DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作 Bom 操作浏览器，比如页面弹窗，检测窗口宽度，存储数据到浏览器等 JS的位置内部引入 直接在HTML文件中引入（一般在标签的底部使用）&lt;script&gt; alert('我是内部引入的JS') &lt;/script&gt; 外部引入 是指将JS文件外置在HTML文件的外部，在head标签内引入相对路径中的JS文件 使代码更加有序，易于复用，且没有了脚本的混合，HTML也会更加易读&lt;head&gt; &lt;script src=\"./my.js\"&gt;&lt;/script&gt; &lt;/head&gt; 内联使用 在标签内部使用&lt;button onclick=\"alert('我是内联JS')\"&gt;我是按钮&lt;/button&gt; JS注释 单行注释 // xxx 多行注释 /* xxx */ 字面量 了解什么是字面量前，先知道什么是语法？ 是人和计算机打交道的规则—我们按照这个规则去敲代码 比如输入语法：document.write('输出的文字-文字展示到页面') document.write('&lt;h1&gt;我是嵌套的h1标签&lt;/h1&gt;') alert('要输出的内容-弹框形式展示到页面') console.log('控制台打印的内容') 在计算机科学中，字面量（literal）是在计算机中描述 事/物比如: 初级前端开发薪水是：8k 此时8k就是数字字面量 ‘hello world’ ：这是字符串字面量 还有其他数组字面量、对象字面量 变量变量是什么？ 通俗来讲：变量是计算机存储数据的“容器” 白话：变量就是一个装东西的盒子 变量不是数据本身，它们仅仅是一个用于存储数值的容器，可以理解为是一个个用来装东西的盒子~例如：用户在网页输入自己姓名或者电话等信息时候，就是通过变量存储。 变量的声明方式在JS中创建变量被称为声明变量，JS中变量声明又分为显示声明和隐式声明。其中显示声明中，声明关键字有var、let、const、function、class、import let 变量名 语法：声明关键字 + 变量名 let 即关键字（let：允许、让、要），所谓关键字是系统提供的专门用来声明（定义）变量的词语 注意let不能多次声明一个变量名 可以一次声明多个变量 let age=18,name=’zimo’;// 声明关键字 + 变量名 let age; age = 18; // 变量声明后一般会赋值 也可以连写let age = 18; age = 19; // 变量可以更新值 document.write(age); 案例：用户输入姓名后，页面显示刚才用户输入的姓名&lt;script&gt; let name = (prompt('请输入您的姓名')) document.write(name) &lt;/script&gt; 案例：交换变量的值需求：2个不同变量的变量去交换其值。&lt;script&gt; let num1 = 10 let num2 = 20 let num3 = '' num3 = num1 num1 = num2 num2 = num3 console.log(num1,num2); &lt;/script&gt; 变量本质先了解一下内存：是计算机存储数据的地方，相当于一个空间变量：是程序在内存中申请的一块用来存放数据的小空间 变量的命名规则与规范 不能用关键字比如：let var if for等 只能使用下划线、字母、数字、$组成，且数字不能开头 字母严格区分大小写 起名要有意义 遵守小驼峰命名法 （第一个单词首字母小写，后面每个单词首字母大写，如：UserName） 拓展 let 与 var 区别 let为了解决var的一些问题 var可以先使用 在声明（不合理） var声明过的变量可以重复声明（不合理） 比如变量提升、全局变量、没有块级作用域等等","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue基础知识学习","slug":"05-Vue基础学习","date":"2022-04-17T11:47:00.000Z","updated":"2022-06-16T03:35:29.705Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://wuzimo233.github.io/posts/5.html","excerpt":"","text":"Vue的安装安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve Vue介绍 Vue是渐进式（渐进式：项目中可以逐步使用vue框架 可以使用一部分 或者是整个项目） JavaScript 框架 框架为单页面的应用程序 （Vue项目入口：只有一个页面 index.html ） 跳转的页面路由功能- 路由 （其他页面组件） 框架里面使用的是虚拟DOM 没有js BOM DOM 特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。 Vue的优缺点优点： 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了angular的特点，在数据操作方面更为简单；组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。缺点： 单页面应用程序，首页加载速度慢 不利于搜索引擎优化 Vue的使用局部使用Vue 引入 Vue 的cnd网址 或者是下载到本地js文件 （类似：jquery.js） 创建vue实例 代码演示&lt;head&gt; //引入js文件夹里的vue &lt;script src=\"./JS/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用vue --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;这是vue的区域了 app--&lt;/p&gt; &lt;p&gt;获取vue的信息：{{msg}}&lt;/p&gt; &lt;/div&gt; &lt;!-- 创建vue实例 --&gt; &lt;script&gt; const vm = new Vue({ el:'#app',//获取element元素 data:{ msg:'hello vue', } }) &lt;/script&gt; &lt;/body&gt; 搭建vue项目1.兼容性Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 2.安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 3.安装vue 命令行工具 (CLI) 介绍：Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。CLI是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速搭建一个新项。 网址：https://cli.vuejs.org/zh/ 版本：Vue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上) 先安装yarn: npm i yarn -g (推荐) 安装vue-cli： npm install -g @vue/cli （下载模块：npm install 模块 ） 或者 yarn global add @vue/cli （下载模块：yarn add 模块 ） 检查其版本是否正确vue –version 4.创建一个vue项目–通过脚手架vue-cli 创建vue项目： vue create vue-project说明：vue项目名称最好是英文 不能包含驼峰命名法 按需项目需要的依赖配置 进入项目cd 项目名称 启动项目npm run serve或者yarn serve 打包项目npm run build 目录结构 node_moudles 安装包依赖 –模块public 单页面入口 - index.htmlsrc 资源文件 – 前端– – assets 静态文件资源 - 放置 css js images– – components 公共组件 - 组件化 （样式 布局 效果）– – App.vue 根组件– – main.js 入口配置文件.browserslistrc 浏览器配置.gitignore 上传git仓库 忽略的文件配置babel.config.js babel配置package.json 项目配置文件 （查看项目安装的依赖 版本 名称… ）readme.md 项目说明文件yarn.lock 配置信息 忽略 Vue组件组成 组成-三部分 template 视图标签 （template标签不会被渲染 只是包裹作用） 必写 script 逻辑代码 style 样式 lang=’less/scss’ scoped 创建组件 xxx.vue 后缀.vue结尾 三部分组件 快捷键 vue 组件使用 引入组件 注册组件 使用组件&lt;script&gt; //1. 引入组件 import Banner from './components/Banner.vue' export default { name: 'App', //2. 注册组件 components: { Banner, } } &lt;/script&gt; &lt;!-- 3. 使用组件 --&gt; &lt;Banner&gt;&lt;/Banner&gt; vue基础语法指令：就是以 v-指令=’js环境’ 具体特定的工具 ，指令。 插值操作 (模板语法) 作用：获取vue数据 显示视图 模板语法来声明式地将数据渲染进 DOM 语法： Mustache &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;!--mustache语法中,不仅仅可以直接写变量,也可以写简单的表达式--&gt; // 获取data里的数据 &lt;h2&gt;{{firstName + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName + ' ' + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{lastName}}&lt;/h2&gt; &lt;h2&gt;{{counter * 2}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', // 提供数据 data: { message: '你好啊', firstName: 'kobe', lastName: 'bryant', counter: 100 }, }) &lt;/script&gt; 指令介绍v-once在某些情况下，我们可能不希望界面随意的跟随改变这个时候，我们就可以使用一个Vue的指令v-once:该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。代码如下： &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-once&gt;{{message}},李银河&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-html -原生HTML某些情况下，我们从服务器请求到的数据本身就是一个HTML代码如果我们直接通过插值语法来输出，会将HTML代码也一起输出但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容可以使用v-html指令该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染 &lt;div id=\"app\"&gt; &lt;h2&gt;{{url}}&lt;/h2&gt; &lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' } }) &lt;/script&gt; v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中v-text通常情况下，接受一个string类型缺点是不够灵活：第二个h2不会显示李银河 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;, 李银河!&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-prev-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。比如下面的代码第一个h2元素中的内容会被编译解析出来对应的内容第二个h2元素中会直接显示 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; //你好啊 &lt;h2 v-pre&gt;{{message}}&lt;/h2&gt; //{{message}} &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-cloak在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签cloak: “斗篷” &lt;div id=\"app\" v-cloak&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 在vue解析之前, div中有一个属性v-cloak // 在vue解析之后, div中没有一个属性v-cloak setTimeout(function () { const app = new Vue({ el: '#app', data: { message: '你好啊' } }) }, 1000) &lt;/script&gt; 条件渲染条件渲染- v-if （v-else、v-else-if） 作用：是否显示元素/ true 显示 false 隐藏 语法： &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; v-else作用：是对 v-if=’’的结果取反 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else&gt;xxxx &lt;/span&gt; v-else-if作用：是否显示元素 与v-if v-else-if 多语句判断 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else-if=\"boolean表达式\"&gt;&lt;/span&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;条件渲染 vue-if&lt;/h2&gt; &lt;!-- v-if='boolean' --&gt; &lt;p&gt;v-if的值：{{flag}}&lt;/p&gt; &lt;p v-if=\"flag\"&gt;我是v-if为true显示的&lt;/p&gt; &lt;h4 v-else&gt;我是v-else控制显示&lt;/h4&gt; &lt;button @click=\"change()\"&gt;点我控制v-if的值&lt;/button&gt; &lt;!-- 多语句 --&gt; &lt;p v-if=\"number&gt;5\"&gt; number&gt;5 &lt;/p&gt; &lt;p v-else-if=\" 2&lt; number &lt;=5\"&gt; number大于2小于等于5 &lt;/p&gt; &lt;p v-else&gt; number小于2 &lt;/p&gt; &lt;input type=\"text\" placeholder=\"请输入数字来判断number\" v-model=\"number\"&gt; &lt;br&gt; &lt;span&gt;{{number}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ flag:false, number:\"\", } }, methods:{ change(){ this.flag=!this.flag } } } &lt;/script&gt; v-show 作用：是否显示元素/ true 显示 false 隐藏 语法：特点：控制元素的 display:block/none &lt;span v-show=\"boolean表达式\"&gt;&lt;/span&gt; 列表渲染- v-for1. 遍历数组语法： &lt;li v-for=\"(item,index) in arr\" :key=\"\"&gt; {{ item }} &lt;/li&gt; 属性 item 第一个元素 表示数组的每一项内容 index 第二个元素 表示数组的下标 0 1 arr 数组数据(或者对象) :key其实是 v-bind属性 作用：做当前数据的唯一标识 一般写的是id 不推荐 index 2. 遍历对象 &lt;div v-for=\"(value, key, index) in object\"&gt; {{ index }}. {{ key }}: {{ value }} &lt;/div&gt; value 对象里每个键值对的值({key:value}中的value) key 对象里每个键值对的键名({key:value}中的key) index 下标0 1 object 要遍历的对象名 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组遍历- v-for&lt;/h2&gt; &lt;p&gt;直接获取数组数据：arr{{ arr }}&lt;/p&gt; &lt;p&gt;遍历数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in arr\" :key=\"item.id\"&gt; 每一项 {{ item }} -- 下标 {{ index }} &lt;/li&gt; &lt;/ul&gt; -------------------------------------------------- &lt;p&gt;遍历内部是对象的数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in books\" :key=\"index\"&gt; &lt;h3&gt;书名：{{ item.name }}&lt;/h3&gt; &lt;p&gt;价格：{{ item.price }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ---------------------------------------------------- &lt;p&gt;遍历对象&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(ele,key) in obj \" :key=\"key\"&gt; &lt;p&gt;{{key}}：：{{ele}}&lt;/p&gt; &lt;!-- &lt;p&gt;姓名：{{ele.uname}}&lt;/p&gt; &lt;p&gt;年龄：{{ele.age}}&lt;/p&gt; --&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3, 4], books: [ { id: 1, name: \"三国\", price: 20, }, { id: 2, name: \"西游记\", price: 30, }, { id: 3, name: \"红楼梦\", price: 40, }, ], obj: { uname: \"张三\", age: 20, }, }; }, }; &lt;/script&gt; 3. v-for 与 v-if 一同使用 注意不推荐在同一元素上使用 v-if 和 v-for 、v-for 的优先级比 v-if 更高 解决办法： &lt;template&gt; &lt;div&gt; &lt;h4&gt;4 v-for 与 v-if 一同使用, v-for 的优先级比 v-if 更高&lt;/h4&gt; &lt;h4&gt;今天上架了什么水果：&lt;/h4&gt; &lt;ul&gt; &lt;template v-for=\"(item) in zaoshi\"&gt; &lt;li :key=\"item.id\" v-if=\"item.flag\"&gt; 种类：{{item.fruit}} &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { zaoshi:[ { id:100, fruit:'苹果', flag:true, }, { id:101, fruit:'香蕉', flag:false, }, { id:102, fruit:'阳光玫瑰', flag:true, }, { id:103, fruit:'车厘子', flag:false, }, ] }; }, }; &lt;/script&gt; Vue 事件处理 介绍可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码 定义事件语法：&lt;div&nbsp;v-on:事件名=’dosomething’&gt;函数dosomething定义的位置：要求定义mothds属性中 事件：this指向：事件的this指向 当前组件实例对象事件传递参数：事件传递参数 v-on:click=’canshu(1,2)’事件对象event： 函数不带参数 第一个参数默认是事件对象 event 函数带参数 事件对象需要手动传递 $eventv-on:事件名=’函数’简写：@事件名=’函数’ 事件修饰符Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop.prevent.capture.self.once.passive &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue事件处理&lt;/h2&gt; &lt;!-- 事件修饰符 --&gt; &lt;div @click=\"parent\"&gt; //父元素 我是小头爸爸 &lt;button @click.stop=\"child\"&gt;我是大头儿子&lt;/button&gt; //子元素 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ parent(){ console.log('父元素'); }, child(){ console.log('子元素'); }, } } &lt;/script&gt; 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：.enter *.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right &lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=\"submit\"&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 按键修饰符 --&gt; &lt;input type=\"text\" v-on:keyup.enter='getInput'&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ getInput(e){ //if(e.keyCode == 13) { // console.log('按下了回车键--触发是搜索。。。'); //} console.log('按下了回车键--触发是搜索。。。'); } } } &lt;/script&gt; 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。.ctrl.alt.shift.meta &lt;template&gt; &lt;div&gt; &lt;!-- 系统修饰键 --&gt; &lt;!-- 可以按下ctrl+回车键触发 --&gt; &lt;textarea @keyup.ctrl.enter=\"send\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;button @click=\"send\"&gt;发送&lt;/button&gt; // &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { // 系统修饰键 send(){ console.log('系统修饰键--发送了聊天信息'); } }, }; &lt;/script&gt; 鼠标按钮修饰符.left.right.middle Vue中key属性的作用 （考点） 作用：key的作用主要是为了高效的更新虚拟DOM 高效的Diff算法 &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue中遍历数据v-foe是否添加key 功能&lt;/h2&gt; &lt;p&gt;key作用：提高更新虚拟DOM速度 --底层diff算法--查思路&lt;/p&gt; &lt;!-- 默认不带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;!-- 带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\" :key=\"item\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [\"A\", \"B\", \"C\", \"D\", \"E\"], }; }, methods: { addF() { // 增加 F （给数组添加元素 arr.splice(下标,删除的个数,添加的值)） this.arr.splice(2, 0, \"F\"); }, }, }; &lt;/script&gt; 数组更新检测 说明：在列表渲染中，如果遍历是数组，当数组数据发生改变时，页面什么时候能自动更新(页面重新渲染) 实现数组视图同步更新 变更方法 （修改了原数组）push()pop()shift()unshift()splice()sort()reverse() 替换数组（修改后返回新的数组 原数据不修改 视图想同步更新 覆盖原数组）filter()、concat() 和 slice() &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组更新同步&lt;/h2&gt; &lt;p&gt;arr:{{ arr }}&lt;/p&gt; &lt;button @click=\"addArr\"&gt;追加数组&lt;/button&gt; &lt;button @click=\"sliceArr\"&gt;切割数组&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3], }; }, methods: { addArr() { // this.arr.push(100) this.arr.reverse(); }, sliceArr() { //slice() 返回新的数组 n ce(1); console.log(newArr); //替换 this.arr = newArr; }, }, }; &lt;/script&gt; 对象更新检测 说明：对象修改后 视图同步更新视图 – 内存：栈内存 堆内存 实现对象视图同步更新&lt;template&gt; &lt;div&gt; &lt;h2&gt;对象同步更新&lt;/h2&gt; &lt;p&gt;对象obj:{{ obj }}&lt;/p&gt; &lt;button @click=\"changeUname\"&gt;修改对象已存在的属性&lt;/button&gt; &lt;button @click=\"obj = { user: 'admin' }\"&gt;修改整个obj对象&lt;/button&gt; &lt;!-- //视图检测不到变化 --&gt; &lt;button @click=\"addAttribute\"&gt;给obj添加不存在的属性&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ obj:{ uname:'张三', age:20 } } }, methods:{ changeUname(){ this.obj.uname = '拉拉' }, addAttribute(){ // this.obj.love = '女' // 问题: 视图检测不到变化 vue认为obj没有修改 // 方法一:对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 // this.obj = {...this.obj} // 方法二: es6合并对象 Object.assign({},{},{}) // this.obj = Object.assign({},this.obj) // 方法三: vue官网解决方法 // Vue.set( target, propertyName/index, value ) /**参数： {对象 | 数组} target 目标元素 {string | number} propertyName/index (要添加的属性)数据类型名字或者index {any} value 属性的值 用法：向响应式对象中添加一个 property(属性)，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi') **/ //这里没有引入Vue了,因为组件实例对象vm身上有$set()方法 this.$set(this.obj,'love','女') //删除 同步视图 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。 this.$delete(this.obj,'age') } } } &lt;/script&gt; Class 与 Style 绑定介绍：动态的添加class或者是style样式1.绑定 HTML Class 直接绑定变量 &lt;div v-bind:class='变量'&gt;&lt;/div&gt; 对象语法 (最常用)&lt;div v-bind:class=\"{类名: 表达式-true显示类名、false隐藏 ,类名:boolean}\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:class=\"[变量1,变量2, {类名：boolean}]\"&gt;&lt;/div&gt; 2.绑定内联样式v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 对象语法 &lt;div v-bind:style=\"{css样式:变量,... }\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 直接变量&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; data: { styleObject: { color: 'red', fontSize: '13px' } } 完整练习案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;动态绑定样式class 和 style&lt;/h2&gt; &lt;h4&gt;动态绑定样式class&lt;/h4&gt; &lt;!-- 绑定变量 --&gt; &lt;button @click=\"active = 'box2'\"&gt;切换颜色-绑定变量&lt;/button&gt; &lt;div v-bind:class=\"active\"&gt;动态绑定样式class&lt;/div&gt; &lt;hr /&gt; &lt;!-- 对象语法 --&gt; &lt;div v-bind:class=\"{ box: flag }\"&gt;对象语法&lt;/div&gt; &lt;button @click=\"flag = !flag\"&gt;修改flag-对象语法&lt;/button&gt; &lt;hr /&gt; &lt;!-- 数组语法 --&gt; &lt;div class=\"aa\" v-bind:class=\"[active, { box2: true }]\"&gt;数组语法&lt;/div&gt; &lt;hr /&gt; &lt;h2&gt;动态绑定内联样式&lt;/h2&gt; &lt;p&gt;0. 默认的内联写法&lt;/p&gt; &lt;div style=\"width: 100px; height: 100px; background: orange\"&gt; 默认的内联写法 &lt;/div&gt; &lt;p&gt;1. 直接变量&lt;/p&gt; &lt;div v-bind:style=\"styleObject\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;2. 对象语法&lt;/p&gt; &lt;div v-bind:style=\"{color:'green',fontSize:'30px', width:'100px',height: '100px',backgroundColor:'blue'}\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;3. 数组语法&lt;/p&gt; &lt;div :style=\"[styleObject,{border:'5px solid #333'}]\"&gt;数组语法&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { active: \"box\", flag: \"true\", styleObject:{ width: '100px', height: '100px', background: 'orange', } }; }, methods: { changeColor() { this.active = \"box2\"; }, }, }; &lt;/script&gt; &lt;style&gt; .box { width: 200px; height: 200px; background-color: pink; } .box2 { width: 200px; height: 200px; background-color: rgb(21, 226, 253); } &lt;/style&gt; Vue-tab栏切换练习&lt;template&gt; &lt;div&gt; &lt;h2&gt;Vue-tab切换&lt;/h2&gt; &lt;ul class=\"nav\"&gt; &lt;li v-for=\"(item,index) in arr\" :key='item' :class=\"{active:index == num}\" @click=\"changeNav(index)\"&gt; {{item}}-{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"box1\"&gt; &lt;div v-for=\"(ele,n) in content \" :key=\"ele\" :class=\"{show:n == num}\"&gt;{{ele}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 0, arr: [\"选项1\", \"选项2\", \"选项3\"], content: [\"111\", \"222\", 333], }; }, methods: { changeNav(index){ this.num = index } }, }; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; .nav { overflow: hidden; list-style: none; li { display: inline; width: 100px; height: 40px; line-height: 40px; margin-right: 10px; } .active{ background: lightblue; } } .box1 { margin: auto; width: 400px; height: 200px; border: 1px solid #000; &gt;div { display: none; } .show { display: block; } } &lt;/style&gt; 表单输入绑定 (v-modele)1.介绍你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定通过指令 v-model=’’ 获取表单输入的信息数据 实现双向数据绑定 2.语法:会将文本框输入的数据实时传递给绑定到data里的msg中 &lt;input type='text' v-model='msg' /&gt; data(){ return{ msg:'' } } 案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;表单输入绑定&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" :value=\"msg\" name=\"\" id=\"\"&gt; --&gt; &lt;!-- 1. 文本/密码 v-model=''--&gt; &lt;input type=\"text\" placeholder=\"请输入\" v-model=\"formData.msg\" @keyup.enter=\"send\" name=\"\" id=\"\" /&gt; &lt;p&gt;msg:{{formData.msg}}&lt;/p&gt; &lt;!-- 2. 多行文本 --&gt; &lt;!-- 3. 单选按钮 --&gt; 性别: &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"1\" /&gt;男 &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"2\" /&gt;女 &lt;p&gt;选择的性别:{{ formData.sex }}&lt;/p&gt; &lt;!-- 爱好: --&gt; &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"a\" /&gt;吃 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"b\" /&gt;喝 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"c\" /&gt;玩 &lt;p&gt;选择的爱好:{{ formData.arr }}&lt;/p&gt; &lt;!-- 城市: --&gt; &lt;select name=\"\" id=\"\" v-model=\"formData.select\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"gaungzhou\"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;p&gt;城市选择:{{ formData.select }}&lt;/p&gt; &lt;button @click=\"submit\"&gt;注册信息&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'初始值', sex:'', //对象的语法--------存储表单数据 formData: { msg: \"\", //输入框 sex: 1, //性别 arr: [], select: \"\", }, }; }, methods:{ send() { console.log(\"输入的数据为:\", this.msg); }, submit() { //点击按钮--发送输入的数据给后台-- data -- msg sex arr ... console.log(\"提交注册信息表单\",this.formData); }, } }; &lt;/script&gt; 3.修饰符 lazy&nbsp; 只有当input失去焦点时才更新数据 number 把input标签中输入的内容转成数字，调用是parseFloat (Nunber()) trim 去除左右空格 案例： &lt;template&gt; &lt;div&gt; &lt;h3&gt;表单修饰符 -修饰符 &lt;/h3&gt; &lt;!-- .lazy 失去焦点或者回车 获取数据 --&gt; &lt;input type=\"text\" v-model.lazy=\"search\"&gt; &lt;p&gt;search:{{ search }}&lt;/p&gt; &lt;input type=\"text\" v-model.trim=\"msg\" name=\"\" id=\"\"&gt; &lt;p&gt;去空格:{{msg}}&lt;/p&gt; &lt;!-- .number 转数字 --&gt; &lt;input type=\"number\" v-model.number=\"num\" name=\"\" id=\"\"&gt; &lt;p&gt;num:{{ num }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ } }; &lt;/script&gt; 4.v-model实现原理v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发oninput 事件并传递数据v-model&nbsp;是什么。语法糖&nbsp;:value&nbsp;+&nbsp;@input。还要分为两种情况 &lt;input v-model=\"val\"&gt; &lt;!-- 基本等价于，因为内部还有一些其他的处理 --&gt; // $event是事件对象，$event.target.value表示input框中的输入值 &lt;input :value=\"val\" @input=\"val = $event.target.value\"&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;!-- v-model实现的原理 --&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;p&gt;inp:{{inp}}&lt;/p&gt; &lt;!-- v-model == v-bind:value='' @input='函数' --&gt; 表单值:&lt;input type=\"text\" :value=\"val\" @input=\"changeVal\" name=\"\" id=\"\"&gt; &lt;p&gt;val:{{val}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { val:'请输入', msg:'', inp:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ changeVal(e){ console.log(e); //表单的事件对象 console.log(e.target.value); //表单里的文本框内容 this.val = e.target.value; //将文本框内容 赋值给 data里的val 即使用v-bind又让数据进行双向绑定了 } } }; &lt;/script&gt; 计算属性和侦听器1. 计算属性 介绍: 处理数据后把数据缓存起来 使用数据的时候使用的缓存的数据,但是如果原数据修改了重新计算 语法&lt;template&gt; &lt;div&gt; &lt;h2&gt;计算属性computed&lt;/h2&gt; &lt;!-- 如果是字符串 取反操作实现 --&gt; &lt;p&gt;字符串:{{ msg }}&lt;/p&gt; &lt;!-- 不推荐: 模板语法里面写很多方法 多次使用不方便 --&gt; // split-先转换为数组， reverse-然后取反， join-最后转为字符串 &lt;p&gt;字符串-取反:{{ msg.split(\"\").reverse().join(\"\") }}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;button @click=\"msg = 'how are you'\"&gt;修改msg&lt;/button&gt; &lt;!-- 例子: v-for='' v-if不能在同一个元素使用 -- computed处理数据 --&gt; &lt;h4&gt;早市水果更新:&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=\"item in zaoshi2\" :key='item.id'&gt; {{item.fruit}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: \"hello vue\", zaoshi: [ { id: 100, fruit: \"苹果\", flag: false, }, { id: 101, fruit: \"阳光玫瑰\", flag: true, }, { id: 102, fruit: \"车厘子\", flag: false, }, { id: 103, fruit: \"榴莲\", flag: true, }, ], }; }, methods: { qufan() { console.log(\"执行了一次取反方法\"); return this.msg.split(\"\").reverse().join(\"\"); }, }, //计算属性: 对数据进行加工处理 缓存数据 computed: { msg2() { console.log(\"计算属性: 对数据进行加工处理 缓存数据\"); return this.msg.split(\"\").reverse().join(\"\"); }, //处理数据 zaoshi2(){ //过滤方法 返回的满足条件的数组 比如:[1,2,3,4] =&gt;[3,4] return this.zaoshi.filter((item)=&gt;{ // if(item.flag == true) { // return item.flag // } return item.flag }) } }, }; &lt;/script&gt; 2. 侦听器 介绍: Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化 &lt;template&gt; &lt;div&gt; &lt;h2&gt;侦听器-watch&lt;/h2&gt; &lt;p&gt;功能:监听数据修改了,然后做业务逻辑&lt;/p&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ inp:'', arr:[] } }, //侦听器--数据变化 (当前监听的是inp变化) watch:{ inp:function(n,o){ console.log('新值:',n ,'旧值:',o); //业务逻辑 比如输入东西后 网络请求 //模糊查询 } } } &lt;/script&gt; 3. computed和watch区别 （考点） 相同：computed和watch都是观察页面的数据变化的。 不同：computed：是计算属性，依赖其它属性值: 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化watch：没有缓存性，更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； Vue 的生命周期方法有哪些 一般在哪一步发请求生命周期：事物从诞生到消亡的过程Vue生命周期： v-if 和 v-show 的区别v-if: 控制元素的渲染或者销毁v-show:控制元素的 display:block/none 场景：频繁切换： v-show初次渲染优化：v-if Vue 修饰符有哪些v-for 为什么要加 key理解 Vue 的单向/双向 数据流首先了解一下数据绑定什么是绑定？比如当前href属性值取决于表达式school.url.toUpperCase()的结果，这两者之间就是有绑定关系，且通过v-bind指令完成数据绑定。 &lt;a v-bind:href=\"school.url.toUpperCase()\" v-bind:x=\"hello\"&gt;点我去{{school.name}}学习&lt;/a&gt; v-bind 单向数据原理前面学习的指令主要作用是将值插入到模板的内容当中但除了内容需要动态来决定外，某些属性也希望动态来绑定作用：动态绑定属性缩写：**:**预期：any (with argument) | Object (without argument)参数：attrOrProp (optional)v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到Vue进阶时介绍)在开发中，一般有哪些属性需要动态进行绑定呢？比如图片的链接src、网站的链接href、动态绑定一些类、样式等等例子：通过Vue实例中的data绑定元素的src和href，代码如下： 基本使用很多时候，我们希望动态的来切换class，比如：当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。 &lt;div id=\"app\"&gt; &lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt; &lt;!--&lt;img src=\"{{imgURL}}\" alt=\"\"&gt;--&gt; &lt;!-- 正确的做法: 使用v-bind指令 --&gt; &lt;img v-bind:src=\"imgURL\" alt=\"\"&gt; &lt;a v-bind:href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;!--&lt;h2&gt;{{}}&lt;/h2&gt;--&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=\"imgURL\" alt=\"\"&gt; &lt;a :href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', imgURL: 'https://img11.360buyimg.com/mobilecms/s350x250_jfs/t1/20559/1/1424/73138/5c125595E3cbaa3c8/74fc2f84e53a9c23.jpg!q90!cc_350x250.webp', aHref: 'http://www.baidu.com' } }) &lt;/script&gt; v-bind动态绑定class(对象语法) 绑定方式：对象语法含义是:class后面跟的是一个对象 直接通过{}绑定一个类&lt;h2 :class=\"{'active': isActive}\"&gt;Hello World&lt;/h2&gt; 也可以通过判断，传入多个值&lt;h2 :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=\"title\" :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 比如ul的li标签点击某个标签变颜色 &lt;div id=\"app\"&gt; &lt;!-- 当布尔值为true 这个类名1即 active 就会被添加到标签上 --&gt; &lt;!-- 一个 { } 表示对象 --&gt; &lt;h2 class=\"title\" v-bind:class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" v-bind:class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', isActive: true, isLine: true }, methods: { btnClick: function () { this.isActive = !this.isActive }, getClasses: function () { return {active: this.isActive} } } }) &lt;/script&gt; v-bind动态绑定class(数组语法) 数组语法的含义是:class后面跟的是一个数组。 直接通过{}绑定一个类&lt;h2 :class=\"['active']\"&gt;Hello World&lt;/h2&gt; 也可以传入多个值&lt;h2 :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：会有title/active/line三个类&lt;h2 class=\"title\" :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 例如： &lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"[active, line]\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', active: 'aaaaaa', line: 'bbbbbbb' }, methods: { getClasses: function () { return [this.active, this.line] } } }) &lt;/script&gt; 小案例 点击li标签变色（默认第一li为红色）分析： v-for绑定给li标签，同时v-on添加点击事件，并且li标签的class用v-bind动态绑定 使用v-for绑定到li标签上，自动遍历data中的数据，将下标（index）和每一项内容（item）用插值语法显示到页面 在data中添加一个isRed属性值为0，想让class样式显示，需要v-bind绑定的red值为true，即该值可以等等于index,因为index的第一个值就是0 v-on点击事件点击某一个li，将下标的值赋值给isRed，即当前点击的li标签的class样式显示 end~&lt;style&gt; .red { color: red; } &lt;/style&gt; &lt;!--作业需求: 点击列表中的哪一项, 那么该项的文字变成红色--&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=\"每一项,下标 in 数据源\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;li v-for=\"(item,index) in movie\" v-on:click=\"getColor(index)\" v-bind:class=\"{red:isRed==index}\" &gt;{{index}}--{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', data:{ isRed:0, movie:['海王','海尔兄弟','火影忍者','进击的巨人'] }, methods:{ getColor: function (index){ this.isRed = index console.log(this.isRed); } }, }) &lt;/script&gt; v-bind绑定style 一利用v-bind:style来绑定一些CSS内联样式在写CSS属性名的时候，比如font-size可以使用驼峰式 (camelCase) fontSize或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ v-model 双向数据原理Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。Vue中有两种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。备注： 双向绑定一般都应用在表单类元素上（如：input、select等） v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。&lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'哔哩哔哩', } }) &lt;/script&gt; 虚拟 DOM 是什么 有什么优缺点MVVM全称： Model-View-ViewModel ， Model 表示数据模型层。 view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。 Model层： 数据层数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。 View层： 视图层在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。 VueModel层： 视图模型层视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。 M：模型(Model) ：对应 data 中的数据 V：视图(View) ：模板 VM：视图模型(ViewModel) ： Vue 实例对象Vm（Vue实例对象）把左边的View和右边Model进行连接在一起 观察发现： data中所有的属性，最后都出现在了vm身上。 VM身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 执行过程 ：数据在data中经过 VM视图模型放到了页面View上页面上如果有地方需要更改要映射回数据就再给VM视图模型，然后视图模型再给data里的数据 &lt;!-- 1 准备好一个容器 也就是 view 视图 模板代码--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;!-- &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = fal se //阻止 vue 在启动时生成生产提示 const vm = new Vue({// 2 VM 视图模型ViewModel el:'#root', data:{ // 3 data里的是模型 model name:\"b站大学\", address:\"成都\", } }) console.log(vm) &lt;/script&gt; Vue的数据代理首先学习下 Object.defineProperty()方法Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。defineProperty()参数 Object.defineProperty(obj, prop, descriptor) obj 需要定义属性的对象 prop 需被定义或修改的属性名 descriptor 需被定义或修改的属性的描述符 例子：定义了一个person对象，里面包含name、sex属性和其它属性值。注意：age属性是通过defineProperty方法中 &lt;script type=\"text/javascript\"&gt; let number = 19 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { value:19, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value } }) console.log(Object.keys(person)) // Object.keys方法传入一个对象作为参数，可以把传入对象所有属性的属性名提取出来变成数组 console.log(person) &lt;/script&gt; Vue中的数据代理什么是数据代理数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） &lt;script type=\"text/javascript\" &gt; let obj = { x:100 } let obj2 = { y:200 Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; vue常用ui库移动端 mint-ui （http://mint-ui.github.io/#!/zh-cn） Vant（https://youzan.github.io/vant/#/zh-CN/home） VUX (https://vux.li/) pc端 element-ui（https://element.eleme.cn/2.13/#/zh-CN/component/installation） Ant Design of Vue（https://www.antdv.com/docs/vue/introduce-cn/） Avue (https://avuejs.com/) 常用webpack配置待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"}]},{"title":"axios学习","slug":"04-axios学习","date":"2022-04-17T06:12:00.000Z","updated":"2022-06-16T03:35:21.712Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://wuzimo233.github.io/posts/4.html","excerpt":"","text":"前置条件已经学习过ajax、Promise准备json-server包，快速搭建HTTP服务（用axios的时候需要向服务端发送请求即需要服务端这个角色来与axios结合做实践） json-server用于模拟服务端接口数据，可以根据json数据建立一个完整的web服务 1安装json-servernpm install -g json-server //查看版本号，安装成功 json-server -v 2在文件夹下创建一个db.json文件，存放一些数据。{ \"posts\": [ //文章 { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"《b站大学》\", \"author\": \"吴老师\" } ], \"comments\": [ //评论 { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }, { \"body\": \"喜大普奔\", \"postId\": 2, \"id\": 2 } ], \"profile\": { //个人信息 \"name\": \"typicode\" } } 3 启动服务进入终端。执行启动json-server命令:json-server --watch .\\db.json 认识axiosaxios 是什么?axios是目前前端使用非常广泛的基于 promise 的 HTTP 网络请求库，包括Vue/React也是推荐使用axios；本质是XMLHttpRequests请求 即ajax请求 axios 特性： 从浏览器中创建 XMLHttpRequests （浏览器中发送xml请求） 从 node.js 创建 http 请求 （在node.js中发送http请求） 支持 Promise API 相关操作 拦截请求和响应 转换请求数据和响应数据（对请求和响应的数据作转换） 取消请求 自动将结果转换成 JSON 数据 客户端支持防御 XSRF （阻止跨站攻击） axios安装 1 使用 npm安装:$ npm install axios 2 使用 yarn安装:$ yarn add axios 3 使用 jsDelivr CDN安装:&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.min.js\"&gt;&lt;/script&gt; console.log(axios); //ƒ() {for(var n=new Array(arguments.length),r=0;r&lt;n.length;r++)n[r]=arguments[r];return e.apply(t,n)} //建议使用国内CDN网速较快 //去这个网站引入 https://www.bootcdn.cn/axios/ axios的基本使用 前置：引入了axios准备四个按钮发送不同的请求 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; GET请求//获取按钮 const btns = document.querySelectorAll('button'); //第一个 （get 查询功能） btns[0].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'GET', //请求地址 刚启动好的json-server地址 且id为2的那篇文章 url: ' http://localhost:3000/posts/2' }).then(response =&gt; { console.log(response); }) } POST请求//添加一篇新的文章 （post 添加功能） btns[1].onclick = function () { //发送ajax请求 axios({ method: 'POST', //请求类型 url: ' http://localhost:3000/posts', //请求地址 data: { \"title\": \"招聘摄影\", //请求体 \"author\": \"小吴\" } }).then(response =&gt; { console.log(response); }) } PUT请求//更新文章 需要在url里加上id 比如这里要更新的是id为3的文章（put 更新功能） btns[2].onclick = function () { //发送ajax请求 axios({ method: 'PUT', //请求类型 url: ' http://localhost:3000/posts/3', //请求地址 data: { \"title\": \"招聘程序员吗\", //修改请求体的数据 \"author\": \"小瑶酱\" } }).then(response =&gt; { console.log(response); }) } DELETE请求//删除文章 （delete 删除功能） btns[3].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'DELETE', //请求地址 url: ' http://localhost:3000/posts/3', }).then(response =&gt; { console.log(response); }) } axios的其他发送请求使用request方法 发送 GET 请求 （接收一个对象类型参数）//获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ // axios() axios.request({ method:'GET', url:' http://localhost:3000/posts', // 返回结果依然是Promise对象 用then指定成功的回调 }).then((response) =&gt; { console.log(response); }) ; } //使用POST方法 发送post请求 增加数据//获取按钮 const btns = document.querySelectorAll('button'); btns[1].onclick = function(){ // axios() axios.post( 'http://localhost:3000/comments', { \"body\": \"喜大普奔\", \"postId\": 2 }).then(response =&gt; { console.log(response); }) } axios配置对象{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 baseURL: 'https://some-domain.com/api/', // `transformRequest` 对请求的数据做处理，处理后将结果像服务器发送 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 对响应的结果做一些改变，改变之后我们用自定义的回调去处理结果 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 对请求头信息做一个配置（身份校验） headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求体的设置 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时对coken的携带设置 withCredentials: false, //不携带 // `adapter` 对请求的适配器做设置 // 有两种一种是ajax、一种是node.js里发送http请求的 adapter: function (config) { /* ... */ }, // `auth` 对请求基础的验证设置用户名和密码 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // 响应结果的编码 responseEncoding: 'utf8', // `xsrfCookieName` 跨域请求标识对cookie的名称设置 xsrfCookieName: 'XSRF-TOKEN', // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 上传的一些回调 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 下载时的一些回调 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 对响应结果的成功做一个设置 什么情况下是成功的呢？默认值为响应状态码 大于等于200 小于300 validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 最大跳转的次数 默认5次 即向一个服务发送请求，它作了跳转后呢，我们是否需要让它继续往前进行请求 maxRedirects: 5, // 默认的 // 设置socket 文件的位置 作用是像docker的守护进程发送请求的 socketPath: null, // default // 对客户端的一些信息做一些设置 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 设置代理 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 对ajax请求作一个取消的设置 cancelToken: new CancelToken(function (cancel) { }) } axios的默认配置例子：点击按钮发送get请求//没有做默认配置时，每次访问都比较麻烦 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ axios({ method:'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log(response); }) } &lt;/script&gt; 使用默认配置后 //默认配置 axios.defaults.method = 'GET'; //设置默认的请求类型为 GET axios.defaults.baseURL = 'http://localhost:3000' //设置基础url btns[0].onclick = function () { axios({ url: '/posts', }).then(response =&gt; { console.log(response); }) //还有其他的默认配置项 // axios.defaults.params = {id:100}; 默认的请求url参数 即url后增加 ?id=100 // axios.defaults.timeout = 3000; 超时时间 axios创建实例对象主要用于：项目中接口数据服务不是来自于单一的服务器，比如有两个服务器A、B，都提供了数据服务。在发送请求时，比如给A发，就要去设置A的协议域名端口，如果用默认方法做只能满足一个服务器， &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 发送POST请求 &lt;/button&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //创建实例对象 /getJoke const duanzi = axios.create({ baseURL:'https://api.apiopen.top', timeout:2000 }); //这里duanzi 与 axios 对象的功能几近是一样的 duanzi({ url:'/getJoke', }).then((response)=&gt;{ console.log(response); }) duanzi.get('/getJoke').then((response) =&gt; { console.log(response.data); }) const another = axios.create({ baseURL:'http:b.com', timeout:2000 }) axios拦截器在请求或响应被 then 或 catch 处理前拦截它们。在发送请求之前，借助一些函数对请求的参数和内容作一些处理和检测。如果说都没有问题再去发送请求，有问题的话这个请求就停止或者取消。当服务器返回结果之后，可以通过自己指定的回调处理结果。那么响应拦截器可以在我们处理响应结果之前先对结果做一些预处理。如：失败了就对失败结果做一些提醒或者记录，还能对数据接口做一些格式化的处理。然后再交由我们自己自定义的回调来处理。如果有问题在响应拦截器中就处理掉了。执行顺序是，当用户发送请求后先执行请求拦截器成功/失败的回调，然后走响应拦截器成功/失败的回调，然后再走自定义的成功/失败的回调 一般情况// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); return config; }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }); 其他情况：请求拦截器成功但抛出错误，响应拦截器失败，自定义失败回调// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); // return config; throw '参数出了问题' //如果这里抛出错误即失败了，返回一个失败的Promise， //在执行后续的响应回调时就只能走失败的回调了， }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) 多个请求、响应的结果顺序请求拦截器 成功 2号请求拦截器 成功 1号响应拦截器 成功 1号响应拦截器 成功 2号自定义回调处理成功的结果{data: Array(2), status: 200, statusText: ‘OK’, headers: {…}, config: {…},&nbsp;…} // Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 1号'); //修改 config 中的参数 // config.params = {a:100}; return config; }, function (error) { console.log('请求拦截器 失败 1号'); return Promise.reject(error); }); axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 2号'); //修改 config 中的参数 config.timeout = 2000; return config; }, function (error) { console.log('请求拦截器 失败 2号'); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 1号'); return response; // return response; }, function (error) { console.log('响应拦截器 失败 1号') return Promise.reject(error); }); axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 2号') return response; }, function (error) { console.log('响应拦截器 失败 2号') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) axios取消请求 基本流程配置 cancelToken 对象缓存用于取消请求的 cancel 函数在后面特定时机调用 cancel 函数取消请求在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能点击按钮, 取消某个正在请求中的请求 在请求一个接口前, 取消前面一个未完成的请求 使用 canceltoken 取消请求Axios 的 cancel token API 基于cancelable promises proposal可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;axios取消请求&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 取消请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function(){ // 防止用户疯狂点击按钮发送请求 //检测上一次的请求是否已经完成 if(cancel !== null){ //取消上一次的请求 cancel(); } axios({ method: 'GET', url: 'http://localhost:3000/posts', //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function(c){ //3. 将 c 的值赋值给 cancel cancel = c; }) }).then(response =&gt; { console.log(response); //将 cancel 的值初始化 cancel = null; }) } //绑定第二个事件取消请求 btns[1].onclick = function(){ cancel(); } axios源码文件结构说明 ├── /dist/ # 项目打包后的文件即最终输出的axios整体文件 ├── /lib/ # 项目源码目录 │ ├── /adapters/ # 定义请求的适配器 xhr、http │ │ ├── http.js # 用来在node.js中向 远端服务发送HTTP请求的 │ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象) │ ├── /cancel/ # 定义取消功能 │ ├── /core/ # 一些核心功能 │ │ ├── Axios.js # axios 的核心主类 构造函数 │ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数 │ │ ├── InterceptorManager.js # 拦截器的管理器 │ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态 │ ├── /helpers/ # 一些辅助方法 │ ├── axios.js # 对外暴露接口 │ ├── defaults.js # axios 的默认配置 │ └── utils.js # 公用工具 ├── package.json # 项目信息 ├── index.d.ts # 配置 TypeScript 的声明文件 └── index.js # 入口文件 axios的创建过程axios对象创建过程模拟实现axios发送请求过程详解模拟实现axios发送请求axios拦截器工作原理模拟实现axios拦截器功能axios 取消请求工作原理模拟实现axios取消请求功能axios源码分析总结","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise学习","slug":"03-Promise学习","date":"2022-04-14T06:30:00.000Z","updated":"2022-06-16T03:35:15.395Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://wuzimo233.github.io/posts/3.html","excerpt":"","text":"认识 Promise 什么是 Promise 抽象表达: Promise 是一门新的技术(ES6 规范)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数 具体表达: 语法上来说: Promise 是一个构造函数从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 为什么要用 Promise指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题 什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用 终极解决方案? async/await 如何使用 PromisePromise 语法结构 语法结构： new Promise((resolve, reject) =&gt; { } 里面是一个函数类型的参数，参数里面的两个参数也是函数在花括号{ }里边包含一个异步操作,如果成功则调用 resolve ，同时只要 resolve 调用就会将 promise 对象 p 的状态设置为『成功』，如果失败则调用 reject，调完 reject 后会将 promise 对象 p 的状态设置为『失败』（即这两个可以修改 promise&gt;对象的状态）接着 promise 对象通过调用 then()方法去指定成功和失败时的回调如果成功就执行第一个回调函数，失败则执行第二个回调函数Promise 除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即下方Promise 形式实现案例的 n 值然后可以将 n 值传递给 resolve 和 reject 函数最后下方的 then 方法里的两个回调都能拿到这个结果值作为参数使用 Promise 初体验 案例：需求——点击抽奖按钮两秒后，告诉用户是否中奖，中奖的概率是百分之 30。如果中奖在页面中弹框告知恭喜中奖，没有就弹出再接再厉。 一般方法实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 定时器 setTimeout(() =&gt; { //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ alert(n+'恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券'); }else{ alert(n+'再接再厉'); } }, 1000); }) &lt;/script&gt; Promise 形式实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 使用 new Promise(接收一个函数参数) 创建实例 // resolve 解决 函数类型的数据 --成功时调用 // reject 拒绝 函数类型的数据 --失败时调用 const p = new Promise((resolve, reject) =&gt; { // promise对象可以包裹一个异步操作（直接将上方定时器拿过来） setTimeout(() =&gt; { //30% 1-100 1 2 30 //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ // Promise除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即这里的n值 // 可以将n值传递给resolve 和 reject函数 // 那么下方的then方法里的两个回调都能拿到这个结果值作为参数 resolve(n); // 调完resolve后会将 promise 对象 p 的状态设置为『成功』 }else{ reject(n); // 调完reject后会将 promise 对象 p 的状态设置为『失败』 } }, 1000); }); console.log(p); //调用 then（里边有两个回调函数参数） 方法 --- 每个promise对象上都有then方法 // 第一个回调是对象状态为成功时的回调，第二个是对象状态失败时的回调函数 // value 值 // reason 理由 p.then((value) =&gt; { alert('恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 ' + value); }, (reason) =&gt; { alert('再接再厉, 您的号码为 ' + reason); }); }) &lt;/script&gt; 实践练习 Promise 封装 AJAX// 需求点击按钮发送ajax请求拿到段子接口的数据 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 封装 AJAX 操作&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击发送 AJAX&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //接口地址 https://api.apiopen.top/getJoke //获取元素对象 const btn = document.querySelector('#btn'); // 给按钮绑定点击事件 btn.addEventListener('click', function(){ //首先创建 Promise 对象 p const p = new Promise((resolve, reject) =&gt; { //1.创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 get请求 给后边的接口发送 xhr.open('GET', 'https://api.apiopen.top/getJoke'); //3. 发送 xhr.send(); //4. 处理响应结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断响应状态码 2xx if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //控制台输出响应体 resolve(xhr.response); }else{ //控制台输出响应状态码 reject(xhr.status); } } } }); //调用then方法 p.then(value=&gt;{ console.log(value); }, reason=&gt;{ console.warn(reason); }); }); &lt;/script&gt; Promise的状态 『PromiseState』 的改变状态是Promise实例对象当中的一个属性，属性叫做 promiseState 有三种状态 pending 值未决定的、初始化的默认值 pending 变为 resolved / fullfilled 即成功 pending 变为 rejected 即失败说明: pending变化只有这 2 种情况, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据成功的结果数据一般称为 value, 失败的结果数据一般称为 reason Promise对象 『PromiseResult』的值保存着异步任务『成功/失败』的结果以下函数能够修改这个属性的值： resolve reject Promise的基本流程 首先通过new Promise 创造一个对象，在Promise内部封装异步操作。如果异步操作成功则调用resolve函数，resolve函数调用后会把Promise对象状态改为成功，成功在调用then方法时将调用的是第一个回调函数参数，返回一个新的promise对象如果在Promise内部封装的异步操作失败，则调用reject 函数，reject函数调用后会把Promise对象状态改为失败，失败之后调用的是then方法中的第二个回调函数参数，并且返回一个新的Promise对象 Promise的Api执行器函数Promise 构造函数: Promise (excutor) {}//new实例化对象需要接收一个参数，参数是一个函数类型的参数（也称之为执行器函数），而且函数当中有两个形参也是函数类型参数resolve、reject，这俩函数是内部定义的，异步任务成功就会调用resolve函数，失败就会调用reject函数。(1) executtor 函数: 执行器 (resolve, reject) =&gt; {}(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}说明: 执行器函数 executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行 let p = new Promise((resolv, reject) =&gt; // resolve('ok'); console.log(111); }) console.log(222); //结果控制台先打印111 ，后打印222。表明 p对象内部的代码是同步调用的 Promise.then方法Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}// 说明: then方法是用于指定回调的，传递两个参数，第一个参数是传递成功时的回调，第二个参数是传递失败时的回调。返回一个新的 promise 对象(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} Promise.catch方法Promise.prototype.catch 方法: (onRejected) =&gt; {}// 说明: catch() 方法是 then()的语法糖, 相当于: then(undefined, onRejected)，即只能指定失败的回调。 onRejected 函数: 失败的回调函数 (reason) =&gt; {let p = new Promise((resolv, reject) =&gt; // 修改Promise对象的状态 reject('error 失败了'); }) // 执行catch方法 p.catch(reason =&gt; { console.log(reason); }) Promise.resolve方法 Promise.resolve 方法: (value) =&gt; {}// 说明：它属于Promise函数对象，不是实例对象。接收一个参数，返回一个成功或失败的对象// 作用：就是快速得到一个Promise对象，还能封装一个值，将这个值转化为Promise对象 value: 成功的数据或 promise 对象 //如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象 //如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果 let zimo = Promise.resolve(\"I Love You\"); console.log(zimo); // Promise&nbsp;{&lt;fulfilled&gt;: 'I Love You' let p1 = Promise.resolve(new Promise((resolve, reject) =&gt; { resolve('OK'); // reject('Error'); })); p1.then((value) =&gt; { console.log(value); //ok },(reason)=&gt;{ console.log(reason); }) console.log(p1); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} let p2 = Promise.resolve(p1); console.log(p2); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} Promise.reject方法Promise.reject 方法: (reason) =&gt; {}说明: 快速返回一个失败的 promise 对象即便传入成功的Promise对象结果也是失败 reason: 失败的原因let p1 = Promise.reject(520); p1.catch((reason) =&gt;{ console.log(reason); // Promise&nbsp;{&lt;rejected&gt;: 520} }) console.log(p1); // 520 let p2 = Promise.reject('iloveyou'); let p3 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p2); // Promise&nbsp;{&lt;rejected&gt;: 'iloveyou'} console.log(p3); //Promise&nbsp;{&lt;rejected&gt;: Promise} Promise.all 方法Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败。let p1 = new Promise((resolve, reject) =&gt; { resolve('OK'); }) // let p2 = Promise.resolve('Success'); let p2 = Promise.reject('Error'); let p3 = Promise.resolve('Oh Yeah'); const result = Promise.all([p1, p2, p3]); console.log(result); //[PromiseState]]: \"rejected\" Promise.race 方法Promise.race 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 第一个改变状态的 promise对象就是最终的结果状态。let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }) let p3 = Promise.resolve('Oh Yeah'); let p2 = Promise.resolve('Success'); //调用 const result = Promise.race([p1, p3, p2]); console.log(result); // [[PromiseState]]: \"fulfilled\" // [[PromiseResult]]: \"Oh Yeah\" Promise的几个关键问题如何改变 promise 的状态? 第一种方式 调用 resolve 函数: 如果当前Promise对象是 pending状态就会变为fulfilled(resolve) 第二种方式 调用 reject 函数: 如果当前Promise对象是 pending状态就会变为 rejected 第三种方式 抛出异常: 如果当前是 pending 就会变为 rejectedlet p = new Promise((resolve, reject) =&gt; { //初始化状态是pending //第一种方式 调用 resolve 函数 // resolve('ok'); // pending =&gt; fulfilled (resolved) //第二种方式 调用 reject 函数 // reject(\"error\");// pending =&gt; rejected //3. 抛出错误 throw '出问题了'; //pending =&gt; rejected }); console.log(p); 一个 promise 指定多个成功/失败回调函数, 都会调用吗?简单说问题是：用then方法为一个Promise对象去指定多个回调，这些回调是否都会执行？答案：当 promise 改变为对应状态时都会调用 let p = new Promise((resolve, reject) =&gt; { resolve('OK'); }); ///指定回调 - 1 p.then(value =&gt; { console.log(value); }); //指定回调 - 2 p.then(value =&gt; { alert(value); }); 改变 promise 状态和指定回调函数谁先谁后?答案： 都有可能 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promise对象改变状态后才执行 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promi对象改变状态后才执行 }); p.then(value =&gt; { console.log(value); },reason=&gt;{ }) 如何先改状态再指定回调?① 在执行器中直接调用 resolve()/reject()② 延迟更长时间才调用 then() 什么时候才能得到数据?① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 promise.then()返回的新 promise 的结果状态由什么决定?(1) 简单表达: 由 then()指定的回调函数执行的结果决定(2) 详细表达:① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 promise 如何串连多个操作任务?(1) promise 的 then()返回一个新的 promise, 即可以在后边接着调用then()方法，可以看成 then()方法的链式调用(2) 通过 then 的链式调用串连多个同步/异步任务 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //异步任务 }); p.then(value =&gt; { return new Promise((resolve, reject) =&gt; { resolve(\"success\"); }); }).then(value =&gt; { //这里的Promise状态由他指定的回调函数的返回值绝定，此处回调函数没写返回值即为Undefined 所以这里的then方法返回结果就是一个成功的Promise且成功的结果就是回调函数返回的结果Undefined，因为成功了所以后边的then方法也会执行第一个回调函数，并且输出前边成功的结果所以依然是Undefined console.log(value); // success }).then(value =&gt; { console.log(value); //undefined }) promise 异常传透?(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理例如：下方启动了一个Promise，后续用then方法又进行了几个其他的任务，这时候只需要在最后的位置去指定失败的回调就可以。 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); // reject('Err'); }, 1000); }); p.then(value =&gt; { // console.log(111); throw '失败啦!'; }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); //失败啦! }); 中断 promise 链?(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }); p.then(value =&gt; { console.log(111); // 111 //有且只有一个方式 返回一个pending状态的Promise对象 return new Promise(() =&gt; {}); //下方的then方法因为没有发现前边的Promise对象状态发生改变所以就不执行了 }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); }); 自定义（手写）Promise(后续学习)定义整体结构Promise 构造函数的实现promise.then()/catch()的实现Promise.resolve()/reject()的实现Promise.all/race()的实现Promise.resolveDelay()/rejectDelay()的实现ES5 function 完整版本ES6 class 完整版本 async 与 awaitasync 函数 函数的返回结果为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定//和then方法返回规则一摸一样 async function main(){ //1. 如果返回值是一个非Promise类型的数据 // return 521; //2. 如果返回的是一个Promise对象 // return new Promise((resolve, reject) =&gt; { // // resolve('OK'); // reject('Error'); // }); //3. 抛出异常 throw \"Oh NO\"; //[PromiseState]]: \"rejected\" [PromiseResult]]: \"Oh NO\" } let result = main(); console.log(result); await 表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 async function lala(){ let p = new Promise((resolve, reject) =&gt; { // resolve('OK'); reject('Error'); }) //1. 右侧为promise的情况 await 返回的是 promise 成功的值即 'ok' // let res = await p; // console.log(res); //ok //2. 右侧为其他类型的数据 //let res2 = await 20; //console.log(res2); //20 //3. 如果promise是失败的状态 try{ let res3 = await p; }catch(e){ console.log(e); //抛出一个错误 使用try...catch } } lala() async与await结合/** * 读取同级目录resource文件夹下 有1.html 2.html 3.html 的文件内容 想去读取到 */ const fs = require('fs'); const util = require('util'); // util里有个方法可以将api转换成一个Promise形态的函数 const mineReadFile = util.promisify(fs.readFile); //回调函数的方式 // fs.readFile('./resource/1.html', (err, data1) =&gt; { // if(err) throw err; // fs.readFile('./resource/2.html', (err, data2) =&gt; { // if(err) throw err; // fs.readFile('./resource/3.html', (err, data3) =&gt; { // if(err) throw err; // console.log(data1 + data2 + data3); //读取到文件信息 // }); // }); // }); //async 与 await方式 就用不到回调函数 // 1.首先写一个async函数 async function main(){ try{ //2.读取第一个文件的内容 let data1 = await mineReadFile('./resource/1x.html'); let data2 = await mineReadFile('./resource/2.html'); let data3 = await mineReadFile('./resource/3.html'); console.log(data1 + data2 + data3); }catch(e){ // console.log(e); // Error: ENOENT: no such file or directory...... console.log(e.code); // ENOENT } } main(); async与await结合发送AJAX&lt;button id=\"btn\"&gt;点击获取段子&lt;/button&gt; &lt;script&gt; //一般使用axios封装好的 function sendAJAX(url){ return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.responseType = 'json'; xhr.open(\"GET\", url); xhr.send(); //处理结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //成功的结果 resolve(xhr.response); }else{ reject(xhr.status); } } } }); } //段子接口地址 https://api.apiopen.top/getJoke let btn = document.querySelector('#btn'); btn.addEventListener('click',async function(){ //获取段子信息 let duanzi = await sendAJAX('https://api.apiopen.top/getJoke'); //发送ajax请求的函数返回的结果是一个Promise对象 console.log(duanzi); }); &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"Ajax学习","slug":"02-ajax学习","date":"2022-04-14T02:22:11.000Z","updated":"2022-06-16T03:35:06.667Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://wuzimo233.github.io/posts/2.html","excerpt":"","text":"认识 Ajax什么是 Ajax Ajax 是一种异步请求数据的 web 开发技术，对于改善用户的体验和页面性能很有帮助。刚好回顾下什么是异步同步，大部分的请求是同步的，就是说我必须等待后台请求给我返回结果了才能往下操作。通俗讲的话，我要去烧水、水热了后去洗碗、扫地。同步来做的话就是依次等待水烧热后我再去洗碗，洗了碗后我再去扫地。异步做的话我把水壶接通电源（发送请求）、接着水壶它烧它的，我去扫地了，可能扫完地后水热了，再用水壶的水来洗碗。还可以说我今天一天没有逛朋友圈，晚上终于有空翻朋友圈，好不容易翻到了上午的朋友圈，突然觉得某个动态有意思我想评论一下或者点赞，如果页面上有刷新，那我点赞后直接就刷新了朋友圈，我又得从新翻很久才能回到刚才的动态页面。如果是不会刷新，即点赞后马上就显示了点赞记录。这就是无刷新技术通过Dom操作来实现的效果。所以Ajax通常会结合Dom一起操作。简单地说，在不需要重新刷新整个页面的情况下，Ajax 通过异步请求加载后台数据，能在网页的局部更新数据。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax 的目的是提高用户体验，较少网络数据的传输量。同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。AJAX=Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)Ajax 不是一门编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术 传统的网页(即不用 ajax 技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。 增加 B/S 体验性 （B/S 未来的主流，持续增长） Ajax 原理是什么在解释 Ajax 原理之前，我们不妨先举个 “领导想找小李汇报一下工作” 例子，领导想找小李问点事，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作。 Ajax 请求数据流程与“领导想找小李汇报一下工作”类似。其中最核心的依赖是浏览器提供的 XMLHttpRequest 对象，它扮演的角色相当于秘书，使得浏览器可以发出 HTTP 请求与接收 HTTP 响应。浏览器接着做其他事情，等收到 XHR 返回来的数据再渲染页面。 理解了 Ajax 的工作原理后，接下来我们探讨下如何使用 Ajax 利用 AJAX 可以做：注册时，输入用户名自动检测用户已经存在登陆时，提示用户密码错误删除数据时，将行 ID 发送到后台，后台在数据库中删除，数据库删除成功后，在页面 DOM 中将数据行也删除我们可以使用前端的一个标签来伪造一个 ajax 的样子。iframe 标签 &lt;!-- iframe 元素会创建包含另外一个文档的内联框架（即行内框架） --&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function () { var myDate = new Date(); //获取当前时间 并传递给p标签里的span document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage() { var targetUrl = document.getElementById('url').value; //获取input框的网址 console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; //把网址传给内联标签iframe标签的src属性 } &lt;/script&gt; 这里简单的制造了一个在当前页面打开其他页面不刷新整体页面的场景，ajax 可以实现更多更高级的类似功能 Ajax 的使用原生Ajax 的使用1.创建 Ajax 核心对象 XMLHttpRequest(记得考虑兼容性) var xhr=null; if (window.XMLHttpRequest) { // 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); } else { // 兼容 IE6, IE5 xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 2.向服务器发送请求 xhr.open(method,url,async); send(string);//post请求时才使用字符串参数，否则不用带参数。 。。。太麻烦了 后期再学原生吧 jQuery.ajax 的使用浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery Ajax 本质就是 XMLHttpRequest，对他进行了封装，方便调用！纯 JS 原生实现 Ajax 暂时不去了解了，直接使用 jquery 提供的，方便学习和使用，避免重复造轮子，有空再去了解下 JS 原生 的XMLHttpRequest把···Ajax 的核心是XMLHttpRequest对象(XHR)。XHR 为向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。 使用 jQuery 需要先从官网下载jQuery.js并导入到文件就可以使用$符号，它是jquery中代表jquery对象的引用,“jQuery”是核心对象。通过该对象可以获取jQuery对象，调用jQuery提供的方法等。$ &lt;==&gt; jQuery 通过 jQuery AJAX 方法，能够从远程服务器上请求文本、HTML、XML 或 JSON – 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery 中发起 Ajax 请求最常用的三个方法如下：$.get()$.post()$.ajax() $.get()函数的语法 jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求 将服务器上的资源请求到客户端来进行使用。 $.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 $.get()发起不带参数的请求使用 $.get() 函数发起不带参数的请求时，直接提供请求的 URL 地址和请求成功之后的回调函数即可，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', function(res) { console.log(res) // 这里的 res 是服务器返回的数据 }) $.get()发起带参数的请求使用 $.get() 函数发起带参数的请求时，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function(res) { console.log(res) }) $.post()函数的语法 jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。 $.post() 函数的语法如下： $.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 使用 $post() 向服务器提交数据的示例代码如下： $.post( 'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址 { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据 function(res) { // 回调函数 console.log(res) } ) $.ajax()函数的语法 相比于$.get()和$.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数 它允许我们对 Ajax 请求进行更详细的配置 $.ajax() 函数的基本语法如下： $.ajax({ type: '', // 请求的方式，例如 GET 或 POST url: '', // 请求的 URL 地址 data: { },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) 使用$.ajax()发起GET请求使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 ‘GET’ 即可： $.ajax({ type: 'GET', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址 data: { id: 1 },// 这次请求要携带的数据 success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) 使用$.ajax()发起POST请求使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 ‘POST’ 即可： $.ajax({ type: 'POST', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的 URL 地址 data: { // 要提交给服务器的数据 bookname:&nbsp;'水浒传', author:&nbsp;'施耐庵', publisher:&nbsp;'上海图书出版社' }, success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) jQuery.ajax(…) 部分参数： url：请求地址（待载入页面的URL地址） data：要发送的数据（待发送给后台的值key/value参数） success：载入成功之后执行的回调函数(全局) type：请求方式，GET、POST（1.9.0之后用method） // 下边的了解下不常用 headers：请求头 contentType：即将发送信息至服务器的内容编码类型(默认: “application/x-www-form-urlencoded; charset=UTF-8”) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 “xml”: 将服务器端返回的内容转换成xml格式 “text”: 将服务器端返回的内容转换成普通文本格式 “html”: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 “script”: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 “json”: 将服务器端返回的内容转换成相应的JavaScript对象 “jsonp”: JSONP 格式使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 接口相关知识 接口的概念 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。例如：www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求)www.liulongbin.top:3006/api/addbook 添加图书的接口（POST请求） 分析接口的请求过程 通过GET方式请求接口的过程 通过POST方式请求接口的过程 Ajax的优缺点优点1.无刷新更新数据。AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。2.异步与服务器通信。AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。3.前端和后端负载平衡。AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。4.基于标准被广泛支持。AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 5.界面与应用分离。Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点1.AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。2.AJAX的安全问题。3.因为网络延迟需要给用户提供必要提示","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-04-12T17:17:00.000Z","updated":"2022-04-15T06:14:16.957Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wuzimo233.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？因为学习一些知识总是学了就忘，或者敲了不复习，记得手写笔记也根本不爱翻动。花了大半天时间搭建个博客来记录未来学到的知识，勤能补拙吧~ 展望博客我会整理一些个人所学的知识（前端方向和一些其它数码、科技、摄影先暂时想这么多）或生活方面有兴趣的事发到博客上。 关于博主普普通通的社畜。。 勇敢就是，在你还没开始的时候就知道自己会输，但依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。 ​ go on！","categories":[{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"GIT","slug":"GIT","permalink":"https://wuzimo233.github.io/tags/GIT/"},{"name":"项目","slug":"项目","permalink":"https://wuzimo233.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"小程序","slug":"小程序","permalink":"https://wuzimo233.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wuzimo233.github.io/tags/Vuex/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wuzimo233.github.io/tags/uni-app/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"},{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}