{"meta":{"title":"zimo","subtitle":"zimoの博客","description":"人要接受自己的有限性，人的逻辑、理性、阅读都是有限的，整个人就是在偏见之中。人这一生就是在走出偏见。","author":"Zimo","url":"https://wuzimo233.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-04-14T05:28:56.000Z","updated":"2022-04-16T01:46:42.290Z","comments":false,"path":"about/index.html","permalink":"https://wuzimo233.github.io/about/index.html","excerpt":"","text":"普通人埼玉“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：普通人琦玉（萌新up） QQ：2772459092 座右铭：昨日之深渊,今日之浅谈"},{"title":"分类","date":"2022-04-15T09:12:19.000Z","updated":"2022-04-15T09:30:45.183Z","comments":false,"path":"categories/index.html","permalink":"https://wuzimo233.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-04-15T09:38:28.000Z","updated":"2022-04-15T09:38:20.951Z","comments":false,"path":"comments/index.html","permalink":"https://wuzimo233.github.io/comments/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wuzimo233.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-15T09:33:49.000Z","updated":"2022-04-15T09:34:52.986Z","comments":true,"path":"link/index.html","permalink":"https://wuzimo233.github.io/link/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-15T18:40:45.848Z","updated":"2022-04-15T18:40:33.275Z","comments":true,"path":"bangumis/index.html","permalink":"https://wuzimo233.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://wuzimo233.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-15T09:09:39.000Z","updated":"2022-04-15T09:29:33.704Z","comments":false,"path":"tags/index.html","permalink":"https://wuzimo233.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-16T02:11:08.265Z","comments":false,"path":"List/movies/index.html","permalink":"https://wuzimo233.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-13T13:05:50.468Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wuzimo233.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-04-13T16:19:21.819Z","comments":false,"path":"List/music/index.html","permalink":"https://wuzimo233.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-16T02:11:10.000Z","updated":"2022-04-16T02:18:08.424Z","comments":false,"path":"List/videos/index.html","permalink":"https://wuzimo233.github.io/List/videos/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wuzimo233.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wuzimo233.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"Axios新版学习大纲","slug":"15-Axios新版学习大纲","date":"2022-06-16T03:12:00.000Z","updated":"2022-06-16T03:08:49.278Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://wuzimo233.github.io/posts/14.html","excerpt":"","text":"Axios入门HTTP相关MDN文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview HTTP请求报文请求行格式: method url 例如: GET/product_detail?id=2 或 POST / login 请求头（一般有多个请求头）Host: www.baidu.com Cookie: BAIDUID=AD3B0FA706E;BIDUPSID=AD3B0FA706; Content-Type: applicartion/x-www-from-urlencoded 或者 application/json 请求体 (get没有)username=tom&amp;pwd=123 {“username”:”tom”,”pwd”:123} HTTP响应报文响应行格式： status status Text 例如： 200 OK 或 404 Not Found 响应头（一般有多个）Content-Type：text/html;charset=utf-8 Set-Cookie:BD_CK_SAM=1;PATH=/ 响应体html/json/js/css/图片 常见的状态码200 OK 请求成功.。一般用于GET/POST请求 201 Created 已创建。成功请求并创建了新的资源 401 Unauthorized 未授权/请求用户的身份证 404 Not Found 服务器无法根据客户端请求找到资源 500 internal Serve Error 服务器内部错误，无法完成请求 请求方式与请求参数请求方式GET（索取）：从服务端读取数据 —– 查（R –Retrieve） POST（交差）：向服务端添加新数据 —– 增（C –Create） PUT：更新服务端已经存在的数据 —— 改（U –Update） DELETE：删除服务器端数据 —— 删（D –Delete） 请求参数query参数（查询字符串参数） 参数包含在请求地址中，格式为:/xxxx?name=tom&amp;age=18 敏感数据不要用query参数，因为参数是地址的一部分，比较危险 备注：query参数又称为查询字符串参数，编码方式为urlencoded params参数 参数包含在请求地址中，格式如下： http://localhost:3000/add_person/tom/18 敏感数据不要用params参数，因为参数是地址的一部分，比较危险 请求体参数（body） 参数包含在请求体中，可通过浏览器开发工具查看 常用的两种格式： 格式一：urlencoded格式 例如：name=tom&amp;age=18 对于请求头：Content-Type：application/x-www-from-urlencoded ​ 格式二：json格式 ​ 例如：{“name”:”tom”,”:age”:12} ​ 对应请求头：Content-Type：application/json 特别注意： GET请求不能携带请求体参数，因为GET请求没有请求体 理论上一次请求可以随意使用上述3种类型参数中的任何一种，甚至一次请求的3个参数可以用3种形式携带，但一般不这样做 一般来说我们有一些”约定俗成”的规矩: (1):例如 from 表单发送 post 请求时，自动使用请求体参数，用urlencoded编码 ​ (2):例如 jQuery 发送ajax-post请求时，自动使用请求体参数，用urlencoded编码 开发中请求到底发给谁？用什么方式？ 携带什么参数？ —要参考项目的API接口文档 API相关API的分类REST API（restful 风格的 API） 发送请求进行 CRUD（增查改删） 哪个操作由请求方式来决定 同一个请求路径可以进行多个操作 请求方式会用到 GET / POST / PUT / DELETE const express = require('express') // 实例一个app服务对象 const app = express() app.get('/person',(req,res)=&gt;{ res.send('一些人的数据给你了') }) app.post('/person',(req,res)=&gt;{ res.send('你成功的添加了一个人') }) app.put('/person',(req,res)=&gt;{ res.send('你成功的修改了一个人') }) app.post('/person',(req,res)=&gt;{ res.send('你成功的删除了一个人') }) app.listen(8090,(error)=&gt;{ if(!error) console.log('服务器开启成功了'); }) 非 REST API (restless 风格的 API) 请求方式不决定请求的 CRUD 操作 一个请求路径只对应一个操作 一般只有 GET / POST // 早些年都这么写，两个请求有4个路径 --不能清晰表达要干嘛 const express = require('express') // 实例一个app服务对象 const app = express() app.get('/get_person',(req,res)=&gt;{ res.send('一些人的数据给你了') }) app.post('/add_person',(req,res)=&gt;{ res.send('你成功的添加了一个人') }) app.post('/update_person',(req,res)=&gt;{ res.send('你成功的修改了一个人') }) // 请求方式不决定请求的 CRUD 操作 app.post('/delete_person',(req,res)=&gt;{ res.send('你成功的删除了一个人') }) app.listen(8090,(error)=&gt;{ if(!error) console.log('服务器开启成功了'); }) 使用 json-server 搭建 REST APIjson-server是什么？ 用来快速搭建REST API 风格的工具包 使用 json-server 在线文档：http:github.com/typicode/json-serrver 下载：npm install -g json-server - 目标根目录下创建数据库 **json** 文件：**db.json** { \"posts\": [ { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" } ], \"comments\": [ { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 } ], \"profile\": { \"name\": \"typicode\" } } - 启动服务器执行命令：json-server --watch db.json (watch可以省略 db可以改为任意喜欢的名字) #### 使用浏览器访问测试 http://localhost:3000/posts http://localhost:3000/comments http://localhost:3000/profile #### 使用postmon接口测试 **json-server服务器注意：** - postmon测试中发送PUT请求，能在请求体携带id参数（或者使用params携带id），不能用query参数携带id - postmon测试中发送DELETE请求，只能使用params携带参数（json-server模拟的服务器，id都得通过params携带，其他有请求体就用请求体，没有就正常使用params或者query） #### 一般 http 请求与 ajax 请求 - ajax请求是一种特别http请求 - 对服务器端来说，没有任何区别，区别在浏览器端 - 浏览器端发请求：只有XHR或fetch发出得才是ajax请求。其他所有得都是非ajax请求 - 浏览器端接收到响应 ​ （1） 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说得自动刷新/跳转页面 ​ （2）ajax 请求：浏览器不会对界面进行任何更新操作，只是调用监视得回调函数传入响应相关数据 ## axios的理解和使用 ### axios是什么 1.前端最流行的ajax请求库 2.react/vue官方都推荐使用axios发ajax请求 3.文档：https://github.com/axios/axios ### axios特点 1.基于Promise的异步ajax请求库 2.浏览器端/node端都可以使用 3.支持请求/响应拦截器 4.支持请求取消 5.请求/响应数据转换 6.批量发送多个请求 ### 使用axios发送ajax请求 - 终端打开准备好的server文件夹里使用api-doc工具制作的api文档 - 新建 '1_axios的基本使用.html' 文件，同时新建一个js文件夹存放axios.mini.js文件,引入到html里 **准备按钮、文本框** ```html &lt;button id=\"btn1\"&gt;点我获取所有人&lt;/button&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn2\"&gt;点我获取某个人&lt;/button&gt; &lt;input id=\"person_id\" type=\"text\" placeholder=\"请输入一个人的id\"&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn3\"&gt;点我添加一个人&lt;/button&gt; &lt;input id=\"person_name\" type=\"name\" placeholder=\"请输入一个人的名字\"&gt; &lt;input id=\"person_age\" type=\"age\" placeholder=\"请输入一个人的年龄\"&gt;&lt;br&gt;&lt;br&gt; &lt;button id=\"btn4\"&gt;点我更新一个人&lt;/button&gt; &lt;input id=\"person_update_id\" type=\"text\" placeholder=\"请输入一个人的id\"&gt; &lt;input id=\"person_update_name\" type=\"text\" placeholder=\"请输入名字\"&gt; &lt;input id=\"person_update_age\" type=\"text\" placeholder=\"请输入年龄\"&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=\"btn5\"&gt;点我删除一个人&lt;/button&gt; &lt;input id=\"person_delete_id\" type=\"text\" placeholder=\"请输入删除的id\"&gt; 获取按钮、文本框 const btn1 = document.getElementById('btn1') const btn2 = document.getElementById('btn2') const btn3 = document.getElementById('btn3') const personId = document.getElementById('person_id') const personName = document.getElementById('person_name') const personAge = document.getElementById('person_age') const btn4 = document.getElementById('btn4') const btn5 = document.getElementById('btn5') const personUpdateId = document.getElementById('person_update_id') const personUpdateName = document.getElementById('person_update_name') const personUpdateAge = document.getElementById('person_update_age') const personDeleteId = document.getElementById('person_delete_id') 获取所有人的信息 —发送GET请求 —不携带参数 // 获取所有人的信息 ---发送GET请求 ---不携带参数 btn1.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/persons', //请求地址 method: 'GET', //请求方式 }).then( (response) =&gt; { console.log('请求成功了',response.data)}, (error) =&gt; { console.log('请求失败了',error) } ) // 精简版 axios.get('http://localhost:5000/persons').then( response =&gt; {console.log('请求成功了',response.data)}, error =&gt; {console.log('请求失败了',error)} ) } // 如果只想获取到成功的值 可以使用await 方法更简单 btn1.onclick = async() =&gt; { const result = await axios.get('http://localhost:5000/persons') console.log(result.data) } 使用axios发送其他请求发送GET请求获取某个人—发送GET请求—携带query参数 //获取某个人---发送GET请求---携带query参数 btn2.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/person', method: 'GET', params: { id: personId.value }//此处写的是params，但携带的是query参数 }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { '请求失败了', error } ) // 精简版 axios.get('http://localhost:5000/person', { params: { id: personId.value } }).then( response =&gt; { console.log('成功了', response.data); }, error =&gt; { console.log('失败了', error); } ) } 发送POST请求添加一个人—发送POST请求—携带json编码参数 或 urlencoded编码 btn3.onclick = ()=&gt; { axios({ // 完整版 url:'http://localhost:5000/person', method:'POST', data:{name:personName.value,age:personAge.value} //携带请求体参数（json编码） }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { console.log('请求失败了', error); } ) // 精简版 axios.post('http://localhost:5000/person',`name=${personName.value}&amp;age=${personAge.value}`).then( // axios.post('http://localhost:5000/person',{name:personName.value,age:personAge.value}).then( response =&gt; {console.log('请求成功了',response.data)}, error =&gt; {console.log('请求失败了',error)} ) } 发送PUT请求 更新一个人—发送PUT请求—携带json编码参数 或 urlencoded编码 btn4.onclick = () =&gt; { // 完整版 axios({ url: 'http://localhost:5000/person', method: 'PUT', data: { id:personUpdateId.value, name:personUpdateName.value, age:personUpdateAge.value }, }).then( response =&gt; { console.log('请求成功了', response.data); }, error =&gt; { console.log('请求失败了', error); } ) //精简版 axios.put('http://localhost:5000/person',{ id:personUpdateId.value, name:personUpdateName.value, age:personUpdateAge.value }).then( response =&gt; { console.log('请求成功了', response.data) }, error =&gt; { console.log('请求失败了', error) } ) } 发送DELETE请求删除一个人—发送DELETE请求—携带params参数 btn5.onclick = ()=&gt; { axios({ url:`http://localhost:5000/person/${personDeleteId.value}`, method:'DELETE', }).then( (response)=&gt;{console.log('请求成功了',response.data);}, (error)=&gt;{console.log('请求失败了',error);} ) } 结论 axios调用的返回值是Promise实例 成功的值叫response，失败的值叫error axios成功的值是一个axios封装的response对象，服务器返回的真正数据在response.data中 携带query参数时，编写的配置项叫做params 携带params参数时，就需要自己手动拼在url中 axios常用配置项新建‘2_axios常用配置项.html’文件，引入‘axios.min.js’ &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //给axios配置默认属性 axios.defaults.timeout = 2000 axios.defaults.headers = {school:'atguigu'} axios.defaults.baseURL = 'http://localhost:5000' btn.onclick = ()=&gt;{ axios({ url:'/persons', //请求地址 method:'GET',//请求方式 //params:{delay:3000},//配置query参数 //data:{c:3,d:3},//配置请求体参数(json编码) //data:'e=5&amp;f=6',//配置请求体参数(urlencoded编码) //timeout:2000,//配置超时时间 //headers:{school:'atguigu'} //配置请求头 //responseType:'json'//配置响应数据的格式(默认值) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; axios常用语法新建’3_axios.create方法.html‘，引入‘axios.min.js’ axios.create(config) 根据指定配置创建一个新的axios, 也就是每个新axios都有自己的配置 新axios只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 为什么要设计这个语法? 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样 &lt;button id=\"btn3\"&gt;点我获取笑话信息&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn3 = document.getElementById('btn3') // 创建一个新的axios const axios2 = axios.create({ timeout:3000, //headers:{name:'tom'}, baseURL:'https://api.apiopen.top/api' }) //给原axios配置默认属性 axios.defaults.timeout = 2000 axios.defaults.headers = {school:'atguigu'} axios.defaults.baseURL = 'http://localhost:5000' btn3.onclick = ()=&gt;{ axios2({ url:'/getImages', method:'GET' }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; 拦截器函数/ajax请求/请求的回调函数axios请求拦截器 1.是什么？ 在真正发请求前执行的一个回调函数 2.作用： 对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等 新建’4_axios中的拦截器.html‘，引入‘axios.min.js’ &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //请求拦截器 axios.interceptors.request.use((config)=&gt;{ console.log('请求拦截器1执行了'); // 如果时间戳是偶数 就加上请求头 if(Date.now() % 2 === 0){ config.headers.token = 'atguigu' } console.log(config); return config }) btn.onclick = ()=&gt;{ axios.get('http://localhost:5000/persons').then( response =&gt; {console.log('成功了',response.data)}, error =&gt; {console.log('失败了',error);} ) } &lt;/script&gt; axios响应拦截器 1.是什么？ 得到响应之后执行的一组回调函数 2.作用： 若请求成功，对成功的数据进行处理 若请求失败，对失败进行统一的操作 &lt;button id=\"btn\"&gt;点我获取所有人&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') //响应拦截器 axios.interceptors.response.use( response =&gt; { console.log('响应拦截器成功的回调执行了',response); if(Date.now() % 2 === 0) { return response.data } else { return '时间戳不是偶数，不能给你数据' } }, error =&gt; { console.log('响应拦截器失败的回调执行了'); alert(error); return new Promise(()=&gt;{}) } ) btn.onclick = async ()=&gt;{ const result = await axios.get('http://localhost:5000/persons2') console.log(result); } &lt;/script&gt; ​ 取消请求&lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const {CancelToken} = axios //CancelToken能为一次请求“打标识” let cancel btn.onclick = async()=&gt;{ axios({ url:'http://localhost:5000/test1?delay=3000', cancelToken:new CancelToken((c)=&gt;{ //c是一个函数，调用c就可以关闭本次请求 cancel = c }) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; {console.log('失败了',error);} ) } btn2.onclick = ()=&gt;{ cancel() } &lt;/script&gt; 取消请求和拦截器配合使用 &lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') // axios里面有个isCancel方法专门用于判断错误，还是用户取消请求导致的不合理。使用{}取出isCancel const {CancelToken,isCancel} = axios //CancelToken能为一次请求“打标识” let cancel btn.onclick = async()=&gt;{ // 每次点击按钮的时候都问一下外边是否有cancel 有没有值 if(cancel){ cancel() } axios({ url:'http://localhost:5000/test1?delay=3000', cancelToken:new CancelToken((c)=&gt;{ //c是一个函数，调用c就可以关闭本次请求 cancel = c }) }).then( response =&gt; {console.log('成功了',response.data);}, error =&gt; { if(isCancel(error)){ //如果进入判断，证明：是用户取消了请求 console.log('用户取消了请求，原因是：',error.message); }else{ console.log('失败了',error); } } ) } btn2.onclick = ()=&gt;{ cancel('任性，就是不要了') } &lt;/script&gt; &lt;button id=\"btn\"&gt;点我获取测试数据&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const {CancelToken,isCancel} = axios //CancelToken能为一次请求“打标识” let cancel axios.interceptors.request.use((config)=&gt;{ if(cancel) cancel('取消了') config.cancelToken = new CancelToken((c)=&gt; cancel= c) return config }) axios.interceptors.response.use( response =&gt; {return response.data}, error =&gt; { if(isCancel(error)){ //如果进入判断，证明：是用户取消了请求 console.log('用户取消了请求，原因是：',error.message); }else{ console.log('失败了',error); } return new Promise(()=&gt;{}) } ) btn.onclick = async()=&gt;{ const result = await axios.get('http://localhost:5000/test1?delay=3000') console.log(result); } btn2.onclick = ()=&gt;{ cancel('任性，就是不要了') } &lt;/script&gt; 批量的发送请求&lt;script type=\"text/javascript\" &gt; const btn = document.getElementById('btn') btn.onclick = async()=&gt;{ axios.all([ axios.get('http://localhost:5000/test1'), axios.get('http://localhost:5000/test2?delay=3000'), axios.get('http://localhost:5000/test3'), ]).then( response =&gt; {console.log(response);}, error =&gt; {console.log(error);} ) } &lt;/script&gt; ​","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise新版学习大纲","slug":"14-Promise新版学习大纲","date":"2022-06-16T03:10:00.000Z","updated":"2022-06-16T03:08:01.374Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://wuzimo233.github.io/posts/14.html","excerpt":"","text":"Promise准备函数对象与实例对象​ 1.函数对象: 将函数作为对象使用时, 简称为函数对象。 ​ 2.实例对象: new 构造函数或类产生的对象, 我们称之为实例对象。 //函数对象 function Person (name,age){ this.name = name this.age = age } Person.a = 1 //将Person看成一个对象 这是给它添加一个a属性并且赋值为1 //实例对象 --p1是Person的实例对象 const p1 = new Person('老刘',18) console.log(p1); 注意：每一个函数对象有一个不可修改的属性叫name Person.name = 'tom' //这是错误的 因为name值是函数的名（Person） 回调函数的分类什么是回调？​ —①我们定义的函数，②我们没有调用，③最终函数执行了。 两种回调函数同步的回调函数:​ 理解: 立即在主线程上执行, 不会放入回调队列中。 ​ 例子: 数组遍历相关的回调函数 / Promise的executor函数 异步的回调函数:​ 理解: 不会立即执行, 会放入回调队列中以后执行（等主线程忙完） ​ 例子: 定时器回调 / ajax（成功、失败时）的回调 //演示同步的回调函数 let arr = [1,3,5,7,9] arr.forEach((item)=&gt;{ console.log(item); }) console.log('主线程的代码'); //演示异步的回调函数 setTimeout(()=&gt;{ console.log('@'); },2000) console.log('主线程'); 错误类型的说明 js中错误类型有详细的划分，这里进一步理解 JS 中的错误 (Error) 和错误处理 mdn文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error 错误的类型​ Error: 所有错误的父类型 （当发生错误时，将显示下方的子错误类型） ​ ReferenceError: 引用的变量不存在 ​ TypeError: 数据类型不正确 ​ RangeError: 数据值不在其所允许的范围内–死循环 ​ SyntaxError: 语法错误 //演示：ReferenceError: 引用的变量不存在 console.log(a); //演示：TypeError: 数据类型不正确 //（声明一个demo常量，并且赋值一个函数，demo函数是能够被调用的，值是undefined，然后undefined再调用函数,当然显示类型不正确） const demo = ()=&gt;{} demo()() //演示：RangeError: 数据值不在其所允许的范围内 //(声明一个变量demo并赋值一个函数给他，同时函数内部再调用自己（递归函数），然后执行demo函数，然后无限的执行就会超出栈范围) const demo = ()=&gt;{demo()} demo() //演示：SyntaxError: 语法错误 console.log(1; js中的错误处理​ 捕获错误: try{}catch(){} ​ 抛出错误: throw error 如何捕获一个错误？ try中放可能出现错误的代码，一旦出现错误立即停止try中代码的执行，调用catch，并携带错误信息 try { console.log(1); console.log(a); //js引擎捕获到错误 console.log(2); } catch (error) { console.log('代码执行出错了,错误的原因是：',error); } js中的错误处理_抛出错误 //如何抛出一个错误 function demo(){ const date = Date.now() if(date % 2 === 0){ console.log('偶数，可以正常工作'); }else{ throw new Error('奇数，不可以工作！') } } try { demo() } catch (error) { debugger; console.log('@',error); } 错误对象 message属性: 错误相关信息 stack属性: 记录信息 //演示：ReferenceError: 引用的变量不存在 console.log(a); //演示：TypeError: 数据类型不正确 const demo = ()=&gt;{} demo()() //演示：RangeError: 数据值不在其所允许的范围内 const demo = ()=&gt;{demo()} demo() //演示：SyntaxError: 语法错误 console.log(1; Promise的理解和使用Promise是什么？抽象表达:​ (1).Promise是一门新的技术(ES6提出的) ​ (2).Promise是 JS 中异步编程的新方案 ** (旧方案是谁? –**纯回调：只靠回调函数解决（ajax）) 具体表达:​ (1).从语法上来说: Promise是一个内置构造函数 ​ (2).从功能上来说: Promise的实例对象可以用来 封装一个异步操作，并可以获取其成功/失败的值 总结： Promise不是回调函数，是一个内置的构造函数，是程序员自己new调用的。 new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数 –该函数将在构造这个新Promise对象过程中，被构造函数执行 每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected) 每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending) executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收 ​ 1.调用resolve函数会： ​ (1).让Promise实例状态变为成功(fulfilled) ​ (2).可以指定成功的value –resolve(‘ok’) ​ 2.调用reject函数会： ​ (1).让Promise实例状态变为失败(rejected) ​ (2).可以指定失败的reason –reject(‘失败的原因’) &lt;script type=\"text/javascript\"&gt; //创建一个Promise实例对象 const p = new Promise((resolve,reject)=&gt;{ // resolve('ok') reject('失败的原因') // console.log(resolve); console.log(reject); }) console.log('@',p); //一般不把Promise实例做控制台输出 @ Promise {&lt;rejected&gt;: 'ok'} &lt;/script&gt; Promise的基本使用重要语法​ new Promise(executor) 构造函数 ​ Promise.prototype.then 方法 基本编码流程​ 1.创建Promise的实例对象(pending状态), 传入executor函数 ​ 2.在executor中启动异步任务（定时器、ajax请求） ​ 3.根据异步任务的结果，做不同处理： ​ 3.1 如果异步任务成功了： ​ 我们调用resolve(value), 让Promise实例对象状态变为成功(fulfilled),同时指定成功的value ​ 3.2 如果异步任务失败了： ​ 我们调用reject(reason), 让Promise实例对象状态变为失败(rejected),同时指定失败的reason ​ 4.通过then方法为Promise的实例指定成功、失败的回调函数，来获取成功的value、失败的reason ​ 注意：then方法所指定的：成功的回调、失败的回调，都是异步的回调。 关于状态的注意点：​ 1.三个状态: ​ pending: 未确定的——初始状态 ​ fulfilled: 成功的——调用resolve()后的状态 ​ rejected: 失败的——-调用reject()后的状态 ​ 2.两种状态改变 ​ pending ==&gt; fulfilled ​ pending ==&gt; rejected ​ 3.状态只能改变一次！！ ​ 4.一个promise指定多个成功/失败回调函数, 都会调用吗? &lt;script&gt; // 1.声明变量p，将Promise实例对象赋值给它,并且里边传入一个执行器函数executor --里边有两个参数resolve、reject const p = new Promise((resolve,reject)=&gt;{ // 2.函数体 setTimeout(() =&gt; { resolve('我是服务器返回的数据') reject('我是一些错误信息') }, 2000); }).then( // 3.成功和失败后的回调 (value)=&gt;{console.log('成功了',value);}, //成功的回调-异步 (reason)=&gt;{console.log('失败了',reason);} //失败的回调-异步 ) console.log('@'); &lt;/script&gt; Promise与ajax配合使用&lt;!-- ajax配合使用 --&gt; &lt;script&gt; const p = new Promise((resolve,reject)=&gt;{ // 真正开启一个异步任务 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt;{ if(xhr.readyState === 4) { //readyState为4代表接收完毕，接收的可能是：服务器返回的成功数据、服务器返回的错误 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ resolve(xhr.response) }else { reject('请求出错') } } } xhr.open('GET','https://api.apiopen.top/api/sentences') // !!将服务器数据转为json格式 xhr.responseType = 'json' xhr.send() }) p.then( (value)=&gt;{console.log('成功了1',value);}, //成功的回调-异步 (reason)=&gt;{console.log('失败了1',reason);} //失败的回调-异步 ) console.log('@'); &lt;/script&gt; Promise封装ajax请求需求： 每次请求都要输入很多数据比较麻烦因此定义一个 sendAjax() 函数，对xhr的 GET 请求进行封装： 1.该函数接收两个参数：url(请求地址)、data(参数对象) 2.该函数返回一个Promise实例 ​ (1).若ajax请求成功,则Promise实例成功,成功的value是返回的数据。 ​ (2).若ajax请求失败,则Promise实例失败,失败的reason是错误提示。 正常使用promise发送一个ajax请求： // 1.声明变量p，将Promise实例对象赋值给它,并且里边传入一个执行器函数executor --里边有两个参数resolve、reject const p = new Promise((resolve, reject) =&gt; { // 2.实例化 xhr const xhr = new XMLHttpRequest() // 3.绑定监听 xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) resolve(xhr.response) else reject('请求出错') } } xhr.open('GET', 'https://api.apiopen.top/api/getImages?page=0&amp;size=10') xhr.responseType = 'json' xhr.send() }) p.then( (value) =&gt; { console.log('成功了1', value); }, //成功的回调-异步 (reason) =&gt; { console.log('失败了1', reason); } //失败的回调-异步 ) console.log('@'); 使用函数封装后： // 1.定义函数，并准备俩参数接收地址和参数（data是参数对象） function sendAjax(url, data) { // 2.准备一个promise实例 const p = new Promise((resolve,reject) =&gt; { // 3.实例化 xhr const xhr = new XMLHttpRequest() // 4.绑定监听 xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response); } else { reject('请求出了问题'); } } } // 5.整理参数 --需将 page=0&amp;size=10 这种形式转化为 {page:0,size:10}这种形式才能放进地址中作为参数 let str = '' for (let key in data) { str += `${key}=${data[key]}&amp;` } str = str.slice(0, -1) xhr.open('GET', url + '?' + str) xhr.responseType = 'json' xhr.send( }) return p const x = sendAjax('https://api.apiopen.top/api/getImages',{page:0,size:10}) x.then( (data)=&gt;{console.log('成功了',data);}, (reason)=&gt;{console.log('失败了',reason);} ) 封装ajax请求（纯回调方式）需求： 定义一个sendAjax函数，对xhr的get请求进行封装 该函数接收4个参数：url(请求地址)、data(参数对象)、success(成功的回调)、error(失败的回调) &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;封装一个简单的ajax(纯回调)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; function sendAjax(url,data,success,error){ //实例xhr const xhr = new XMLHttpRequest() //绑定监听 xhr.onreadystatechange = ()=&gt;{ if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) success(xhr.response); else error('请求出了点问题'); } } //整理参数 let str = '' for (let key in data){ str += `${key}=${data[key]}&amp;` } str = str.slice(0,-1) xhr.open('GET',url+'?'+str) xhr.responseType = 'json' xhr.send() } sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ console.log('成功了',response); }, (err) =&gt;{console.log('第1次失败了',err);} ) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Promise的APIPromise构造函数:new Promise (executor) {} executor函数: 是同步执行的，(resolve, reject) =&gt; {}resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。说明: **excutor函数会在Promise内部立即同步调用,**异步代码放在excutor函数中。 Promise.prototype.then方法:Promise实例.then(onFulfilled,onRejected)onFulfilled: 成功的回调函数 (value) =&gt; {}onRejected: 失败的回调函数 (reason) =&gt; {}特别注意(难点)：then方法会返回一个新的Promise实例对象 验证then的返回值 //验证：then方法会返回一个新的Promise实例对象。(暂且不研究返回的这个新Promise实例状态怎么变化) const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(100) },1000) }) const x = p.then( value =&gt; {console.log('成功了',value);}, reason =&gt;{console.log('失败了',reason);} ) console.log('50'); console.log(x); // pomise {&lt;pending&gt;} Promise.prototype.catch方法: Promise实例.catch(onRejected)onRejected: 失败的回调函数 (reason) =&gt; {}说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected) //Promise.prototype.catch方法 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject(100) },1000) }) p.then( value =&gt; {console.log('成功了1',reason);}, reason =&gt; {console.log('失败了1',reason);} ) p.catch( reason =&gt; {console.log('失败了2',reason);} ) Promise.resolve方法: Promise.resolve(value)说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象备注：当状态为rejected是因为value的值可能是： (1)非Promise值 – 100、’abc’、{}、[] (2)Promise值 – Promise实例（此时值是传入的promise实例，值成功或者失败） 例子：Promise.resolve方法生成了一个状态为失败的Promise对象实例 p //Promise.resolve const p0 = Promise.reject(-100) const p = Promise.resolve(p0) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.reject方法: Promise.reject方法(reason)说明: 用于快速返回一个状态必为rejected的Promise实例对象 例子：Promise.reject方法即使传入一个状态为成功的Promise对象实例值也是失败的 即失败的原因是那个成功的promise对象实例 //Promise.reject const p0 = Promise.resolve(100) const p = Promise.reject(p0) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.all方法:Promise.all(promiseArr)promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。 //Promise.all const p1 = Promise.resolve('a') const p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('b') //有一个失败了就直接失败。 },500) }) const p3 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('c') },2000) }) const x = Promise.all([p1,p2,p3]) x.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise.race方法:Promise.race(promiseArr)promiseArr: 包含n个Promise实例的数组 说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。 //Promise.race const p1 = Promise.reject('a') const p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('b') },500) }) const p3 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject('c') },2000) }) const x = Promise.race([p3,p1,p2]) x.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) Promise的几个关键问题：如何改变Promise实例的状态？ 执行resolve(value): 如果当前是pending就会变为fulfilled 执行reject(reason): 如果当前是pending就会变为rejected 执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected &lt;script type=\"text/javascript\" &gt; const p = new Promise((resolve,reject)=&gt;{ console.log(a); //浏览器引擎抛异常 // throw 900 //编码抛异常 }) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) &lt;/script&gt; 改变Promise实例的状态和指定回调函数谁先谁后? 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 //先指定回调，后改变状态（最常见） const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },4000) }) p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) 如何先改状态再指定回调? 延迟一会再调用then() //先改状态，后指定回调 const p = new Promise((resolve,reject)=&gt;{ resolve(100) }) setTimeout(()=&gt;{ p.then( value =&gt; {console.log('成功了',value);}, reason =&gt; {console.log('失败了',reason);} ) },2000) Promise实例什么时候才能得到数据? 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 then如何链式调用？Promise实例.then()返回的是一个【新的Promise实例】 它的值和状态由什么决定? 简单表达: 由then()所指定的回调函数执行的结果决定 详细表达: 如果then所指定的回调返回的是非Promise值a: ​ 那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a 如果then所指定的回调返回的是一个Promise实例p: ​ 那么【新Promise实例】的状态、值，都与p一致 如果then所指定的回调抛出异常: ​ 那么【新Promise实例】状态为rejected, reason为抛出的那个异常 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },1000) }) p.then( value =&gt; {console.log('成功了1',value); return Promise.reject('a')}, reason =&gt; {console.log('失败了1',reason);} ).then( value =&gt; {console.log('成功了2',value);return true}, reason =&gt; {console.log('失败了2',reason); return 100} ).then( value =&gt; {console.log('成功了3',value);throw 900}, reason =&gt; {console.log('失败了3',reason); return false} ).then( value =&gt; {console.log('成功了4',value);return -100}, reason =&gt; {console.log('失败了4',reason);} ) 纯回调会引起的问题？如下：可以发现代码非常的混乱，不利于查阅，且当再多发几次的请求后更加难以查阅 // 调用之前封装好的 sendAjax函数 sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调1 console.log('第一次成功了',response) sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调2 console.log('第二次成功了' ,response) sendAjax( 'https://api.apiopen.top/api/getImages', {page:0,size:10}, (response) =&gt;{ //成功的回调3 console.log('第三次成功了',response) }, (err) =&gt;{ // 失败的回调3 console.log('第三次失败了',err); } ) }, (err) =&gt;{ // 失败的回调2 console.log('第二次失败了',err); } ) }, (err) =&gt;{ // 失败的回调1 console.log('第1次失败了',err); } ) 使用then的链式调用解决回调地狱注意：then方法会返回一个新的Promise实例对象 但是因为其成功的value回调里还返回了 sendAjax()方法，该方法的返回值也是Promise实例对象，所以then返回的新Promise实例的状态、值，都与sendAjax()方法返回的promise一致 （详情见上方 ‘then如何链式调用‘ ） // 调用之前封装好的 sendAjax函数 （详情见上方 'Promise封装ajax请求'） //发送第1次请求 sendAjax('https://api.apiopen.top/api/getImages',{page:0}) /* 注意：then方法会返回一个新的Promise实例对象 但是因为其成功 的value回调里还返回了 sendAjax()方法，该方法的返回值也是 Promise实例对象，所以then返回的新Promise实例的状态、值， 都与sendAjax()方法返回的promise一致 （详情见上方 'then如何链式调用' ） */ .then( value =&gt; { console.log('第1次请求成功了',value); //发送第2次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第1次请求失败了',reason);} ) .then( value =&gt; { console.log('第2次请求成功了',value); //发送第3次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第2次请求失败了',reason);} ) .then( value =&gt; {console.log('第3次请求成功了',value);}, reason =&gt; {console.log('第3次请求失败了',reason);} ) 中断Promise链原因： 代码同上的时候，假如将发送第1次请求的地址写错后，第二次、第三次依然会因为种种原因继续执行。 思路： 当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。 办法: 在失败的回调函数中返回一个pendding状态的Promise实例。在每次reason后加上 ‘ return new Promise(()=&gt;{}) ’ 这样then返回的promise实例对象状态是pending就不会执行后边的value和reason 代码如下： .then( value =&gt; { console.log('第1次请求成功了',value); //发送第2次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第1次请求失败了',reason);return new Promise(()=&gt;{})} ) .then( value =&gt; { console.log('第2次请求成功了',value); //发送第3次请求 return sendAjax('https://api.apiopen.top/api/getImages',{page:0}) }, reason =&gt; {console.log('第2次请求失败了',reason);return new Promise(()=&gt;{})} ) .then( value =&gt; {console.log('第3次请求成功了',value);}, reason =&gt; {console.log('第3次请求失败了',reason);} ) Promise的错误穿透 当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调, 前面任何操作出了错误, 都会传到最后失败的回调中处理了 备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。 原理：底层帮我们在then里补上了一个失败的回调 reason =&gt; {throw reason} 又因为then所指定的回调抛出异常，那么新Promise实例状态为rejected, reason为抛出的那个异常 //另一个例子演示错误的穿透 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ reject(-100) },1000) }) p.then( value =&gt; {console.log('成功了1',value);return 'b'}, reason =&gt; {throw reason}//底层帮我们补上的这个失败的回调 ) .then( value =&gt; {console.log('成功了2',value);return Promise.reject(-108)}, reason =&gt; {throw reason}//底层帮我们补上的这个失败的回调 ) .catch( // reason =&gt; {throw reason} reason =&gt; {console.log('失败了',reason)} ) Promise的优势优势： 指定回调函数的方式更加灵活: ​ 旧的: 必须在启动异步任务前指定（如之前用jQuery封装的get请求，需要提前写好成功和失败的回调） ​ promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定) 支持链式调用, 可以解决回调地狱问题 ​ (1)什么是回调地狱： ​ 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件 ​ (2)回调地狱的弊病： ​ 代码不便于阅读、不便于异常的处理 ​ (3)一个不是很优秀的解决方案： ​ then的链式调用 ​ (4)终极解决方案： ​ async/await（底层实际上依然使用then的链式调用） async/await的使用 注意: ​ await必须写在async函数中, 但async函数中可以没有await ​ 如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try…catch来捕获处理 const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('a') }, 1000) }) const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('b') }, 2000) }) const p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('c') }, 4000) }) // async function demo() { /*当Promise实例对象p状态为失败时， 一旦try中的代码发生了抛异常， 将会携带异常来到catch，此时err就是抛出的'a' */ //（记得前边加分号） ; (async () =&gt; { // try中放可能存在错误的代码 try { const result1 = await p1 console.log('成功了', result1); const result2 = await p2 console.log('成功了', result2); const result3 = await p3 console.log('成功了', result3); } catch (error) { console.log('失败了',error); } })() await的应用（解决链式调用）//准备好一个 Promise封装好的发送ajax get请求的函数 --sendAjax(url,data) (async()=&gt;{ try { // 如果wait右侧的表达式为Promise实例对象，await后的返回值是promise成功的值 const result1 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第1次请求成功了',result1); const result2 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第2次请求成功了',result2); const result3 = await sendAjax('https://api.apiopen.top/api/getImages',{page:0}) console.log('第3次请求成功了',result3); } catch (error) { console.log(error); } })() async与await的规则 async修饰的函数 ​ 函数的返回值为promise对象 ​ Promise实例的结果由async函数执行的返回值决定 await表达式 ​ await右侧的表达式一般为Promise实例对象, 但也可以是其它的值 ​ (1).如果表达式是Promise实例对象, await后的返回值是promise成功的值 ​ (2).如果表达式是其它值, 直接将此值作为await的返回值 //测试async async function demo(){ const result = await p1 console.log(result); } demo() await原理 若我们使用async配合await这种写法： 1.表面上不出现任何的回调函数 2.但实际上底层把我们写的代码进行了加工，把回调函数“还原”回来了。 3.最终运行的代码是依然有回调的，只是程序员没有看见。 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('a') },4000) }) async function demo(){ //程序员“轻松”的写法 const result = await p console.log(result); console.log(100); console.log(200); } demo() console.log(1); //浏览器翻译后的代码 /* p.then( result =&gt; { console.log(result); console.log(100); console.log(200); }, ) */ 宏队列与微队列宏队列:[宏任务1，宏任务2…..] –如主线程上定时器就是宏任务 微队列:[微任务1，微任务2…..] –promise实例对象的then方法内就是微任务 规则：每次要执行宏队列里的一个任务之前，先看微队列里是否有待执行的微任务 1.如果有，先执行微任务 2.如果没有，按照宏队列里任务的顺序，依次执行 //代码一 setTimeout(()=&gt;{ console.log('timeout') },0) Promise.resolve(1).then( value =&gt; console.log('成功1',value) ) Promise.resolve(2).then( value =&gt; console.log('成功2',value) ) console.log('主线程') // 控制台结果 主线程 成功1 1 成功2 2 timeout //代码二 setTimeout(()=&gt;{ console.log('timeout1') }) setTimeout(()=&gt;{ console.log('timeout2') }) Promise.resolve(1).then( value =&gt; console.log('成功1',value) ) Promise.resolve(2).then( value =&gt; console.log('失败2',value) ) // 控制台结果 成功1 1 失败2 2 timeout1 timeout2 //代码三 setTimeout(()=&gt;{ console.log('timeout1') Promise.resolve(5).then( value =&gt; console.log('成功了5') ) }) setTimeout(()=&gt;{ console.log('timeout2') }) Promise.resolve(3).then( value =&gt; console.log('成功了3') ) Promise.resolve(4).then( value =&gt; console.log('成功了4') ) // 控制台结果 成功了3 成功了4 timeout1 成功了5 timeout2 经典面试题典型的先指定回调后改变状态 以下代码的执行流程： 首先可以判断是先指定回调再改变状态 主线程上的代码在飞速运行，new Promise后瞬间开始执行代码。然后执行器函数excuter是同步的回调函数，由于同步的回调函数不会往回调队列里边进，主线程上直接执行这些代码，瞬间开启一个定时器，那么setTimeout所指定的回调不是马上推入队列（除非到点了），而是放到浏览器的定时器管理模块，到点后定时器管理模块把setTimeout所指定的回调再推向宏队列，当主线程任务完成后才执行setTimeout所指定的回调。 再来看主线程，new Promise在主线程上使用后，执行器函数也是在主线程上执行，定时器setTimeout内置函数也是在主线程上飞速的执行完毕（而最重要的是setTimeout其里边的函数体需要到点后再推向队列），然后主线程开始执行p.then(),这其中有成功和失败的两个函数参数，是挂在实例自身上了。可以理解为只要是Promise实例对象，那么一出生身上就有个类似 P.list = []的结构，于是这里把成功和失败的回调推向这个里边（不是推向队列，因为还不知到上方状态的结果，除非是知道状态才去调用成功/失败的回调）一旦setTimeout内函数体从宏队列拉出执行，才发现状态是否成功。然后去自身找到之前缓存的成功/失败的回调。 const p = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ // 函数体 resolve('ok') },1000) }) p.then( (value)=&gt;{console.log(value);}, (reason)=&gt;{console.log(reason);} ) 典型的先改状态后指定回调 /* 典型的先改状态后指定回调 这个Promise实例对象一出生瞬间变为成功的状态，然后指定回调。即成功后直接把成功的回调推向了微队列。 （记住要执行的时候才进队列，等着主线程将它勾出来去执行） */ const p = new Promise((resolve,reject)=&gt;{ resolve('ok') }) p.then( (value)=&gt;{console.log(value);}, (reason)=&gt;{console.log(reason);} ) 面试题 判断出控制台的输出结果？ 注意：分析方法的注释是按照1~9顺序排列 // 1、立马反应setTimeout立即调用，但是不能进主线程而是进宏队列 宏队列保存 0 setTimeout(()=&gt;{ console.log('0'); },0) // 2、当主线程执行到此时，控制台输出 1，并且new一个Promise 判断出它是一个同步的回调 立刻马上输出1 且瞬间状态切换为成功 new Promise((resolve,reject)=&gt; { console.log('1'); resolve() // 3、状态成功后执行 .then()方法里的回调，但是！！这是属于异步回调，需要先推入微队列 微队列保存 2 }).then(()=&gt;{ /* 6、主线程分析完后,接着开始分析微队列 此时将2输出到控制台，此刻控制台为 1、7、2 此时微队列抹去 2 又 new了一个Promise，执行器在主线程运行马上输出3，同时resolve()将状态变为成功了 此刻控制台为 1、7、2、3 状态成功后，在.then()方法里有一个为其指定得成功得回调 ，!!注意这个回调也先得推入微队列,即把4所在 回调推入微队列.此时队列保存8、4 下一个.then()也是为左侧.then()返回得新Promise实例对象指定得回调,但是前一个实例的状态是由4所在 的回调来定义,而4目前还未执行，所以5就挂在了自身上不推入队列 此刻当前花括号内代码执行完毕,程序默认给Promise返回的值为undefined */ console.log('2'); new Promise((resolve,reject)=&gt; { console.log('3'); resolve() }).then(()=&gt;{ /* 9、接着将4所在的回调拉入主线程执行 输出4 此刻控制台为 1、7、2、3、8、4 如果4所在的回调执行了,那么就说明所在的.then的状态就敲定了,返回undefined 因为.then()左侧有了结果,就把 5 推入微队列 ,此时微队列保存6、5 接着将6(所在的回调)拿出队列,推入主线程,此刻控制台为 1、7、2、3、8、4、6 接着将5(所在的回调)拿出队列,推入主线程,此刻控制台为 1、7、2、3、8、4、6、5 最后 把宏队列的0(所在的回到)推入主线程,此刻控制台为 1、7、2、3、8、4、6、5、0 */ console.log('4'); }).then(()=&gt;{ console.log('5'); }) /* 4、这里的.then()不会推入队列，是因为它左侧的Promise实例还没有执行没有返回出结果，这里当然不能执 行，而是暂存放到左侧Promise实例身上 */ }).then(()=&gt;{ /* 7、因为.then左侧返回undefined,所以新Promise实例状态为成功, 成功的value为undefined 因为.then()左侧有了结果,就把 6 推入微队列 ,此时队列保存8、4、6 */ console.log('6'); }) /* 5、又 new了一次Promise 此时控制台先输出 1、7 ，因为直接改变状态为成功，意味着要去调用后边 的.then()方法，当然得先把.then()方法推向微队列 此时队列保存 2 8 */ new Promise((resolve,reject)=&gt;{ console.log('7') resolve() }).then(()=&gt;{ // 8、接着将8从队列拉出,此刻控制台为 1、7、2、3、8 此时队列保存4、6 console.log('8'); }) 包管理器的对比：仅用cnpm的仓库地址 使用yarn的命令 偶尔yarn网络不好，使用npm","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"AJAX新版学习大纲","slug":"13-AJAX新版学习大纲","date":"2022-06-16T03:08:00.000Z","updated":"2022-06-16T03:06:51.878Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://wuzimo233.github.io/posts/13.html","excerpt":"","text":"AJAX 入门AJAX 简介 AJAX全称为Asynchronous Javascript And XML，就是异步的 JS 和 XML。 通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：页面无刷新获取数据。 AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 ajax也是属于原生js的http请求，可以说是一种特殊的http请求。 在以往提交表单一般是这样子 &lt;body&gt; &lt;form action=\"https://www.baidu.com\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"pad\"&gt; &lt;!-- button按钮会触发表单的提交 --&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; XML简介 XML：可扩展标记语言 XML：被设计用来 传输和存储数据 比方说客户端（client）与 服务器（serve）前后台进行数据交互的时候，你想获取十条新闻，服务器就要给你十条新闻，那么关键是用的什么方式给你？ 于是服务器可以用XML这种字符串形式给你，XML本质就是字符串，不过有很多的规矩。 XML和HTML类似都是可扩展的标记语言，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据 例：用xml表示学生数据 &lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/student&gt; 可以发现体积较大了 现在已被JSON取代 例：用JSON表示学生数据 {\"name\":\"孙悟空\",\"age\":18,gender:\"男\"} AJAX 的特点AJAX 的优点 可以 **无需刷新页面与服务端进行通信 **获取数据 允许你根据用户事件来更新部分页面内容（例如淘宝鼠标移动到某个区域页面不刷新，但是部分区域内容更新） AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题（同源）–面试高频问题 SEO不友好（爬虫获取不到信息） AJAX 的使用核心对象:XMLHttpRequestAJAX的所有操作都是通过该对象进行的 搭建测试ajax的服务器新建任意名的文件夹（最好不用数字开头，不能有大写字母） 接着使用 yarn init （或者 npm init）将当前项目文件夹变成符合npm规范的包 使用 yarn express 安装express 项目文件夹下新建一个serve.js用来当作服务器 // 1. 引入express const express = require('express') // 2.创建一个app实例对象 const app = express() // 4.配置一个路由 （比如想响应get请求，就起一个 'test_get' 的名字 ,里面有两个对象，请求和响应） app.get('/test_get',(request,response)=&gt;{ // 函数体 response.send('hello_test_get!!!') }) // 3.绑定监听 端口号（一般4位数字） + 回调（err是错误对象，如果没有错误对象就证明服务器开启成功） app.listen(8080,(err)=&gt; { if(!err) console.log('测试ajax请求的服务器开启成功了'); }) 启动服务器（三种方式）：node serve / nodemon .\\serve.js / 使用第三方插件 Code Runner（右键 点击Run Code开启，快捷键 ctrl+alt+m 关闭服务） 浏览器地址栏输入查看：localhost:8080/test_get (浏览器默认是get请求) ajax小试牛刀ajax也是属于原生js的http请求，可以说是一种特殊的http请求。 项目根目录新建文件夹src，下新建 ‘1_ajax小试牛刀.html’文件，右键文件使用vscode的Live Server打开 //... &lt;style&gt; #content { width: 300px; height: 100px; border: 1px solid black; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是测试：ajax小试牛刀&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 2.指定发送请求的：method、url xhr.open('GET','http://localhost:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当点击按钮后控制台会报错，出现经典的跨域问题。（如果提示有…the serve responded with a status of 404 :5050/favicon.ico:1 (Not Found) 那么需要找一个ico图片放到项目文件根目录下即可） 解决跨域： 服务器中暴露静态资源 // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 4.配置一个路由 （比如想响应get请求，就起一个 'test_get' 的名字 ,里面有两个对象，请求和响应） app.get('/test_get',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get了'); response.send('hello_test_get!!!') }) // 3.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/1_ajax小试牛刀.html'); } }) 在html文件中将发送请求的url改成 ‘ http://127.0.0.1:8080/test_get ‘，然后不使用vscode的Live Server打开，而是复制到浏览器使用serve.js的 ‘http://127.0.0.1:8080/1_ajax小试牛刀.html’ 地址，同时要看到请求是否成功需要借助xhr的状态state来将xhr.response的结果返回给div中 &lt;h3&gt;该页面是测试：ajax小试牛刀&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xhr的5种状态（了解）复制’1_ajax小试牛刀.html’文件，改名为‘2_xhr的5种状态.html’，其他步骤和1文件类似方法打开 注意服务器需要再写一行 //方便复制 // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/1_ajax小试牛刀.html'); console.log('http://127.0.0.1:8080/2_xhr的5种状态.html'); //方便复制 } }) 页面html文件代码如下： //... &lt;h3&gt;该页面是测试：xhr的5种状态.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // xhr实例对象在实例出来的那一刻就是0,随着请求变化不断变化 /* xhr内部有5种状态,5种状态值分别为:0、1、2、3、4 0:实例出来的那一刻就是0,初始状态 1:open已经调用,但是send没有调用,此时可以修改请求头内容 2:send已经调用了,已经无法修改请求头 3:已经回来部分数据,小的数据会在此阶段一次性接收完毕,较大的数据有待进一步接收,响应头回来了. 4:数据全部接收完毕 // getAllResponseHeaders获取所有响应头 */ xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 1) { // xhr的请求头api setRequestHeader //配置请求头:请求头中增加 key:value // xhr.setRequestHeader('demo',123) // alert('@') } if(xhr.readyState === 2) { // xhr.setRequestHeader('demo',123) //配置请求头:报错 因为2阶段无法修改请求头了 } if(xhr.readyState === 3) { console.log('3时接收到的数据',xhr.response); console.log('3时接收到的响应头',xhr.getAllResponseHeaders()); } if(xhr.readyState === 4 &amp;&amp; (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：请求成功的判断最好详细一点 if(xhr.readyState === 4 &amp;&amp; (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)){ ​ //...... } ajax的get请求（掌握）复制’2_xhr的5种状态.html’文件，改名为‘3_ajax_get请求.html’，其他步骤和2文件类似方法打开 页面html文件代码: //... &lt;h3&gt;该页面是测试：ajax_get请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的GET请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } // 2.指定发送请求的：method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数的urlencoded编码形式 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET','http://127.0.0.1:8080/test_get?name=老刘&amp;age=18') //携带query参数 xhr.open('GET','http://127.0.0.1:8080/test_get2/老刘/18') //携带params参数 // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码 // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应GET请求 -query参数 app.get('/test_get',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get了--携带的query参数是：',request.query); response.send('hello_test_get!!!') }) // 3.响应GET请求 -params参数 app.get('/test_get2/:name/:age',(request,response)=&gt;{ // 函数体 // 这里设置一句话，检查是否有人请求了 console.log('有人请求test_get2了--携带的params参数是：',request.params); response.send('hello_test_get2!!!') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/3_ajax_get请求.html'); } }) ajax的post请求（掌握）复制’3_ajax_get请求.html’文件，改名为‘4_ajax_post请求.html’，其他步骤和3文件类似方法打开 页面html文件代码如下： //... &lt;h3&gt;该页面是测试：ajax_post请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的POST请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } // 2.指定发送请求的：method、url、参数 // post 可以携带query params参数 和请求体body（body有两种编码形式 urlencoded 、json） // xhr.open('POST','http://127.0.0.1:8080/test_post?name=tom&amp;age=18') // 携带query参数 xhr.open('POST','http://127.0.0.1:8080/test_post') // 不带参数 (参数放到下方请求体发送) // 追加响应头用于标识携带请求体参数的编码形式 --urlencoded 形式 // xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded') // 追加响应头用于标识携带请求体参数的编码形式 --json 形式 xhr.setRequestHeader('Content-type','application/json') // 3.发送请求 （post请求可以携带query、params参数，但是一般不带，而是放到请求体里面） 请求体里用urlencoded / json编码形式 const person = { name:'老刘', age:18 } // xhr.send('name=老刘&amp;age=18') //携带 urlencoded 编码形式的请求体参数 xhr.send(JSON.stringify(person)) //携带 json 编码形式的请求体参数 --使用JSON.stringify()方法将对象转为json格式 } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码： // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 使用中间件express.urlencoded() 解析urlencoded编码形式的请求体参数 // 简单说：如果想用express框架接收post请求所携带的请求体参数，需要借助中间件 express.urlencoded app.use(express.urlencoded({extended:true})) // 使用中间件解析json编码形式的请求体参数 app.use(express.json()) // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应POST请求 -请求体参数(后端需要占位符) app.post('/test_post',(request,response)=&gt;{ console.log('有人请求test_post了,携带的请求体参数是:',request.body); response.send('hello_test_post!!!') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/4_ajax_post请求.html'); } }) git相关操作克隆仓库 例：在一个名为student_ajax文件夹右键打开Git Bush Here 使用 git clone ‘仓库地址’，拿到公司代码 （此时克隆下来的文件里面有.git文件夹，该文件夹里边配置的是克隆的远程仓库的地址） 本地环境yarn 下载依赖 git add * –将文件放到暂存区 git commit -m ‘描述干啥事情了’ –对刚才的操作进行注释 目前文件仅在本地git仓库里，还需要推送到线上仓库 git push origin master 当线上主线文件更新了之后，支线需要下载主线的最新版本，使用 git pull origin master 拉取代码 那么这样拉取后本地文件将被线上文件覆盖，所以建议单独新建个文件夹存放克隆的的仓库，每次线上有更新就拉取代码到本地该文件夹里 借助vscode去操作git ajax解析json数据（了解）推荐安装FeHelper(前端助手)插件到浏览器。 新建’5_ajax_解析json数据.html’ 页面html文件代码如下： // ... &lt;h3&gt;该页面是：解析json数据.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') btn.onclick = ()=&gt; { // 1.实例化xhr对象 const xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); // 将json格式解析成对象 然后使用解构赋值 // 因为不知道后端那边的数据格式，假如后端是对象，直接使用JSON.parse（）就会报错 在3下方使用 xhr.responseType = 'json'解决 const {name,age,sex} = (xhr.response) content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person') // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 4.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码： // 1.引入express const express = require('express') // 2.创建app实例对象 const app = express() // 使用中间件express.urlencoded() 解析urlencoded编码形式的请求体参数 // 简单说：如果想用express框架接收post请求所携带的请求体参数，需要借助中间件 express.urlencoded app.use(express.urlencoded({extended:true})) // 使用中间件解析json编码形式的请求体参数 app.use(express.json()) // 5.解决跨域:暴露静态资源 app.use(express.static(__dirname+'/src')) // 3.响应get请求 app.get('/get_person',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'老刘',age:'18',sex:'女'} response.send(JSON.stringify(person)) //response.send('hello') }) // 4.监听 app.listen(8080,(err)=&gt; { if(!err) { console.log('测试ajax请求的服务器开启成功了!测试地址如下'); console.log('http://127.0.0.1:8080/5_ajax_解析json数据.html'); } }) 连续解构赋值&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 例子 想要得到c ？？ let obj = { a:1, b:{ c:2, }, } // 方法1 --标准的解构赋值得到 2 // const {c} = (obj.b) // console.log(c); / // 方法2 --连续解构赋值 // const {b:{c}} = obj // console.log(c); // 得到 2 // 新需求不喜欢用c名称，改为value // 连续解构赋值 + 重命名 const {b:{c:value}} = obj console.log(value); // 得到 2 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 处理IE浏览器-get请求缓存问题（了解）协商缓存 –一般浏览器中，当页面第一次向服务器发起请求后，服务器返回数据给页面，在控制台终端Network中可以看到请求的状态码是200。此时，当服务器中的数据更新（改变）后，页面第二次向服务器发起请求，页面数据随之变化，但是第三次点击按钮，控制台终端的状态码显示304（因为这次和上一次请求的地址都没有变化，浏览器会认为返回的信息依然和之前一样，但还是会问一问服务器，数据是否有变化，此时若服务器返回没有变化，那么浏览器会从自己缓存中读取数据，304就出现了） 所以也叫协商缓存。 但是！IE浏览器，在遇到该问题时候非常武断，直接不问服务器直接拿之前的数据给页面用。–IE的强缓存机制 解决方式：加上了时间戳参数，忽悠IE浏览器每次的请求地址不同。即使服务器接口没有参数，默认不处理请求来的参数。 // 指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person?t='+Date.now()) 请求异常与超时的处理新建’ 7_ajax请求的异常与超时处理.html ‘文件 页面html文件代码如下： &lt;h3&gt;该页面是：ajax请求的异常与超时处理.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') btn.onclick = function(){ // 1.实例化xhr对象 const xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay?t='+Date.now()) // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 网络不好的处理 --配置出错的回调 xhr.onerror = ()=&gt;{ alert('请求出错了，可能当前网络不稳定请稍后再试'); } //超时时间 --这个api意思是仅请求2秒，2秒后没有数据返回就取消请求 xhr.timeout = 2000 // 超时后的回调 xhr.ontimeout = () =&gt; { alert('网速不给力，请切换网络'); } // 4.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务器代码 // 3.响应get请求 --延时响应 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} // 3秒后返回数据 setTimeout(()=&gt;{ response.send(JSON.stringify(person)) },3000) }) ajax取消请求（掌握）新建 ’ 8_ajax取消请求.html ‘ 页面html文件代码如下： // ... &lt;h3&gt;该页面是：ajax取消请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;button id=\"btn2\"&gt;取消请求&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const btn2 = document.getElementById('btn2') const content = document.getElementById('content') let xhr btn.onclick = function(){ // 1.实例化xhr对象 xhr = new XMLHttpRequest() // 2.绑定监听 xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 3.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay?t='+Date.now()) // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 网络不好的处理 --配置出错的回调 xhr.onerror = ()=&gt;{ alert('请求出错了，可能当前网络不稳定请稍后再试'); } //超时时间 --这个api意思是仅请求2秒，2秒后没有数据返回就取消请求 xhr.timeout = 2000 // 超时后的回调 xhr.ontimeout = () =&gt; { alert('网速不给力，请切换网络'); } // 4.发送请求 xhr.send() // xhr.abort() //这里只要发送请求的次数多还是有概率会取消不了 } //点击第二个按钮后触发取消请求 btn2.onclick = function() { xhr.abort() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 3.响应get请求 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} response.send(JSON.stringify(person)) 如何避免用户发送重复请求（掌握）新建 ’ 9_避免多次重复请求.html ‘ 页面html文件代码如下： 思路：点击按钮前，定义一个isLoading变量 代码执行顺序：当第一次点击按钮后，先判断isLoading变量，为假就取消。然后实例化xhr，指定发送请求的格式参数，发送请求，接着关键一点就是将isLoading变量变为真，（这样当下次点击按钮时候，isLoading变量为真就会取消下次的请求）然后判断服务器那边的状态码将isLoading变量变为假。 // ... &lt;h3&gt;该页面是：避免多次重复请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的get请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn = document.getElementById('btn') const content = document.getElementById('content') let xhr // 声明一个变量，假如它为真代表正在发送请求中，就可以在之后取消请求 let isLoading // 每次点击按钮 xhr将被重新实例化，即每次都被替换成新的xhr对象 btn.onclick = function(){ // 这里代表第一次点击按钮 由于isLoading为undefin 所以不会取消请求 if(isLoading) xhr.abort() // 1.实例化xhr对象 xhr = new XMLHttpRequest() // 4. 这是判断服务器那边的状态码 （绑定监听） xhr.onreadystatechange = function(){ if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { isloading = false; console.log(xhr.response); const {name,age,sex} = xhr.response content.innerHTML = (` &lt;ul&gt; &lt;li&gt;姓名：${name}&lt;/li&gt; &lt;li&gt;年龄：${age}&lt;/li&gt; &lt;li&gt;性别：${sex}&lt;/li&gt; &lt;/ul&gt; `) } } } // 2.指定发送请求的：method、url (这里暂时不加参数) xhr.open('GET','http://127.0.0.1:8080/get_person_delay') // 因为不知道后端那边的数据格式， responseType用于指定返回数据的格式 xhr.responseType = 'json' // 3.发送请求 xhr.send() isLoading = true } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码: // 3.响应get请求 --延时响应 app.get('/get_person_delay',(request,response)=&gt;{ console.log('有人请求get_person了'); const person = {name:'海峰6',age:'18',sex:'女'} // 3秒后返回数据 setTimeout(()=&gt;{ response.send(JSON.stringify(person)) },3000) }) jQuery封装的ajax（了解）新建 ‘10_jquery封装的ajax.html’ 打开浏览器 –下载好jquerymini.js放到文件中引入 页面html文件代码如下： // ... &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是：jQuery封装的ajax.html&lt;/h3&gt; &lt;button id=\"btn1\"&gt;点我发送请求（jQuery-ajax-get）&lt;/button&gt; &lt;button id=\"btn2\"&gt;点我发送请求（jQuery-ajax-post）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const btn1 = $('#btn1') const btn2 = $('#btn2') const content = $('#content') btn1.click(() =&gt; { // 使用jQyuery发送get请求 --完整版写法 $.ajax({ url: 'http://127.0.0.1:8080/test_jquery_get', //请求地址 method: 'GET', //请求方式 --不写的话默认也是get data: { school: '麻省理工学院' }, //携带的数据 dataType: 'json', //配置响应数据格式 --将服务器拿到的json数据类型转换成对象 timeout:'2000', //指定超时的时间 // 成功的回调函数 success: (result, responseText, xhr) =&gt; { //第二个参数 responseText --代表本次响应（成功与否）的文字 第三个参数是xhr console.log(result, responseText, xhr); content.append(`&lt;div&gt;汽车名：${result.name},价格：${result.price}&lt;/div&gt;`) }, // 失败的回调 error: (xhr) =&gt; { //里边可以有 xhr参数 console.log('请求出错了'); } }) // 使用jQyuery发送get请求 携带query参数 --简版写法 // 如果是params请求 /test_jquery_get/bilibili // $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ // console.log(data); // },'json') }) btn2.click(() =&gt; { // 使用jQyuery发送 post请求 --完整版写法 $.ajax({ url: 'http://127.0.0.1:8080/test_jquery_post', //请求地址 method: 'POST', //请求方式 --不写的话默认也是get data: { school: '麻省理工学院' }, //携带的数据 dataType: 'json', //配置响应数据格式 --将服务器拿到的json数据类型转换成对象 timeout:'2000', //指定超时的时间 // 成功的回调函数 success: (result, responseText, xhr) =&gt; { //第二个参数 responseText --代表本次响应（成功与否）的文字 第三个参数是xhr console.log(result, responseText, xhr); content.append(`&lt;div&gt;汽车名：${result.name},价格：${result.price}&lt;/div&gt;`) }, // 失败的回调 error: (xhr) =&gt; { //里边可以有 xhr参数 console.log('请求出错了'); } }) // 使用jQyuery发送post请求 携带query参数 --简版写法 // 如果是params请求 /test_jquery_post/bilibili //$.post('http://127.0.0.1:8080/test_jquery_post',{school: '麻省理工学院' },(data)=&gt;{ //console.log(data); //content.append(`&lt;div&gt;汽车名：${data.name},价格：${data.price}&lt;/div&gt;`) //},'json') }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码 // 响应GET请求 --为jQuery准备： 接收query参数 如果是params参数 --'/test_jquery_get/:school' console.log('有人请求test_jquery_get了',request.params); app.get('/test_jquery_get',(request,response)=&gt;{ console.log('有人请求test_jquery_get了',request.query); const car= {name:'马自达.阿特兹',price:'25w'} response.send(JSON.stringify(car)) }) // 响应POST请求 --为jQuery准备： 响应体：request.body app.post('/test_jquery_post',(request,response)=&gt;{ console.log('有人请求test_jquery_post了',request.body); const car= {name:'马自达.阿特兹',price:'25w'} response.send(JSON.stringify(car)) }) 演示回调地狱（了解）新建 ’ 11_演示回调地狱.html ‘ &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;11_演示回调地狱.html&lt;/title&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;该页面是：演示回调地狱.html（看代码）&lt;/h3&gt; &lt;h3&gt;需求：点击按钮1之后发送一条请求，成功后发第二条，第二条成功后再发第三条，&lt;/h3&gt; &lt;button id=\"btn1\"&gt;点我发送请求（jQuery-ajax-get）&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; const btn1 = $('#btn1') btn1.click(() =&gt; { // 使用jQyuery发送get请求 携带query参数 --简版写法 $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); $.get('http://127.0.0.1:8080/test_jquery_get',{school: '麻省理工学院' },(data)=&gt;{ console.log(data); },'json') },'json') },'json') }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 跨域问题与同源策略总结：为什么有跨域问题？ 原因是浏览器为了安全，而采用的同源策略。 浏览器中有一个ajax引擎，只要xhr请求必须走ajax引擎，ajax引擎听一个叫同源策略的话，当前后端的端口不同时，浏览器阻止页面收到请求。 什么是同源策略？ 同源策略是由Netscape（网景公司）提出的一个著名安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。 Web是构建同源策略协议基础之上的，浏览器只是针对同源策略的一种实现。 所谓同源是指：协议、域名（IP），端口必须要完全相同。 ​ 即：协议、域名（IP）、端口都相同，才能算是在同一个域里 备注：规则举例如下（假设已有网站地址为：http://study.cn 不写端口号时，http会使用默认的） 请求地址： 形式 结果 http://study.cn/test/a.html 协议、域名、端口均相同 成功 http://study.cn/user/a.html 协议、域名、端口均相同 成功 http://a.study.cn/user/a.html 域名不同 失败 http://study.cn:8080/tset/a.html 域名不同 失败 http://study.cn/user/a.html 协议、域名、端口均相同 成功 https://study.cn/tset/a.html 协议不同 失败 没有同源策略的危险场景：危险场景： ​ 有一天，你刚睡醒，收到一封邮件，说你的银行账号有风险，赶紧点进www.yinghang.com改密码。你着急的赶紧点击进去，还是熟悉的银行登陆界面，你果断输入账号密码后，还没准备看里边的余额，睡眼朦胧的你想起了平时访问的银行网站是 www.yinhang.com,不是现在访问这个。随后你收到短信，钱没了，这个钓鱼网站做了什么呢？ 大概是如下思路： 新建 ’ 12_演示没有同源策略的危险场景.html ‘ &lt;iframe id=\"baidu\" src=\"https://www.baidu.com\"&gt;&lt;/iframe&gt; &lt;script type=\"text/javascript\"&gt; const iframe = window.frames['baidu'] const inputNode = iframe.document.getElementById('输入铭感信息的input的id') console.log(inputNode.value); &lt;/script&gt; 非同源受到哪些限制？ Cookie不能读取； DOM无法获得； Ajax请求不能获取数据； JSONP解决跨域（掌握）JSONP是什么 JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求 同源策略限制了xhr、Cookie、DOM，但是在网页有一些标签具有跨域能力，比如：img, link, iframe, scriptJ。SONP就是利用script标签的跨域能力来发送请求的 新建文件‘13_jsonp解决跨域.html’ 代码如下： 一切的前提是定义了demo()，当点击按钮后创建一个script节点并且src属性为请求的地址，将节点放入页面，最后在给window添加demo方法。 解决的原理是绕开了xhr，借助script标签发请求不收同源策略的限制。有一种前端定义函数，后端调用函数的感觉。 &lt;body&gt; &lt;!-- 这里的jquery可以发送跨域请求 --因为是在script的src下支持跨域 --&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = document.getElementById('btn') btn.onclick = () =&gt; { // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） scriptNode.src = 'http://localhost:8080/test_jsonp' // 3.将节点放入页面 document.body.appendChild(scriptNode) // 4.准备好一个函数 window.demo = (a) =&gt; { console.log(a); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应get请求 --为jsonp跨域准备 app.get('/test_jsonp',(request,response)=&gt;{ const person = {name:'tpm',age:18} // 想将一个对象变成字符有两种方式： // 1、toString() 方法 但是人类一般接受不了 --demo([object object]) // 2、JSON.stringify() 方法 response.send(`demo(${JSON.stringify(person)})`) }) 完善JSONP优化： 1、 假如前端的函数名更改了，后端也要更改一次就很麻烦 –需要优化写法 2、前边每次点击按钮都会动态创建了一个script标签 –需要移除已经使用过的script节点 页面代码： &lt;body&gt; &lt;!-- 这里的jquery可以发送跨域请求 --因为是在script的src下支持跨域 --&gt; &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，用jsonp解决问题&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = document.getElementById('btn') btn.onclick = () =&gt; { // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） 这里的key使用callback命名是因为前端请求，后端返回的数据是一段可以执行的js代码，这段代码触发了peiqi函数的调用 scriptNode.src = 'http://localhost:8080/test_jsonp?callback=peiqi' // 3.将节点放入页面 document.body.appendChild(scriptNode) // 4.准备好一个函数 window.peiqi = (a) =&gt; { console.log(a); } // 5.（优化）移除已经使用过的script节点 document.body.removeChild(scriptNode) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应get请求 --为jsonp跨域准备 app.get('/test_jsonp',(request,response)=&gt;{ const {callback} = request.query const person = [{name:'tpm',age:18},{name:'jery',age:'16'}] // 这样写的优势是前端的函数名随便更改，后端这里不需要改 response.send(`${callback}(${JSON.stringify(person)})`) }) JSONP面试问题：JSON 和 JSONP有关系吗？有一定关系，但是他俩是两回事儿。JSON是一种存储和交互的一种格式，JSONP是后端一种解决跨域的方式。他俩的关系是因为后端返回数据的时候，必须将数据变为JSON字符串。 用JSONP去解决跨域也是用到了xhr对吗？不对，JSONP解决跨域根本没用到xhr JSONP解决跨域有什么缺点？后端需要配合前端去拿到callback函数名，后端需要配合前端将数据变成JSON格式，后端需要配合前端写成函数调用的形式，简单来说前后端都挺麻烦。 jQuery封装的JSONP（了解）用jQuery去发送一个JSONP请求： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;14_jQuery封装的JSONP.html&lt;/title&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，用jQuery封装的JSONP解决&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script&gt; const btn = $('#btn') btn.click(()=&gt;{ $.getJSON('http://localhost:8080/test_jsonp?callback=?',{},(data)=&gt;{ console.log(data); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CORS （后端技术）解决跨域（掌握）CORS 是什么？​ CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS 怎么工作的？​ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。 CORS 的使用新建 ‘ 15_测试cors解决跨域.html ’文件 代码如下： // ... &lt;h3&gt;当前页面一定不要用服务器去打开，因为要制造跨域问题，测试cors解决跨域&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我获取数据&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300) { console.log(xhr.response); console.log(xhr.getAllResponseHeaders()); } } } // 2.指定发送请求的：method、url xhr.open('GET','http://127.0.0.1:8080/test_get') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ​ 主要是服务端的设置： // 3.响应GET请求 -可以接收query 参数 request,response --请求、响应对象 app.get('/test_get',(request,response)=&gt;{ console.log('有人请求test_get了--携带的query参数是：',request.query); response.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500') // 只允许这个 http://127.0.0.1:5500 网站进行跨域请求 response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 // response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 // 这里设置一句话，检查是否有人请求了 response.send('hello_test_get!!!') }) 发送 put 请求新建文件 ‘16_ajax_put请求.html’ 文件代码为： // ... &lt;h3&gt;该页面是测试：ajax_put请求.html&lt;/h3&gt; &lt;button id=\"btn\"&gt;点我发送请求（原生js里的ajax的PUT请求）&lt;/button&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 const btn = document.getElementById('btn') const content = document.getElementById('content') // 给按钮绑定监听 btn.onclick = () =&gt; { // 发送ajax请求 有如下几步： // 1.创建xhr实例对象 const xhr = new XMLHttpRequest() // 绑定监听 xhr.onreadystatechange = ()=&gt; { if(xhr.readyState === 4) { if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(xhr.response); content.innerHTML = `&lt;h3&gt;${xhr.response}&lt;/h3&gt;` } } } xhr.open('PUT','http://127.0.0.1:8080/test_put') // 3.发送请求 xhr.send() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端代码： // 响应 put请求 app.put('/test_put',(request,response) =&gt; { response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.send('hello_tset_put') }) 假如此时使用 open with live serve打开文件，将会显示跨域问题，即仅仅如上设置服务端是没有解决 put请求的跨域问题 –(预请求失败) 因为get、put属于http里的简单请求，不存在嗅探请求（也叫预请求 –在请求真正发出之前要进行一个预请求的动作 预解析 –在代码真正执行之前有人扫了一遍代码），put和delete有预请求这种嗅探请求。同时复杂请求可以检查服务器的性能，使用HTTP的OPTIONS方法，因此目前服务端没有写这个方法就会失败。所以可以在服务端的put请求之前再写一个options请求 // 预请求的方式 app.options('/test_put',(request,response)=&gt;{ response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Methods','*') // 预请求 这里代表哪些请求可以跨域 '*'代表任何请求都可以 response.send('我性能很好') }) // 响应 put请求 app.put('/test_put',(request,response) =&gt; { response.setHeader('Access-Control-Expose-Headers','*') // 把所有的响应头都交给跨域的网站 response.setHeader('Access-Control-Allow-Origin','*') // '*' 任何网站都可以来这个接口拿数据 response.send('hello_tset_put') }) 总结：掌握的需要掌握，了解的需要了解","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"","slug":"zimo后台管理-详细大纲","date":"2022-05-26T07:29:06.527Z","updated":"2022-06-16T03:09:31.092Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://wuzimo233.github.io/posts/0.html","excerpt":"","text":"项目的技术栈展示 以及项目的核心重点部分 项目搭建+使用element实现首页布局 顶部导航菜单及与左侧导航联动的面包屑实现 封装一个ECharts组件 封装一个Form表单组件和Table表格组件 企业开发之权限管理思路讲解 一、前置所需1、安装node.js进入官网下载Node.js 中文网 (nodejs.cn)node.js 2、安装 cnpm1、说明：npm（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 2、使用npm安装插件：命令提示符执行npm install 3、选装 cnpm 因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事！ 安装： npm install -g cnpm --registry=https://registry.npm.taobao.org 输入cnpm -v，可以查看当前cnpm版本 PS: yarn是个包管理器，是facebook发布的一款取代npm的包管理工具 //npm安装yarn npm install -g yarn 3、脚手架的搭建（命令行工具 cli）Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统 Vue CLI 的包名称由 vue-cli 改成了 @vue/cli。 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。 Node 版本要求： Vue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上)。你可以使用 n，nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 可以使用下列任一命令安装这个新的包： npm install -g @vue/cli # 或者 yarn global add @vue/cli 如果不喜欢当前的脚手架版本，可以使用以下代码回退（我使用的是cli 4.5.17版本） npm uninstall -g vue-cli #删除 npm install -g @vue/cli@4.5.17 #安装指定版本 4、创建项目vue create vue-manage-me 选择的是默认vue2.0安装 dafault (babel,eslint) 5、启动项目cd+项目名进入项目路径 使用npm run serve 运行 6、element-ui的使用 网页直接使用 脚手架中使用 全部引入 按需引入 1、网页直接使用是在html单文件中引入vue.js、element.css、element.js、和需要的便签组件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- import CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;el-button @click=\"visible = true\"&gt;Button&lt;/el-button&gt; &lt;el-dialog :visible.sync=\"visible\" title=\"Hello world\"&gt; &lt;p&gt;Try Element&lt;/p&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- import Vue before Element --&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;!-- import JavaScript --&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#app', data: function() { return { visible: false, } } }) &lt;/script&gt; &lt;/html&gt; 2 、脚手架全部引入在 main.js 中写入以下内容：缺点是打包后体积增加，优点是使用快捷方便 import Vue from 'vue'; import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import App from './App.vue'; Vue.use(ElementUI); new Vue({ el: '#app', render: h =&gt; h(App) }); 3 、脚手架局部引入在 main.js 中写入以下内容：需要用到什么组件便签就增加什么标签，缺点是较麻烦 import Vue from 'vue'; import App from './App.vue'; import {Button,Radio} from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(Button); Vue.use(Radio); Vue.config.productionTip = false new Vue({ el: '#app', render: h =&gt; h(App) }); 二、Vue Router路由的使用1、介绍：Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括： 嵌套路由映射 动态路由选择 模块化、基于组件的路由配置 路由参数、查询、通配符 展示由 Vue.js 的过渡系统提供的过渡效果 细致的导航控制 自动激活 CSS 类的链接 HTML5 history 模式或 hash 模式 可定制的滚动行为 URL 的正确编码 2、安装这里我安装的是指定的3.2.0版本 npm安装 npm install vue-router@3.2.0 yarn安装 yarn add vue-router@3.2.0 3、配置路由1、创建router文件夹在项目根目录创建router文件夹，并在其内创建路由的逻辑文件 index.js 2、引入 router里的index.js在main.js中引入 router里的index.js import Vue from 'vue'; import App from './App.vue'; import {Button,Radio} from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import router from '../router/index' //1.这里引入的index.js Vue.use(Button); Vue.use(Radio); Vue.config.productionTip = false new Vue({ router:router, //2.引入后要配置使用一下 el: '#app', render: h =&gt; h(App) }); 3、创建view文件夹在根目录创建view文件夹，并在其内创建Home.vue文件方便展示在页面观察有无路由效果 &lt;template&gt; &lt;div&gt; 我是home页面 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Home', data() { return {} } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 4、router的配置刚创建router文件夹其的逻辑文件 index.js ，步骤较多直接展示代码 // 路由逻辑文件 // 1.引入 vue 和 vue-router import Vue from 'vue' import VueRouter from 'vue-router' // 5.直接引入方式 --引入要用路由跳转的vue文件相对路径 如果使用按需引入方式这里可以注释 // import Home from '../views/Home.vue' // 2.全局引入 VueRouter Vue.use(VueRouter) // 4.路由详细的配置 --声明一个常量 routes 接收一个数组里面包括很多对象 const routes = [ { // 4-1. 匹配的路由地址 '/' 是指根目录 path:'/', // 4-2.取名 可选 使得根目录默认显示的是叫做Home的页面 name:'Home', // 4-3. 两种引入方式 直接引入 or 按需引入 // component: Home, --直接引入 component: ()=&gt; import('../views/Home.vue') } ] // 3.对VueRouter进行相关配置 --同时声明一个变量router 接收VueRouter实例 const router = new VueRouter ({ // 3-1.设置路由匹配模式 mode:'history', // 6.将routes传入 routes:routes, }) // 7.全局暴露router export default router 5、router-view在APP.vue文件夹内的 template 内使用 组件展示路由效果 同时可以再在view下创建一个User.vue文件 &lt;template&gt; &lt;div&gt; 我是user页面 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'User', data() { return {} } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 接着在路由index.js文件内routes添加一个user的对象属性， 同时可以再在view下创建一个User.vue文件 const routes = [ { path:'/', name:'Home', component: ()=&gt; import('../views/Home.vue') }, { path:'/user', name:'User', component: ()=&gt; import('../views/User.vue') //即当前routes内是如此 }, ] 6、router-link最后最重要的是去页面的App.vue或者其他页面上（当前作为展示的出口页面）写入 使其按下按钮后指向跳转的路径 成功即代表路由配置正确 &lt;template&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt; &lt;el-button type=\"primary\"&gt;首页按钮&lt;/el-button&gt; &lt;/router-link&gt; &lt;router-link to=\"/user\"&gt; &lt;el-button type=\"primary\"&gt;用户按钮&lt;/el-button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;/template&gt; 三、项目的页面布局1、首页架子的搭建使用的是container容器 在Home页面使用container容器 &lt;template&gt; &lt;div&gt; &lt;el-container style=\"height:100%\"&gt; &lt;el-aside width=\"auto\"&gt;Aside&lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Home\", data() { return {}; }, }; &lt;/script&gt; // 使用less 需要先下载引入 &lt;style lang=\"less\" scoped&gt; .el-header { background: pink; } .el-main { padding-top: 0; } &lt;/style&gt; 同时需要下载less 和less loader解析器 npm i less 和 npm i less-loader@5.0.0 如果有报错就根据提示安装需要的数据 当然因为是按需加载需要在main.js里添加刚才使用的组件 import Vue from 'vue'; import App from './App.vue'; import {Button,Radio,Container,Aside,Header,Main} from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import router from '../router/index' Vue.use(Button); Vue.use(Radio); Vue.use(Container); Vue.use(Aside); Vue.use(Header); Vue.use(Main); Vue.config.productionTip = false new Vue({ router:router, el: '#app', render: h =&gt; h(App) }); 2、侧边栏aside的实现使用的是NavMenu 导航菜单的样式 1、引入NavMenu因为是考虑其他页面也显示侧边栏在commponents文件夹下新建CommonAside.vue文件，并导入NavMenu 导航菜单的样式，记得展开菜单一下方便观察collapse改为false 当然还要再Home.vue文件里引入这个组件，注意在标签内要用小写，然后在main.js里导入element刚使用到的组件！（注意：驼峰命名改为小写字母＋中横线） &lt;template&gt; &lt;div&gt; &lt;el-container style=\"height: 100%\"&gt; &lt;!-- 左侧aside区域 --&gt; &lt;el-aside width=\"auto\"&gt; &lt;!-- 驼峰命名改为小写字母＋中横线 --&gt; &lt;common-aside&gt;&lt;/common-aside&gt; &lt;/el-aside&gt; &lt;!-- 右侧的头和main区域 --&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import CommonAside from \"../src/components/CommonAside.vue\"; export default { components: { CommonAside, }, name: \"Home\", data() { return {}; }, }; &lt;/script&gt; // 使用less 需要先下载引入 &lt;style lang=\"less\" scoped&gt; .el-header { background: pink; } .el-main { padding-top: 0; } &lt;/style&gt; 2、一级菜单实现：在data里添加数据 [ { path: '/', name: 'home', label: '首页', icon: 's-home', url: 'Home/Home' }, { path: '/mall', name: 'mall', label: '商品管理', icon: 'video-play', url: 'MallManage/MallManage' }, { path: '/user', name: 'user', label: '用户管理', icon: 'user', url: 'UserManage/UserManage' }, { label: '其他', icon: 'location', children: [ { path: '/page1', name: 'page1', label: '页面1', icon: 'setting', url: 'Other/PageOne' }, { path: '/page2', name: 'page2', label: '页面2', icon: 'setting', url: 'Other/PageTwo' } ] } ] 在计算属性中添加两个方法获取有无子菜单的对象 computed:{ noChildren(){ // 对数据源过滤 判断data里有无子项目 没有的话就将它返回 return this.menu.filter(item =&gt; !item.children) }, hasChildren() { return this.menu.filter(item =&gt; item.children) } } 然后在第一个没有子菜单的el-menu-item里遍历刚才计算属性的noChildren方法 记得引入icon组件在main.js中 &lt;el-menu-item v-for=\"(item) in noChildren\" :index=\"item.path\" :key=\"item.path\"&gt; &lt;!-- item下有icon的图标 --&gt; &lt;i :class=\"'el-icon-' + item.icon\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;{{item.label}}&lt;/span&gt; &lt;/el-menu-item&gt; 3、二级菜单的实现&lt;template&gt; &lt;el-menu default-active=\"1-4-1\" class=\"el-menu-vertical-demo\" @open=\"handleOpen\" @close=\"handleClose\" :collapse=\"isCollapse\" &gt; &lt;h3&gt;zimo后台管理系统&lt;/h3&gt; &lt;!-- 一级菜单 --&gt; &lt;el-menu-item v-for=\"item in noChildren\" :index=\"item.path\" :key=\"item.path\" &gt; &lt;!-- item下有icon的图标 --&gt; &lt;i :class=\"'el-icon-' + item.icon\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;{{ item.label }}&lt;/span&gt; &lt;/el-menu-item&gt; &lt;!-- 二级菜单 --&gt; &lt;el-submenu v-for=\"item in hasChildren\" :index=\"item.icon\" :key=\"item.icon\"&gt; &lt;template slot=\"title\"&gt; &lt;i :class=\"'el-icon-' + item.icon\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;{{ item.label }}&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group v-for=\"subItem in item.children\" :key=\"subItem.path\"&gt; &lt;el-menu-item :index=\"subItem.path\"&gt; &lt;i :class=\"'el-icon-' + subItem.icon\"&gt;&lt;/i&gt; {{ subItem.label }} &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/template&gt; 4、menu样式和侧边栏跳转首先将左侧顶部的xx管理系统样式调整一下 &lt;style lang=\"less\" scoped&gt; .el-menu-vertical-demo:not(.el-menu--collapse) { width: 200px; min-height: 400px; } .el-menu { height: 100vh; border: none; h3 { color: #fff; text-align: center; line-height: 48px; } } &lt;/style&gt; 然后对左侧边栏背景色和选择样式进行调整 &lt;el-menu default-active=\"1-4-1\" class=\"el-menu-vertical-demo\" @open=\"handleOpen\" @close=\"handleClose\" :collapse=\"isCollapse\" background-color=\"#545c64\" #背景色 text-color=\"#fff\" #前景色 active-text-color=\"#ffd04b\" #选中色 &gt; 接着去掉顶部的百边需要在App.vue中调整 &lt;style&gt; #app { height: 100vh; } html, body { margin: 0; padding: 0; } &lt;/style&gt; 设置路由的点击跳转 –即点击首页或者商品管理后跳转到该页面上 在el-menu-item上添加一个点击事件@click=”clickMenu(item)”, &lt;!-- 一级菜单 --&gt; &lt;el-menu-item @click=\"clickMenu(item)\" v-for=\"item in noChildren\" :index=\"item.path\" :key=\"item.path\" &gt; &lt;!-- item下有icon的图标 --&gt; &lt;i :class=\"'el-icon-' + item.icon\"&gt;&lt;/i&gt; &lt;span slot=\"title\"&gt;{{ item.label }}&lt;/span&gt; &lt;/el-menu-item&gt; 并在methods中配置 clickMenu(item) { // 让路由地址名称后追加点击的路由名称路径 // 因为 router在router文件夹里全局引入了 这里可以直接使用 console.log(this.$router) this.$router.push({ name:item.name }) } 此时，对于Home页面不仅是首页，更像是一个公共的layout，所以将其改名为Main，并去路由名称修改一下，然后Main.vue文件里name也修改为Main 同时在views下新建home和user文件夹，里面分别再建index.vue文件，接着去路由配置文件里配置路由 // 4.路由详细的配置 --声明一个常量 routes 接收一个数组里面包括很多对象 const routes = [ { // 4-1. 匹配的路由地址 '/' 是指根目录 path:'/', // 4-2.取名 可选 name:'Main', // 4-3. 两种引入方式 直接引入 or 按需引入 // component: Home, --直接引入 component: ()=&gt; import('../views/Main.vue'), children:[ // 8. 增加路由 { path:'/home', name:'home', component:()=&gt; import('../views/home/index.vue') }, { path:'/user', name:'User', component: ()=&gt; import('../views/user/index.vue') }, ] }, ] 因为上边是嵌套路由写法所以还要使用router-view 展示在页面上 –去Main.vue中的main区域引入 &lt;template&gt; &lt;div&gt; &lt;!-- **在Home页面使用container容器** --&gt; &lt;el-container style=\"height: 100%\"&gt; &lt;!-- 左侧aside区域 --&gt; &lt;el-aside width=\"auto\"&gt; &lt;common-aside&gt;&lt;/common-aside&gt; &lt;/el-aside&gt; &lt;!-- 右侧的头和main区域 --&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt; &lt;!-- 展示嵌套路由的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; 3、顶栏header的实现首先在src下的assets引入资料中的images、less（包括了四个css样式文件，其中index.css文件将其他三个css文件进行了引入，所以在main.js中只需要引入index.css）import '../src/assets/less/index.less' 在components文件夹下新建CommonHeader.vue的文件， 然后Main.vue中引入CommonHeader.vue组件展示在页面上 CommonHeader.vue引入Dropdown组件样式详细代码如下：（记得去main.js中按需引入Dropdown的相关组件） &lt;template&gt; &lt;header&gt; &lt;div class=\"l-content\"&gt; &lt;el-button plain icon=\"el-icon-menu\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;h3 style=\"color: #fff\"&gt;首页&lt;/h3&gt; &lt;/div&gt; &lt;!-- Dropdown 右侧下拉菜单 --&gt; &lt;div class=\"r-content\"&gt; &lt;el-dropdown trigger=\"click\" size=\"mini\"&gt; &lt;span&gt;&lt;img :src=\"userImg\" class=\"user\" /&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;个人中心&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/header&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"CommonHeader\", data() { return { userImg: require(\"../assets/images/user.png\"), }; }, }; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; .user { } &lt;/style&gt; 1、header组件的样式使用flex布局 &lt;style lang=\"less\" scoped&gt; header { display: flex; height: 100%; justify-content: space-between; align-items: center; } .l-content { display: flex; align-items: center; .el-button { margin-right: 20px; } } .r-content { .user { width: 40px; height: 40px; border-radius: 50%; } } &lt;/style&gt; 2、header按钮侧边栏折叠（vuex）主要思路：是CommonAside.vue中控制el-menu中的 :collapse=”isCollapse” 值布尔值的切换，true为不展开，false为展开。 然后控制的按钮是CommonHeader.vue中的el-button，因为两个文件是兄弟组件，使用vuex来传递事件（当然还有其他简单的方法） 首先下载vux相关依赖 npm i vuex 在根目录新建store文件夹，其下新建index.js存放vuex数据， // 引入vue import Vue from 'vue' // 引入vuex import Vuex from 'vuex' // 引入模块 import tab from './tab' // 全局注入 Vue.use(Vuex) export default new Vuex.Store({ modules:{ tab } }) 在store文件夹下再新建tab.js 模块导入vuex数据 export default { // 在state里定义好数据用来控制展开的布尔值 state:{ isCollapse:false, }, // 在mutations里定义方法修改state的数据 mutations:{ collapseMenu(state) { state.isCollapse = !state.isCollapse } } } 在main.js中引入store import Vue from 'vue'; import App from './App.vue'; //1.引入store import store from '../store' Vue.config.productionTip = false new Vue({ // 2.注册store store:store, el: '#app', render: h =&gt; h(App) }); 在CommonAside.vue文件内计算属性增加一个获取vuex中的state里的isCollapse数据 computed: { //... // 获取vuex中的state数据 isCollapse(){ return this.$store.state.tab.isCollapse } }, 然后可以将原先定义在data里用于控制侧边栏展开与否的isCollapse删除，原因是上方计算属性已经有同名且拿到数据的isCollapse，已经通过上方模板里el-menu属性里的 :collapse=”isCollapse” 绑定 然后去CommonHeader.vue文件内定义个点击事件 &lt;template&gt; &lt;header&gt; //.... //1.定义点击事件 &lt;el-button plain icon=\"el-icon-menu\" size=\"mini\" @click=\"handleMenu()\"&gt;&lt;/el-button&gt; //.... &lt;/header&gt; &lt;/template&gt; &lt;script&gt; export default { //... methods:{ // 2.点击事件函数内使用 this.$store.commit（'mutations里方法名'） 修改state里isCollapse的布尔值取反 handleMenu(){ this.$store.commit('collapseMenu') } } } &lt;/script&gt; 最后解决一下展开侧边栏前后的管理系统名称长度 //使用三元表达式 如果isCollapse为真 即折叠的时候显示'后台两字'，否则为假显示'子墨后台管理系统' &lt;h3&gt;{{isCollapse ? '后台' : '子墨后台管理系统'}}&lt;/h3&gt; 5、主页home的实现1、用户头像部分使用element-ui的Layout组件 对views文件夹下的home/index.vue 布局 （依旧要去main.js中按需引入） &lt;template&gt; &lt;div&gt; &lt;!-- 使用Layout 布局 --&gt; &lt;!-- gutter : 栅格间隔 span : 栅格占据的列数 --&gt; &lt;el-row class=\"home\" :gutter=\"20\"&gt; &lt;el-col :span=\"8\" style=\"margin-top:20px\"&gt; &lt;!-- 卡片 --&gt; &lt;el-card shadow=\"hover\"&gt; &lt;div class=\"user\"&gt; &lt;img :src=\"userImg\"&gt; &lt;div class=\"userinfo\"&gt; &lt;p class=\"name\"&gt;Admin&lt;/p&gt; &lt;p class=\"access\"&gt;超级管理员&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"login-info\"&gt; &lt;p&gt;上次登录时间：&lt;span&gt;2022-05-26&lt;/span&gt;&lt;/p&gt; &lt;p&gt;上次登录地点：&lt;span&gt;成都&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'home', data() { return { userImg:require('../../src/assets/images/user.png') } } } &lt;/script&gt; 2、购买统计部分主要使用element-ui中的 table组件 （依旧要去main.js中按需引入相关组件） 将准备好的tableData数据存入打他中待会 使用 tableData: [ { name: 'oppo', todayBuy: 100, monthBuy: 300, totalBuy: 800 }, { name: 'vivo', todayBuy: 100, monthBuy: 300, totalBuy: 800 }, { name: '苹果', todayBuy: 100, monthBuy: 300, totalBuy: 800 }, { name: '小米', todayBuy: 100, monthBuy: 300, totalBuy: 800 }, { name: '三星', todayBuy: 100, monthBuy: 300, totalBuy: 800 }, { name: '魅族', todayBuy: 100, monthBuy: 300, totalBuy: 800 } ] //... &lt;!-- 购买统计卡片 --&gt; &lt;!-- data : 显示的数据 prop : 对应列内容的字段名， label : 显示的标题 --&gt; &lt;el-card style=\"margin-top: 20px; height: 460px\"&gt; &lt;el-table :data=\"tableData\"&gt; &lt;el-table-column v-for=\"(val,key) in tableLabel\" :key=\"key\" :prop=\"key\" :label=\"val\"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-card&gt; &lt;script&gt; export default { name: \"home\", data() { return { userImg: require(\"../../src/assets/images/user.png\"), tableData: [ { name: \"oppo\", todayBuy: 100, monthBuy: 300, totalBuy: 800, }, //... ], tableLabel:{ name:'课程', todayBuy:'今日购买', monthBuy:'本月购买', totalBuy:'总购买' } }; }, }; &lt;/script&gt; 3、订单统计和图表部分（布局）将这里准备好的countData数据存入data中，6个el-card盒子处遍历使用 countData: [ { name: \"今日支付订单\", value: 1234, icon: \"success\", color: \"#2ec7c9\", }, { name: \"今日收藏订单\", value: 210, icon: \"star-on\", color: \"#ffb980\", }, { name: \"今日未支付订单\", value: 1234, icon: \"s-goods\", color: \"#5ab1ef\", }, { name: \"本月支付订单\", value: 1234, icon: \"success\", color: \"#2ec7c9\", }, { name: \"本月收藏订单\", value: 210, icon: \"star-on\", color: \"#ffb980\", }, { name: \"本月未支付订单\", value: 1234, icon: \"s-goods\", color: \"#5ab1ef\", }, ], &lt;!-- 右侧区域 --&gt; &lt;el-col :span=\"16\" style=\"margin-top: 20px\"&gt; &lt;!-- 6个订单盒子 --&gt; &lt;div class=\"num\"&gt; &lt;el-card v-for=\"item in countData\" :key=\"item.name\" :body-style=\"{display:'flex',padding:0}\"&gt; &lt;i class=\"icon\" :class=\"`el-icon-${item.icon}`\" :style=\"{background:item.color}\"&gt;&lt;/i&gt; &lt;div class=\"detail\"&gt; &lt;p class=\"num\"&gt;￥{{item.value}}&lt;/p&gt; &lt;p class=\"text\"&gt;{{item.name}}&lt;/p&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;!-- 3个图表盒子 --&gt; &lt;el-card style=\"height:280px\"&gt;&lt;/el-card&gt; &lt;div class=\"graph\"&gt; &lt;el-card style=\"height:260px\"&gt;&lt;/el-card&gt; &lt;el-card style=\"height:260px\"&gt;&lt;/el-card&gt; &lt;/div&gt; &lt;/el-col&gt; 4、使用axios获取图表数据npm install axios下载 然后在 main.js 中引入 axios import http from 'axios' //axios不是插件，想全局中使用只能绑定在vue的原型上 Vue.prototype.$http = http 然后对axios二次封装 在项目根目录下新建api文件夹，并在其下新建axios.js文件 main组件的实现// mock数据模拟 import Mock from 'mockjs' // 图表数据 let List = [] export default { getStatisticalData: () =&gt; { //Mock.Random.float 产生随机数100到8000之间 保留小数 最小0位 最大0位 for (let i = 0; i &lt; 7; i++) { List.push( Mock.mock({ 苹果: Mock.Random.float(100, 8000, 0, 0), vivo: Mock.Random.float(100, 8000, 0, 0), oppo: Mock.Random.float(100, 8000, 0, 0), 魅族: Mock.Random.float(100, 8000, 0, 0), 三星: Mock.Random.float(100, 8000, 0, 0), 小米: Mock.Random.float(100, 8000, 0, 0) }) ) } return { code: 20000, data: { // 饼图 videoData: [ { name: '小米', value: 2999 }, { name: '苹果', value: 5999 }, { name: 'vivo', value: 1500 }, { name: 'oppo', value: 1999 }, { name: '魅族', value: 2200 }, { name: '三星', value: 4500 } ], // 柱状图 userData: [ { date: '周一', new: 5, active: 200 }, { date: '周二', new: 10, active: 500 }, { date: '周三', new: 12, active: 550 }, { date: '周四', new: 60, active: 800 }, { date: '周五', new: 65, active: 550 }, { date: '周六', new: 53, active: 770 }, { date: '周日', new: 33, active: 170 } ], // 折线图 orderData: { date: ['20191001', '20191002', '20191003', '20191004', '20191005', '20191006', '20191007'], data: List }, tableData: [ { name: 'oppo', todayBuy: 500, monthBuy: 3500, totalBuy: 22000 }, { name: 'vivo', todayBuy: 300, monthBuy: 2200, totalBuy: 24000 }, { name: '苹果', todayBuy: 800, monthBuy: 4500, totalBuy: 65000 }, { name: '小米', todayBuy: 1200, monthBuy: 6500, totalBuy: 45000 }, { name: '三星', todayBuy: 300, monthBuy: 2000, totalBuy: 34000 }, { name: '魅族', todayBuy: 350, monthBuy: 3000, totalBuy: 22000 } ] } } } } echarts 的基本使用&lt;script src=\"https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\"&gt;&lt;/script&gt; 订单echarts配置order:{ legend: { // 图例文字颜色 textStyle: { color: \"#333\", }, }, grid: { left: \"20%\", }, // 提示框 tooltip: { trigger: \"axis\", }, xAxis: { type: \"category\", // 类目轴 data: [], axisLine: { lineStyle: { color: \"#17b3a3\", }, }, axisLabel: { interval: 0, color: \"#333\", }, }, yAxis: [ { type: \"value\", axisLine: { lineStyle: { color: \"#17b3a3\", }, }, }, ], color: [\"#2ec7c9\", \"#b6a2de\", \"#5ab1ef\", \"#ffb980\", \"#d87a80\", \"#8d98b3\"], series: [], }, 用户配置user: { legend: { // 图例文字颜色 textStyle: { color: \"#333\", }, }, grid: { left: \"20%\", }, // 提示框 tooltip: { trigger: \"axis\", }, xAxis: { type: \"category\", // 类目轴 data: [], axisLine: { lineStyle: { color: \"#17b3a3\", }, }, axisLabel: { interval: 0, color: \"#333\", }, }, yAxis: [ { type: \"value\", axisLine: { lineStyle: { color: \"#17b3a3\", }, }, }, ], color: [\"#2ec7c9\", \"#b6a2de\"], series: [], }, 饼状图配置video: { tooltip: { trigger: \"item\", }, color: [ \"#0f78f4\", \"#dd536b\", \"#9462e5\", \"#a6a6a6\", \"#e1bb22\", \"#39c362\", \"#3ed1cf\", ], series: [], }, 面包屑导航思路面包屑是在head部分组件里,Tag标签虽然不再head部分组件里,但是它在整个管理后台系统中是会一直存在的，所以需要在Main.vue中。 这两块功能的实现,主要依赖Element-ui两个样式 Breadcrumb 面包屑 + Tag 标签 整个大致逻辑是这样的,首先是面包屑 首页 一定要存在的,接下来 侧边组件 点击某菜单,把这个数据存到vuex中，然后 头部组件 来获取vuex中这个数据并展示。 封装一个form表单组件简单form表单的应用&lt;template&gt; &lt;el-form ref=\"form\" :model=\"form\" label-width=\"80px\"&gt; &lt;el-form-item label=\"姓名\" &gt; &lt;el-input v-model=\"form.name\" style=\"width: 195px\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"国籍\"&gt; &lt;el-select v-model=\"form.region\" placeholder=\"请选择国籍\"&gt; &lt;el-option label=\"中国\" value=\"china\"&gt;&lt;/el-option&gt; &lt;el-option label=\"美国\" value=\"America\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"爱好\"&gt; &lt;el-checkbox-group v-model=\"form.type\"&gt; &lt;el-checkbox label=\"画画\" name=\"type\" &gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=\"吹泡泡\" name=\"type\"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=\"放风筝\" name=\"type\"&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=\"看佩琦\" name=\"type\"&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"onSubmit\" size=\"small\"&gt;立即创建&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { form: { name: '', region: '', type: [] } } }, methods: { onSubmit() { console.log('提交 -&gt; ' + this.form.name + \" \" + this.form.region + \" \" + this.form.type ); } } } &lt;/script&gt; 我们看一下现在项目中的form表单的组件 看了这个以后大家可以来想一想怎么做封装想的过程：这里的图片展示了两个from 表单两个form表单里面的item类型都不一样假设现在我们有一个封装好的commonFrom组件 那么这两个form表单的值应该是通过属性传递过来的 那么这里在传递的时候就有两份值 并且每一份值都不一样 这个时候传递的数据机构是什么样的你能想象的到吗？ 应该是 数组里面套对象 每个对象的类型都不一样 那么每个对象里面的类型对应的就是form item的类型 也就是说我们label对应的数据 待会是要传过来的那么我们设计这一部分的传过来的值是 这种类型的 [ { label: '姓名', type: 'input' }, { label: '年龄', type: 'input' }, ] 那下面我们来写代码commonForm.vue&lt;template&gt; &lt;!--是否行内表单--&gt; &lt;el-form ref=\"form\" label-width=\"100px\"&gt; &lt;!--标签显示名称--&gt; &lt;el-form-item v-for=\"item in formLabel\" :key=\"item.label\" :label=\"item.label\"&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;script&gt; export default { // formLabel 是标签数据 props: { formLabel: Array, }, }; &lt;/script&gt; &lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; User.vue&lt;template&gt; &lt;div&gt; &lt;common-form :formLabel=\"operateFormLabel\"&gt;&lt;/common-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import CommonForm from \"../../components/CommonFrom.vue\"; export default { components: { CommonForm, }, data() { return { operateFormLabel: [ { label: \"姓名\", type: \"input\", }, { label: \"年龄\", type: \"input\", }, ], }; }, }; &lt;/script&gt; 此时可以看到遍历出来了但是没有表单的类型 也就是input 框 select框这些 那么理所当然能都想到 刚刚传过来的值里面有type所以 根据type判断 那么就有了 CommonFrom.vue &lt;template&gt; &lt;!--是否行内表单--&gt; &lt;el-form ref=\"form\" label-width=\"100px\"&gt; &lt;!--标签显示名称--&gt; &lt;el-form-item v-for=\"item in formLabel\" :key=\"item.label\" :label=\"item.label\"&gt; &lt;!--根据type来显示是什么标签--&gt; &lt;el-input :placeholder=\"'请输入' + item.label\" v-if=\"item.type === 'input'\" &gt;&lt;/el-input&gt; &lt;el-switch v-if=\"item.type === 'switch'\"&gt;&lt;/el-switch&gt; &lt;el-date-picker type=\"date\" placeholder=\"选择日期\" v-if=\"item.type === 'date'\" value-format=\"yyyy-MM-dd\" &gt; &lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; 继续想一下 如果是select 肯定有 options 是需要遍历的 那么就会多套一层数据结构 &lt;el-select placeholder=\"请选择\" v-if=\"item.type === 'select'\"&gt; &lt;!--如果是select或者checkbox 、Radio就还需要选项信息--&gt; &lt;el-option v-for=\"item in item.opts\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; 此时我们考虑完了 type 接下来的就是表单双向绑定的值 应该怎么处理？肯定也是传过来父组件 传过来 值的类型依然是对象 User.vue data() { return { operateFormLabel: [ { label: \"姓名\", type: \"input\", }, { label: \"年龄\", type: \"input\", }, ], operateForm: { name: \"\", addr: \"\", age: \"\", birth: \"\", sex: \"\", }, }; }, CommonForm.vueexport default { // formLabel 是标签数据 // form是表单数据 props: { formLabel: Array, form: Object, }, }; 注意：在el-form上面 受:model控制所以&lt;el-form ref=\"form\" label-width=\"100px\" :model=\"form\"&gt; &lt;/el-form&gt; 思考 那么formitem上面的 v-model怎么对应起来呢 那我们在传上一个formLabel的时候 可以在对象的key值里面加一个与之对应 &lt;el-input v-model=\"form[item.model]\" :placeholder=\"'请输入' + item.label\" v-if=\"item.type==='input'\"&gt;&lt;/el-input&gt; operateFormLabel: [ { model: 'name', label: '姓名', type: 'input' }, { model: 'age', label: '年龄', type: 'input' }, { model: 'sex', label: '性别', type: 'select', opts: [ { label: '男', value: 1 }, { label: '女', value: 0 } ] }, { model: 'birth', label: '出生日期', type: 'date' }, { model: 'addr', label: '地址', type: 'input' } ], 预留一个插槽 下面的不一样的地方可以灵活的处理&lt;el-form-item&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/el-form-item&gt; &lt;common-form &gt; &lt;el-button type=\"primary\" @click=\"getList(searchFrom.keyword)\"&gt;搜索&lt;/el-button&gt; &lt;/common-form&gt; 表单是不是一行展示权限管理 登录权限 菜单权限 登录权限我们给系统添加一个登录凭证叫”token”，这个token在登录的时候通过接口请求将用户名和密码传给后端，后端再数据库中匹配成功后返回一个凭证，前端将token缓存起来，再调用接口时传给后端验证就建立了登录权限校验 Mock数据 permission import Mock from 'mockjs' export default { getMenu: config =&gt; { const { username, password } = JSON.parse(config.body) // 先判断用户是否存在 // 判断账号和密码是否对应 if (username === 'admin' &amp;&amp; password === 'admin') { return { code: 20000, data: { menu: [ { path: '/', name: 'home', label: '首页', icon: 's-home', url: 'home/index' }, { path: '/mall', name: 'mall', label: '商品管理', icon: 'video-play', url: 'mall/index' }, { path: '/user', name: 'user', label: '用户管理', icon: 'user', url: 'User/index' }, { label: '其他', icon: 'location', children: [ { path: '/page1', name: 'page1', label: '页面1', icon: 'setting', url: 'other/pageOne' }, { path: '/page2', name: 'page2', label: '页面2', icon: 'setting', url: 'other/pageTwo' } ] } ], token: Mock.Random.guid(), message: '获取成功' } } } else if (username === 'xiaoxiao' &amp;&amp; password === 'xiaoxiao') { return { code: 20000, data: { menu: [ { path: '/', name: 'home', label: '首页', icon: 's-home', url: 'home/index' }, { path: '/video', name: 'video', label: '商品管理', icon: 'video-play', url: 'mall/index' } ], token: Mock.Random.guid(), message: '获取成功' } } } else { return { code: -999, data: { message: '密码错误' } } } } }","categories":[],"tags":[]},{"title":"Vuex学习","slug":"12-Vuex学习","date":"2022-05-26T07:00:00.000Z","updated":"2022-05-26T07:25:52.768Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://wuzimo233.github.io/posts/13.html","excerpt":"","text":"Vuex学习1、Vuex是什么？1.介绍 ​ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 2.说明： ​ Vuex是vue组件之间数据传递的方式，任意组件都可以使用-类似大仓库 一般来说某个组件要用数据，可以调用Render读取Vuex中的数据，然后使用Dispatch调用Actions修改页面的数据，当然还有许多其他步骤，这只是最经典的动作（先读再操作）。Actions操作后会利用中间转接人Mutations去修改State， 2、安装Vuex 安装： cnpm install vuex --save 目前默认安装的是Vue3的vuex4版本，vue2需要安装指定版本，我使用的npm i vuex@3.6.2 main.js 全局引入 import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) ​ 3.创建store仓库​ 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state) ​ Vuex 和单纯的全局对象有以下两点不同： ​ 1. Vuex 的状态存储是响应式的，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 ​ 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation 最简单的 Store import Vue from 'vue' import App from './App.vue' import router from './router' // 1.引入Vuex import Vuex from 'vuex' Vue.config.productionTip = false // 2.使用Vuex Vue.use(Vuex) // 3.创建Vuex仓库 const store = new Vuex.Store({ // 4.共享的数据 state:{ user:'admin', } }) new Vue({ router, // 5.仓库放到（挂载）Vue实例上去 store, render: h =&gt; h(App) }).$mount('#app') 3、Vuex核心概念State1.介绍：​ 1. Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。 ​ 2.说明：state就是存储数据仓库 容器 2.获取state数据1、this 直接获取​ this.$store.state.xxx ​ 假如某个组件想获取刚才定义在Vuex中store仓库里state中的user数据，就可以通过this下的$store来找到 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', created(){ console.log(this); console.log(this.$store.state.user); //'admin' } } &lt;/script&gt; 2、mapState 辅助函数获取了解三个使用方式：三个辅助函数使用方法，不必掌握因为比较麻烦且不能复用计算属性 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; &lt;p&gt;mapState辅助函数 箭头函数 写法获取state数据：{{ user1 }}&lt;/p&gt; &lt;p&gt;mapState辅助函数 字符串 写法获取state数据：{{ user2 }}&lt;/p&gt; &lt;p&gt;mapState辅助函数 普通函数方法 写法获取state数据：{{ user3 }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.导入辅助函数 import { mapState } from 'vuex' export default { name: 'Home', data(){ return { msg:'你好', } }, // 2.使用计算属性获取state方法---了解 computed:mapState({ // 方式1、箭头函数写法（代码更简练） user1:state=&gt;state.user, // 方式2、传字符串参数 'count' 等同于 `state =&gt; state.count` user2:'user', // 方式3、为了能够使用 `this` 获取局部状态，必须使用常规函数 user3(state) { return state.user+'----'+this.msg; } }), } &lt;/script&gt; 需要掌握的使用方式：&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;p&gt;vuex-直接获取state数据：{{$store.state.user}}&lt;/p&gt; // 4.直接使用 &lt;p&gt;mapState辅助函数 字符串数组写法 获取state数据：{{ user }}--{{ count }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.导入辅助函数 import { mapState } from 'vuex' export default { name: 'Home', data(){ return { msg:'你好', } }, // 2.使用计算属性获取state方法---掌握 computed:{ //3.mapState 传一个字符串数组方法 ——名称要和vuex仓库里的数据名一致 因为是数据所以放在计算属性里 注意别和data里数据名重复 ...mapState(['user','count',]), }, } &lt;/script&gt; 当然直接把vuex放到main.js中不合适，可以单独在项目根下创建一个叫做store文件夹，里面创建一个index.js的文件 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 5.共享的数据 state:{ user:'admin', count:100, } }) // 6.导出 export default store 最后再在main.js中导入引入store import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ //路由挂载到vue实例 router, // 仓库放到（挂载到）Vue实例 store, render: h =&gt; h(App) }).$mount('#app') Mutations1.介绍​ 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation​ Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 2.语法4-2 处定义一个mutations对象，里面包含想修改state数据的方法 mutations里的方法有两个参数，比如 addCount(state,payload) –其中state是固定的state数据，payload是要携带的参数可以省略(参数可以是对象、字符串、数字) 无参数版 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{ user:'admin', count:100, }, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{ addCount(state){ state.count ++ }, reduceCount(state) { state.count -= 10 } }, }) // 5.导出 export default store 有参数版 mutations:{ addCount(state,num){ //增加了一个参数需要在使用的组件里添加具体参数 state.count += num }, reduceCount(state,{num}) { state.count -= num } }, }) --------------------------------------以下是其他组件需要使用muaations时携带参数的方法----------------------------------------------- &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', methods:{ add(){ // 使用commit()方法调用mutations里的方法去修改state数据 同时将参数10代入 this.$store.commit('addCount',10) //即当前每次点击增加10 }, reduce(){ this.$store.commit('reduceCount',{ num:8 }) } }, } &lt;/script&gt; 3.操作方法：1、直接操作mutations直接使用commit()方法调用mutations里的方法去修改state数据 在需要修改的组件里使用 this.$store.commit(state,payload) –state是定义在mutations里的方法名，payload是参数需要看mutations里的方法是否可以省略 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', methods:{ add(){ // 注意：不能直接修改 仓库不会同步视图 // this.$store.state.count = 200 // 使用commit()方法调用mutations里的方法去修改state数据 this.$store.commit('addCount',) }, reduce(){ this.$store.commit('reduceCount',) } }, } &lt;/script&gt; 2、辅助函数操作&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add2\"&gt;辅助函数+&lt;/button&gt; &lt;button @click=\"reduce2\"&gt;辅助函数-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 1.引入辅助函数 import { mapMutations } from 'vuex' export default { name: 'Home', methods:{ // 2.mapMutations 是方法所以放在methods里 ...mapMutations(['addCount','reduceCount']), add2(){ // 3.操作辅助函数 this.addCount(20) }, reduce2(){ this.reduceCount({ num:20 }) } }, } &lt;/script&gt; 3、Mutation 必须是同步函数一条重要的原则就是要记住 mutation 必须是同步函数 4、 Mutation 需遵守 Vue 的响应规则 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 1. 最好提前在你的 store 中初始化好所有所需属性。 1. 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, ‘newProp’, 123), 或者 以新对象替换老对象。例如，利用对象展开运算符 (opens new window)我们可以这样写： state.obj = { …state.obj, newProp: 123 } mutations:{ addCount(state,num){ state.count += num }, reduceCount(state,{num}) { state.count -= num }, // 修改已经存在的属性 changeUserinfo(state,payload){ state.userinfo.uname = payload.uname }, // 添加数据 addUserinfo(state,payload){ // 直接增加属性 数据会修改 但是视图不同步 // state.userinfo.love = payload.love; // 解决方式： // 1.提前定义好属性 // 2.Vue.set(obj,'属性','值') // 3.{...} // 4.Object.assign() Vue.set(state.userinfo,'love',payload.love) } }, 组件中使用： 当添加一个没有存在的属性 state会添加成功但是页面不会显示，因为对象里的属性地址是没有改变的vue检测不到 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;p&gt;获取userinfo数据:{{userinfo}}&lt;/p&gt; &lt;button @click=\"addobj\"&gt;对象添加一个不存在的属性&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState } from \"vuex\" export default ({ computed:{ ...mapState(['userinfo']) }, methods:{ change(){ // 直接修改state数据 this.$store.commit('changeUserinfo',{ uname:'zimo' }) }, // 当添加一个没有存在的属性 state会添加成功但是页面不会显示，因为对象里的属性地址是没有改变的vue检测不到 addobj(){ this.$store.commit('addUserinfo',{ love:'擦擦擦' }) } } }) &lt;/script&gt; 5、 使用常量替代 Mutation 事件类型使用常量替代 mutation中 事件类型（即方法的名称）在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 首先在store下新建js文件，里边写一个对象暴露出去 /* * 定义mutations事件类型：函数名称 定义常量 */ export const ADDCOUNT = 'ADDCOUNT'; 在需要用到mutations的组件里这样使用 &lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;我是home&lt;/h2&gt; &lt;h3&gt;mutations修改state数据&lt;/h3&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"reduce\"&gt;-&lt;/button&gt; &lt;button @click=\"add2\"&gt;辅助函数+&lt;/button&gt; &lt;button @click=\"reduce2\"&gt;辅助函数-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 辅助函数 import { mapState,mapMutations } from 'vuex' //1. 导入常量js import { ADDCOUNT, } from '../store/mutation-types.js' export default { name: 'Home', computed:{ ...mapState(['user','count',]), }, methods:{ // 2.辅助函数里也改成定义的常量名 ...mapMutations([ADDCOUNT,'reduceCount']), add(){ // 3.使用commit()方法调用mutations里的方法也要改为常量名 this.$store.commit(ADDCOUNT,10) }, reduce(){ this.$store.commit('reduceCount',{ num:8 }) }, add2(){ //4. 其他直接使用辅助函数＋的地方也改为常量名 this.ADDCOUNT(20) }, reduce2(){ this.reduceCount({ num:20 }) } }, } &lt;/script&gt; Action1、介绍​ Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 2、例子注册一个简单的 action： action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) 3、操作Action1.直接获取actionsthis.$store.dispatch('actions里的函数名') 2.辅助函数获取actions// 1.引入mapActions辅助函数 import { mapActions } from 'vuex' export default { // ... //2.在方法里面调用 methods: { ...mapActions(['increment']), add() { //3.使用辅助函数里的方法 this.increment(100) } } } 4、实际上手练习1.定义actions对象首先在vuex文件下定义actions对象（4-3），准备一个异步函数，第一个参数context与 store 实例具有相同方法和属性，第二个参数是因为mutstions里减法函数需要一个对象参数num，使用context.commit()方法，第一个参数是mutations里的方法名称，第二个参数是接收上边传递的参数 // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{ count:100, }, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{ reduceCount(state,{num}) { state.count -= num }, }, // 4-3. actions操作异步 执行mutations actions:{ // 定义函数-异步 asyncReduceCount(context,payload) { //模拟异步请求 5秒后操作上面的mutations里的减法函数 reduceCount setTimeout(()=&gt;{ context.commit('reduceCount',payload) },2000) } } }) // 5.导出 export default store 2.在组件上使用1、组件里直接调用actions 使用this.$store.dispatch（'想要调用的actions里的方法名称',’需要传递的num值‘） &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h3&gt;操作actions&lt;/h3&gt; &lt;p&gt;vuex-count:{{$store.state.count}}&lt;/p&gt; &lt;button @click=\"jian\"&gt;actions 直接调用&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default ({ methods:{ jian(){ this.$store.dispatch('asyncReduceCount',{ num:10 }); } } }) &lt;/script&gt; 2、组件里使用辅助函数方法调用actions 例子1 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h3&gt;操作actions&lt;/h3&gt; &lt;p&gt;vuex-count:{{$store.state.count}}&lt;/p&gt; &lt;button @click=\"jian2\"&gt;actions 辅助函数调用&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {mapActions } from \"vuex\" export default ({ methods:{ ...mapActions(['asyncReduceCount']), jian(){ //直接调用actions this.$store.dispatch('asyncReduceCount',{ num:10 }); }, jian2(){ // 辅助函数方法调用actions this.asyncReduceCount({num:20}) } } }) &lt;/script&gt; 例子2 组件获取state里的用户名 安装一下axios cnpm i axios - S 然后在vuex文件下store仓库的代码如下 const store = new Vuex.Store({ state:{ //1.定义一个空的用户名 user:'', }, mutations:{ // 2.定义一个修改state的user函数 changeUser(state,uname){ state.user = uname }, }, actions:{ // 3.定义一个异步请求--用户名的函数 getUser(context){ axios.get('http://iwenwiki.com/api/blueberrypai/getIndexBanner.php') .then(res =&gt; { console.log(res.data.banner[0].title); // 4.数据获取成功后，解析出来想要的数据格式 --再利用mutations来修改状态state // 5.操作-mutations可以使用contxet.commit('要操作的方法名','其他参数')来修改用户名 context.commit('changeUser',res.data.banner[0].title) }) } } }) 在组件里的代码如下 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;p&gt;用户名:{{user}}&lt;/p&gt; &lt;button @click=\"getUser1\"&gt;获取用户名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapActions } from \"vuex\" export default ({ computed:{ ...mapState(['userinfo','user']) }, methods:{ ...mapActions(['asyncReduceCount','getUser']), getUser1(){ this.getUser() }, } }) &lt;/script&gt; Getter1、介绍​ Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。对数据缓存和过滤处理。 2、如何访问1.直接获取getters​ this.$store.getters.属性 2.辅助函数访问import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount','anotherGetter']) } } 3、例子const store = new Vuex.Store({ state:{ user:'', }, mutations:{ }, actions:{ }, getters:{ userName:state=&gt;{ return state.user +'vip用户' } } }) 其他组件使用 &lt;template&gt; &lt;div class=\"about\"&gt; &lt;h2&gt;我是about&lt;/h2&gt; &lt;h4&gt;getters使用&lt;/h4&gt; &lt;p&gt;用户名:{{user}}&lt;/p&gt; &lt;p&gt;新的用户名直接读取：{{$store.getters.userName}}&lt;/p&gt; &lt;p&gt;新的用户名辅助函数读取：{{userName}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //1. 导入辅助函数 import { mapState,mapActions,mapGetters } from \"vuex\" export default ({ // 2.计算属性中使用辅助函数 computed:{ ...mapState(['userinfo','user']), ...mapGetters(['userName']) }, }) &lt;/script&gt; 总结1、vuex仓库数据 state getters1.state 获取：​ 1、直接获取 ​ this.$store.state.xx ​ 2、辅助函数获取 //引入辅助函数... import { mapState } from \"vuex\" computed:{ ...mapState(['','',...]) } 2.getters获取:​ 1、直接获取​ this.$store.getters.xx ​ 2、辅助函数获取 //引入辅助函数... import { mapGetters } from \"vuex\" computed:{ ...mapGetters(['','',...]) } 2、操作修改state –mutations actions1.mutations操作​ 1、直接获取​ this.$store.commit(‘函数名字’,’参数’) ​ 2、辅助函数获取 //引入辅助函数... import { mapMutations } from \"vuex\" computed:{ ...mapMutations(['','',...]) } 2.actions操作​ 1、直接获取​ this.$store.dispatch(‘函数名字’,’参数’) ​ 2、辅助函数获取 //引入辅助函数... import { mapActions } from \"vuex\" computed:{ ...mapActions(['','',...]) } Modules1、介绍：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块 简单来说store还有一个modules属性对象里面可以单独存储入：用户信息、城市数据、购物车数据、搜索数据等等 2、命名空间:​ 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。 3、modules的使用：4-5 处写一个modules对象，添加一个模块名称的属性对象，里面可以包含state，mutations，actions，getters // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' import { ADDCOUNT } from './mutation-types.js' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:{}, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:{}, // 4-3. actions操作异步 执行mutations actions:{}, // 4-4. getters 处理state数据进行加工 getters:{}, // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:{ // 开启了命名空间 让actions mutations getters的作用域是当前的模块下而不是挂载到全局 namespaced:true, state:{ cityName:'成都', }, mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 也可以写成这种格式 getCity({commit},city) getCity(context,city){ context.commit('changeCity',city) } } }, } }) // 5.导出 export default store 在需要用到的模块组件下使用： &lt;template&gt; &lt;div&gt; &lt;h2&gt;城市模块的使用&lt;/h2&gt; &lt;h4&gt;state&lt;/h4&gt; &lt;p&gt;当前城市--直接读取：{{this.$store.state.cityModule.cityName}}&lt;/p&gt; &lt;p&gt;当前城市--辅助函数读取：{{cityName}}&lt;/p&gt; &lt;h4&gt;mutations&lt;/h4&gt; &lt;button @click=\"getCity1\"&gt;修改城市城名&lt;/button&gt; &lt;button @click=\"getCity2\"&gt;辅助函数修改城市城名&lt;/button&gt; &lt;h4&gt;actions&lt;/h4&gt; &lt;button @click=\"updateCity1\"&gt;actions-修改城市城名&lt;/button&gt; &lt;button @click=\"updateCity2\"&gt;actions-辅助函数修改城市城名&lt;/button&gt; &lt;h4&gt;getters&lt;/h4&gt; &lt;!-- getters这里不能直接打点调用下面的方法，而是用中括号加引号 --&gt; &lt;p&gt;getters--获取数据：cityVal:{{this.$store.getters['cityModule/cityVal']}}&lt;/p&gt; &lt;p&gt;getters--辅助函数获取数据：cityVal:{{this.cityVal}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapMutations,mapActions,mapGetters } from 'vuex' export default { methods:{ ...mapMutations('cityModule',['changeCity']), ...mapActions('cityModule',['getCity']), getCity1(){ // 1、直接获取模块下的mutations this.$store.commit('cityModule/changeCity','南京') }, getCity2(){ // 2、辅助函数获取模块下的mutations下的changeCity方法 this.changeCity('南京') }, updateCity1(){ //1、直接使用actions模块下的getCity方法 this.$store.dispatch('cityModule/getCity','北京') }, updateCity2(){ // 2、辅助函数获取模块下的actions的getCity this.getCity('北京') } }, computed:{ // ...mapState('模块名称',['模块里的变量']) ...mapState('cityModule',['cityName']), ...mapGetters('cityModule',['cityVal']) } } &lt;/script&gt; 4、带命名空间的模块内访问全局内容1.在getter对象里的四个参数如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:{ // 开启了命名空间 让actions mutations getters的作用域是当前的模块下而不是挂载到全局 namespaced:true, state:{ cityName:'成都', }, getters:{ cityVal:state=&gt;{ return state.cityName + '好去处' }, // getGlobalCity方法 --getter数据处理的时候，获取全局的getters state数据 getGlobalCity(state,getters,rootState,rootGetters){ // state 获取当前模块的状态-state // getters 获取当前模块的所有的getterrs // rootState 获取根上的state数据 可以获取其他模块的数据 // rootGetters 获取根上所有的getters 全局的和所有模块的getters console.log(state,getters,rootState,rootGetters); } }, mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 也可以写成这种格式 getCity({commit},city) getCity(context,city){ context.commit('changeCity',city) }, // 注意：局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 ！ getGlobalCityAction(context){ console.log(context); } } }, } 组件中使用 如下， // 同时局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 &lt;template&gt; &lt;div&gt; &lt;h4&gt;模块内访问全局的数据state getters&lt;/h4&gt; &lt;button @click=\"getGetters\" &gt;访问getters&lt;/button&gt; &lt;button @click=\"getGlobalCityAction1\" &gt;访问局部模块的context对象&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState,mapMutations,mapActions,mapGetters } from 'vuex' export default { methods:{ ...mapMutations('cityModule',['changeCity']), ...mapActions('cityModule',['getCity','getGlobalCityAction']), getGetters(){ // console.log(this.getGlobalCity); this.getGlobalCity }, getGlobalCityAction1(){ this.getGlobalCityAction() } }, computed:{ // ...mapState('模块名称',['模块里的变量']) ...mapState('cityModule',['cityName']), ...mapGetters('cityModule',['cityVal','getGlobalCity']) } } &lt;/script&gt; 2.{ root: true } 第三参数需要在全局命名空间内分发 (触发) action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可 actions方法接收一个context对象，使用context.commit()方法能操作mutation，第一个参数是mutations里的方法名称，第二个参数是接收上边传递的参数,所以当第三个参数是{ root: true } 的时候，将可以访问到全局下的mutation，同理dispatch下能访问到全局下的action里的xx方法 解释：就是在命名的模块内想要访问全局的actions或者mutaitons里面的函数 语法：actions里面: context.commit(‘changeUser’,null,{root:true}) 例如：在命名的模块下，如果对象想访问全局的actions 或者是全局的mutations 都是可以的 // modules 模块 分类存储很多信息 modules:{ mutations:{ changeCity(state,payload){ state.cityName = payload } }, actions:{ // 局部模块的context对象可以访问全局对象 state getters mutations getters 包括其他模块 // context对象里面包含了={dispatch:'',commit:'',state:'',getters:'',rootState:'',rootGetters:''} getGlobalCityAction(context){ console.log(context); // 如果对象想访问全局的actions 或者是全局的mutations 都是可以的 这里访问全局的mutations方法修改全局state数据 context.commit('changeUser','局部修改全局的user',{root:true}) } } }, ！！注意：1、commitactions里的方法能够使用commit去调用mutations里的方法， actions方法接收一个context对象，使用context.commit()方法能操作mutation，第一个参数是mutation里的方法名称，第二个参数是接收上边传递的参数, 2、dispatch能够使用dispatch调用action里面的方法 项目结构1、规则虽然vuex设计并不限制你的代码结构，但是，它规定了一些需要遵守的规则： ​ a: 应用层级的状态应该集中到单个 store 对象中。（所有的数据都要在 new Vuex.Store中）​ b: 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。（想改state数据只能通过mutation的方法去修改）​ c: 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。 2、项目结构实例通过上方的学习后会发现vuex文件已经有一百多行代码，看起来较为麻烦。vuex设计了只需将 action、mutation 和 getter 分割到单独的文件。 项目结构示例 └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 在store文件夹下新建state 、mutations 、actions 、getterrs 后辍为.js的文件，模块文件需要单独在store下新建modules文件夹放入各个 模块名.js,然后将原store里的代码移动过去，并暴露出来，重新将项目分割后如下: // 1. 引入Vue import Vue from 'vue' // 2.引入Vuex import Vuex from 'vuex' // 拆分后：引入state mutations actions getterrs 和命名空间模块cityModule、loginModule import state from './state' import mutations from './mutations' import actions from './actions' import getters from './getters' import cityModule from './modules/cityModule' import loginModule from './modules/loginModule' // 3.使用Vuex Vue.use(Vuex) // 4.创建Vuex仓库 const store = new Vuex.Store({ // 4-1.共享的数据 说明：state状态 任意类型 state:state, // 4-2.修改state仓库数据 里面包含的是方法-修改state数据 mutations:mutations, // 4-3. actions操作异步 执行mutations actions:actions, // 4-4. getters 处理state数据进行加工 getters:getters, // 4-5. modules 模块 分类存储很多信息 modules:{ // 1、例：存城市数据 cityModule:cityModule, // 2、例：存用户的数据 loginModule:loginModule, } }) // 5.导出 export default store","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wuzimo233.github.io/tags/Vuex/"}]},{"title":"Uni-app学习","slug":"11-Uni-app学习","date":"2022-05-04T15:17:00.000Z","updated":"2022-05-04T15:23:37.437Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://wuzimo233.github.io/posts/12.html","excerpt":"","text":"前置条件 有vue基础 什么是uni-app uni-app 是DCloud公司打造的一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。 HTML结构(简单了解) View容器–类似于div text文本–包裹文本 swiper–轮播图 img–图片 video–视频 button–按钮 CSS样式 属性 字体 大小 布局：float 选择器 class 取值与单位 px color rpx 自动根据屏幕大小比例进行适配 盒子模型 margin:外边距 padding:内边距 border:边框 弹性盒子模型 更好的布局","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wuzimo233.github.io/tags/uni-app/"}]},{"title":"Vue-图书管理案例","slug":"10-Vue图书管理案例","date":"2022-04-26T04:00:00.000Z","updated":"2022-04-29T16:41:10.237Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://wuzimo233.github.io/posts/11.html","excerpt":"","text":"前置条件 安装Visual Studio Code（代码编辑器） 电脑已安装node.js 配置好vue相关文件 开始构建 电脑任意位置新建文件夹命名为”Vue-图书管理” 新建文件index.html 并创建基本html结构 因为是局部使用vue ，需要cdn方式引入Vue &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; 开始 new vue实例 并赋值为vm，在其内部构建 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ }, methods:{ } }) &lt;/script&gt; 将data里放入图书的数组数据 data:{ books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"20512\", }, { id: 4, name: \"西游记\", price: \"212\", }, ], }, 布局基本html样式 &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\"&gt;编辑&lt;/a&gt; | &lt;a href=\"\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 增加添加图书功能 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ obj:{ id:'', name:'', price:'', }, newobj:'', num:'', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ submit(){ // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.o // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newob // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, } }) &lt;/script&gt; 编辑图书功能 &lt;body&gt; &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\" :disabled=\"isDisabled\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\" :disabled=\"noSubmit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"##\" @click.prevent=\"editor(index)\"&gt;编辑&lt;/a&gt; | &lt;a href=\"##\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip= false; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ noSubmit:false, //禁止提交按钮的状态 isDisabled:false, //默认可以点击 indexData:'', //存储index标识 obj:{ id:'', name:'', price:'', }, newobj:'', num:'2', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ // 提交按钮 submit(){ // 判断是否是提交新数据还是修改旧数据 if(this.isDisabled) { //编辑功能: // 方法 1： 获取index 找操作的行元素 修改它 // console.log('编辑'); // console.log('编辑的当前行',this.books[this.indexData]); // this.books[this.indexData].name = this.obj.name // this.books[this.indexData].price = this.obj.price // 方法 2： 找id 获取编辑的id == books里面的id // 使用方法 some 查找原数组里是否有某元素 如果有返回true // ele 可以获取books数组的每一项 this.books.some( (ele) =&gt; { if( ele.id == this.obj.id){ //这个ele就是编辑的数据 ele.name = this.obj.name ele.price = this.obj.price return true } }) // 释放禁止按钮 this.isDisabled = false; }else { //添加功能 // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.obj // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newobj) } // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, // 编辑按钮 editor(index){ //1 获取当前行的数据 渲染到文本框中 console.log(this.books[index]); // this.obj.id = this.books[index].id // this.obj.name = this.books[index].name // this.obj.price = this.books[index].price this.obj = this.books[index] // 2. 编辑的时候--编号禁止操作 this.isDisabled = true; // 3. 存储index下标---目的：提交的时候 修改的是哪个数据用 this.indexData = index; } }, //侦听器 watch:{ \"obj.name\":function(val){ console.log('监听了数据变化',val); var flag = this.books.some(ele =&gt; { return ele.name == val }) if(flag) { this.noSubmit = true alert('已经存在相同名称书籍') } else { this.noSubmit = false } } } }) &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"}]},{"title":"Vue路由拦截","slug":"09-Vue登录拦截案例","date":"2022-04-20T17:28:00.000Z","updated":"2022-04-29T16:41:05.330Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://wuzimo233.github.io/posts/9.html","excerpt":"","text":"路由拦截案例：从零开始创建一个新的项目安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve 配置路由组件 配置路由组件 – login登录界面 layout-布局界面（首页-新闻-我的） 简单说就是 layout组件里包含首页、新闻、我的 等界面，而在login组件里包含登录，且login和layout是平级的关系 删除HomeView.vue里的默认信息改名为Home，添加 首页 AboutView.vue组件改名About，里面 h1信息This is an about page改为 我的 添加News.vue组件，添加h1新闻界面 在views下新建Login组件，添加h1登录界面 在views下新建Layout组件 配置路由router下的index.js","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"}]},{"title":"TEST","slug":"test","date":"2022-04-20T08:15:00.000Z","updated":"2022-04-20T17:27:34.667Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://wuzimo233.github.io/posts/10.html","excerpt":"","text":"使用hexo发布文章遇到的问题使用两个花括号报错","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"JS进阶学习","slug":"08-JS进阶学习","date":"2022-04-18T13:53:00.000Z","updated":"2022-04-18T14:26:33.665Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://wuzimo233.github.io/posts/8.html","excerpt":"","text":"ES6高级待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue进阶知识学习","slug":"06-Vue进阶学习","date":"2022-04-18T13:42:00.000Z","updated":"2022-04-29T16:41:24.726Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://wuzimo233.github.io/posts/6.html","excerpt":"","text":"该页面假设你已经阅读过了组件基础。如果你还对组件不太了解，推荐你先阅读它。 注册局部组件 创建一个组件Mycomp.vue 在需要用到的地方引入：import Mycomp from './components/Mycomp.vue' 注册组件export default { name: 'App', components: { Mycomp } } 使用组件在 template &lt;Mycomp&gt;&lt;/Mycomp&gt; 组件组成 template 视图 script 逻辑 style 样式 全局组件 注册全局组件 在Vue对象身上有个Vue.component() 注册全局组件 在所有的组件中 不需要引入 可以直接使用 语法：Vue.component(‘my-component-name’, { // ... 选项 ... }) 代码演示 // import Vue from 'vue'//运行时：vue.runtime.js import Vue from 'vue/dist/vue' /注册全局组件(放到main.js) // Vue.component('组件名称',{内容配置}) Vue.component('my-comp',{ //视图 template :template作为属性使用 必须vue.js （完整版的vue.js） 默认引入-运行时-vue.runtime.js template:'&lt;div&gt; &lt;h2&gt;我是一个全局组件&lt;/h2&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/div&gt;', //数据 data(){ return { msg:'hello vue全局组件' } }, //方法 methods:{ } }) 全局组件–可以挂载创建好的局部组件 注册全局import MyBanner from ‘./components/MyBanner.vue’// Vue.component(‘MyBanner’,MyBanner)Vue.component(MyBanner.name,MyBanner) 组件中的data为什么是函数答案避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。 computed和watch的区别action 与 mutation 的区别 mutation 是同步更新， $watch 严格模式下会报错 action 是异步操作，可以获取数据后调用 mutation 提交最终数据 Vue 组件通讯有哪几种方式父传子通过props传递父亲提供数据通过属性 props传给儿子；儿子通过 $on 绑父亲的事件，再通过 $emit 触发自己的事件（发布订阅）利用父子关系 $parent 、 $children 子传父在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。父组件： &lt;child @receive = ‘receive’ /&gt;子组件: this.$emit(‘receive’,’传递的数据’) 兄弟组件传值通过中央通信 let bus = new Vue()prop 验证，和默认值 v-for 为什么要加 keyv-model 原理怎样理解 Vue 的单向数据流Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。 虚拟 DOM 是什么 有什么优缺点 谈一下对 vuex 的个人理解vuex是什么Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 怎么使用vuexvuex中有几个核心属性，分别是什么？ 一共有5个核心属性，分别是: state 唯一数据源,Vue 实例中的 data 遵循相同的规则 getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值. mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发 action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作 module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。 路由页面管理（vue-router）什么是vue-router怎么使用vue-router怎么定义vue-router的动态路由？怎么获取传过来的动态参数？vue-router 路由钩子函数是什么 执行顺序是什么路由拦截方法待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"}]},{"title":"JS基础知识","slug":"07-JS基础学习","date":"2022-04-17T17:00:00.000Z","updated":"2022-04-22T17:59:48.397Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://wuzimo233.github.io/posts/7.html","excerpt":"","text":"JavaScript基础知识点了解 JavaScriptJavaScript是什么 JavaScript是一种运行在客户端（浏览器）高级的、解释型的编程语言的，实现人机交互效果 由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持 JavaScript乍一听与Java在名字上相似，但其实是雷锋与雷锋塔、老婆和老婆饼的关系hhh 一般简称JS，以下都以JS称呼 JS的作用（做什么） 网页特效 （监听用户的一些行为让网页做出对应的反馈） 表单验证 （针对表单数据的合法性进行判断） 数据交互 （获取后台的数据，渲染到前端页面） 服务端编程（node.js） JS的组成（有什么）JS 是由ECMAScript和WebApi 组成。WebApi又由DOM（页面文档对象模型）和BOM（浏览器对象模型）构成 ECMAScript是由网景的布兰登·艾克开发的一种脚本语言的标准化规范；最初命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript[1]。 DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作 Bom 操作浏览器，比如页面弹窗，检测窗口宽度，存储数据到浏览器等 JS的位置内部引入 直接在HTML文件中引入（一般在标签的底部使用）&lt;script&gt; alert('我是内部引入的JS') &lt;/script&gt; 外部引入 是指将JS文件外置在HTML文件的外部，在head标签内引入相对路径中的JS文件 使代码更加有序，易于复用，且没有了脚本的混合，HTML也会更加易读&lt;head&gt; &lt;script src=\"./my.js\"&gt;&lt;/script&gt; &lt;/head&gt; 内联使用 在标签内部使用&lt;button onclick=\"alert('我是内联JS')\"&gt;我是按钮&lt;/button&gt; JS注释 单行注释 // xxx 多行注释 /* xxx */ 字面量 了解什么是字面量前，先知道什么是语法？ 是人和计算机打交道的规则—我们按照这个规则去敲代码 比如输入语法：document.write('输出的文字-文字展示到页面') document.write('&lt;h1&gt;我是嵌套的h1标签&lt;/h1&gt;') alert('要输出的内容-弹框形式展示到页面') console.log('控制台打印的内容') 在计算机科学中，字面量（literal）是在计算机中描述 事/物比如: 初级前端开发薪水是：8k 此时8k就是数字字面量 ‘hello world’ ：这是字符串字面量 还有其他数组字面量、对象字面量 变量变量是什么？ 通俗来讲：变量是计算机存储数据的“容器” 白话：变量就是一个装东西的盒子 变量不是数据本身，它们仅仅是一个用于存储数值的容器，可以理解为是一个个用来装东西的盒子~例如：用户在网页输入自己姓名或者电话等信息时候，就是通过变量存储。 变量的声明方式在JS中创建变量被称为声明变量，JS中变量声明又分为显示声明和隐式声明。其中显示声明中，声明关键字有var、let、const、function、class、import let 变量名 语法：声明关键字 + 变量名 let 即关键字（let：允许、让、要），所谓关键字是系统提供的专门用来声明（定义）变量的词语 注意let不能多次声明一个变量名 可以一次声明多个变量 let age=18,name=’zimo’;// 声明关键字 + 变量名 let age; age = 18; // 变量声明后一般会赋值 也可以连写let age = 18; age = 19; // 变量可以更新值 document.write(age); 案例：用户输入姓名后，页面显示刚才用户输入的姓名&lt;script&gt; let name = (prompt('请输入您的姓名')) document.write(name) &lt;/script&gt; 案例：交换变量的值需求：2个不同变量的变量去交换其值。&lt;script&gt; let num1 = 10 let num2 = 20 let num3 = '' num3 = num1 num1 = num2 num2 = num3 console.log(num1,num2); &lt;/script&gt; 变量本质先了解一下内存：是计算机存储数据的地方，相当于一个空间变量：是程序在内存中申请的一块用来存放数据的小空间 变量的命名规则与规范 不能用关键字比如：let var if for等 只能使用下划线、字母、数字、$组成，且数字不能开头 字母严格区分大小写 起名要有意义 遵守小驼峰命名法 （第一个单词首字母小写，后面每个单词首字母大写，如：UserName） 拓展 let 与 var 区别 let为了解决var的一些问题 var可以先使用 在声明（不合理） var声明过的变量可以重复声明（不合理） 比如变量提升、全局变量、没有块级作用域等等","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue基础知识学习","slug":"05-Vue基础学习","date":"2022-04-17T11:47:00.000Z","updated":"2022-04-29T16:41:33.083Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://wuzimo233.github.io/posts/5.html","excerpt":"","text":"Vue的安装安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve Vue介绍 Vue是渐进式（渐进式：项目中可以逐步使用vue框架 可以使用一部分 或者是整个项目） JavaScript 框架 框架为单页面的应用程序 （Vue项目入口：只有一个页面 index.html ） 跳转的页面路由功能- 路由 （其他页面组件） 框架里面使用的是虚拟DOM 没有js BOM DOM 特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。 Vue的优缺点优点： 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了angular的特点，在数据操作方面更为简单；组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。缺点： 单页面应用程序，首页加载速度慢 不利于搜索引擎优化 Vue的使用局部使用Vue 引入 Vue 的cnd网址 或者是下载到本地js文件 （类似：jquery.js） 创建vue实例 代码演示&lt;head&gt; //引入js文件夹里的vue &lt;script src=\"./JS/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用vue --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;这是vue的区域了 app--&lt;/p&gt; &lt;p&gt;获取vue的信息：{{msg}}&lt;/p&gt; &lt;/div&gt; &lt;!-- 创建vue实例 --&gt; &lt;script&gt; const vm = new Vue({ el:'#app',//获取element元素 data:{ msg:'hello vue', } }) &lt;/script&gt; &lt;/body&gt; 搭建vue项目1.兼容性Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 2.安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 3.安装vue 命令行工具 (CLI) 介绍：Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。CLI是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速搭建一个新项。 网址：https://cli.vuejs.org/zh/ 版本：Vue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上) 先安装yarn: npm i yarn -g (推荐) 安装vue-cli： npm install -g @vue/cli （下载模块：npm install 模块 ） 或者 yarn global add @vue/cli （下载模块：yarn add 模块 ） 检查其版本是否正确vue –version 4.创建一个vue项目–通过脚手架vue-cli 创建vue项目： vue create vue-project说明：vue项目名称最好是英文 不能包含驼峰命名法 按需项目需要的依赖配置 进入项目cd 项目名称 启动项目npm run serve或者yarn serve 打包项目npm run build 目录结构 node_moudles 安装包依赖 –模块public 单页面入口 - index.htmlsrc 资源文件 – 前端– – assets 静态文件资源 - 放置 css js images– – components 公共组件 - 组件化 （样式 布局 效果）– – App.vue 根组件– – main.js 入口配置文件.browserslistrc 浏览器配置.gitignore 上传git仓库 忽略的文件配置babel.config.js babel配置package.json 项目配置文件 （查看项目安装的依赖 版本 名称… ）readme.md 项目说明文件yarn.lock 配置信息 忽略 Vue组件组成 组成-三部分 template 视图标签 （template标签不会被渲染 只是包裹作用） 必写 script 逻辑代码 style 样式 lang=’less/scss’ scoped 创建组件 xxx.vue 后缀.vue结尾 三部分组件 快捷键 vue 组件使用 引入组件 注册组件 使用组件&lt;script&gt; //1. 引入组件 import Banner from './components/Banner.vue' export default { name: 'App', //2. 注册组件 components: { Banner, } } &lt;/script&gt; &lt;!-- 3. 使用组件 --&gt; &lt;Banner&gt;&lt;/Banner&gt; vue基础语法指令：就是以 v-指令=’js环境’ 具体特定的工具 ，指令。 插值操作 (模板语法) 作用：获取vue数据 显示视图 模板语法来声明式地将数据渲染进 DOM 语法： Mustache &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;!--mustache语法中,不仅仅可以直接写变量,也可以写简单的表达式--&gt; // 获取data里的数据 &lt;h2&gt;{{firstName + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName + ' ' + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{lastName}}&lt;/h2&gt; &lt;h2&gt;{{counter * 2}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', // 提供数据 data: { message: '你好啊', firstName: 'kobe', lastName: 'bryant', counter: 100 }, }) &lt;/script&gt; 指令介绍v-once在某些情况下，我们可能不希望界面随意的跟随改变这个时候，我们就可以使用一个Vue的指令v-once:该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。代码如下： &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-once&gt;{{message}},李银河&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-html -原生HTML某些情况下，我们从服务器请求到的数据本身就是一个HTML代码如果我们直接通过插值语法来输出，会将HTML代码也一起输出但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容可以使用v-html指令该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染 &lt;div id=\"app\"&gt; &lt;h2&gt;{{url}}&lt;/h2&gt; &lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' } }) &lt;/script&gt; v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中v-text通常情况下，接受一个string类型缺点是不够灵活：第二个h2不会显示李银河 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;, 李银河!&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-prev-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。比如下面的代码第一个h2元素中的内容会被编译解析出来对应的内容第二个h2元素中会直接显示 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; //你好啊 &lt;h2 v-pre&gt;{{message}}&lt;/h2&gt; //{{message}} &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-cloak在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签cloak: “斗篷” &lt;div id=\"app\" v-cloak&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 在vue解析之前, div中有一个属性v-cloak // 在vue解析之后, div中没有一个属性v-cloak setTimeout(function () { const app = new Vue({ el: '#app', data: { message: '你好啊' } }) }, 1000) &lt;/script&gt; 条件渲染条件渲染- v-if （v-else、v-else-if） 作用：是否显示元素/ true 显示 false 隐藏 语法： &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; v-else作用：是对 v-if=’’的结果取反 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else&gt;xxxx &lt;/span&gt; v-else-if作用：是否显示元素 与v-if v-else-if 多语句判断 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else-if=\"boolean表达式\"&gt;&lt;/span&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;条件渲染 vue-if&lt;/h2&gt; &lt;!-- v-if='boolean' --&gt; &lt;p&gt;v-if的值：{{flag}}&lt;/p&gt; &lt;p v-if=\"flag\"&gt;我是v-if为true显示的&lt;/p&gt; &lt;h4 v-else&gt;我是v-else控制显示&lt;/h4&gt; &lt;button @click=\"change()\"&gt;点我控制v-if的值&lt;/button&gt; &lt;!-- 多语句 --&gt; &lt;p v-if=\"number&gt;5\"&gt; number&gt;5 &lt;/p&gt; &lt;p v-else-if=\" 2&lt; number &lt;=5\"&gt; number大于2小于等于5 &lt;/p&gt; &lt;p v-else&gt; number小于2 &lt;/p&gt; &lt;input type=\"text\" placeholder=\"请输入数字来判断number\" v-model=\"number\"&gt; &lt;br&gt; &lt;span&gt;{{number}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ flag:false, number:\"\", } }, methods:{ change(){ this.flag=!this.flag } } } &lt;/script&gt; v-show 作用：是否显示元素/ true 显示 false 隐藏 语法：特点：控制元素的 display:block/none &lt;span v-show=\"boolean表达式\"&gt;&lt;/span&gt; 列表渲染- v-for1. 遍历数组语法： &lt;li v-for=\"(item,index) in arr\" :key=\"\"&gt; {{ item }} &lt;/li&gt; 属性 item 第一个元素 表示数组的每一项内容 index 第二个元素 表示数组的下标 0 1 arr 数组数据(或者对象) :key其实是 v-bind属性 作用：做当前数据的唯一标识 一般写的是id 不推荐 index 2. 遍历对象 &lt;div v-for=\"(value, key, index) in object\"&gt; {{ index }}. {{ key }}: {{ value }} &lt;/div&gt; value 对象里每个键值对的值({key:value}中的value) key 对象里每个键值对的键名({key:value}中的key) index 下标0 1 object 要遍历的对象名 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组遍历- v-for&lt;/h2&gt; &lt;p&gt;直接获取数组数据：arr{{ arr }}&lt;/p&gt; &lt;p&gt;遍历数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in arr\" :key=\"item.id\"&gt; 每一项 {{ item }} -- 下标 {{ index }} &lt;/li&gt; &lt;/ul&gt; -------------------------------------------------- &lt;p&gt;遍历内部是对象的数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in books\" :key=\"index\"&gt; &lt;h3&gt;书名：{{ item.name }}&lt;/h3&gt; &lt;p&gt;价格：{{ item.price }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ---------------------------------------------------- &lt;p&gt;遍历对象&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(ele,key) in obj \" :key=\"key\"&gt; &lt;p&gt;{{key}}：：{{ele}}&lt;/p&gt; &lt;!-- &lt;p&gt;姓名：{{ele.uname}}&lt;/p&gt; &lt;p&gt;年龄：{{ele.age}}&lt;/p&gt; --&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3, 4], books: [ { id: 1, name: \"三国\", price: 20, }, { id: 2, name: \"西游记\", price: 30, }, { id: 3, name: \"红楼梦\", price: 40, }, ], obj: { uname: \"张三\", age: 20, }, }; }, }; &lt;/script&gt; 3. v-for 与 v-if 一同使用 注意不推荐在同一元素上使用 v-if 和 v-for 、v-for 的优先级比 v-if 更高 解决办法： &lt;template&gt; &lt;div&gt; &lt;h4&gt;4 v-for 与 v-if 一同使用, v-for 的优先级比 v-if 更高&lt;/h4&gt; &lt;h4&gt;今天上架了什么水果：&lt;/h4&gt; &lt;ul&gt; &lt;template v-for=\"(item) in zaoshi\"&gt; &lt;li :key=\"item.id\" v-if=\"item.flag\"&gt; 种类：{{item.fruit}} &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { zaoshi:[ { id:100, fruit:'苹果', flag:true, }, { id:101, fruit:'香蕉', flag:false, }, { id:102, fruit:'阳光玫瑰', flag:true, }, { id:103, fruit:'车厘子', flag:false, }, ] }; }, }; &lt;/script&gt; Vue 事件处理 介绍可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码 定义事件语法：&lt;div&nbsp;v-on:事件名=’dosomething’&gt;函数dosomething定义的位置：要求定义mothds属性中 事件：this指向：事件的this指向 当前组件实例对象事件传递参数：事件传递参数 v-on:click=’canshu(1,2)’事件对象event： 函数不带参数 第一个参数默认是事件对象 event 函数带参数 事件对象需要手动传递 $eventv-on:事件名=’函数’简写：@事件名=’函数’ 事件修饰符Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop.prevent.capture.self.once.passive &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue事件处理&lt;/h2&gt; &lt;!-- 事件修饰符 --&gt; &lt;div @click=\"parent\"&gt; //父元素 我是小头爸爸 &lt;button @click.stop=\"child\"&gt;我是大头儿子&lt;/button&gt; //子元素 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ parent(){ console.log('父元素'); }, child(){ console.log('子元素'); }, } } &lt;/script&gt; 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：.enter *.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right &lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=\"submit\"&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 按键修饰符 --&gt; &lt;input type=\"text\" v-on:keyup.enter='getInput'&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ getInput(e){ //if(e.keyCode == 13) { // console.log('按下了回车键--触发是搜索。。。'); //} console.log('按下了回车键--触发是搜索。。。'); } } } &lt;/script&gt; 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。.ctrl.alt.shift.meta &lt;template&gt; &lt;div&gt; &lt;!-- 系统修饰键 --&gt; &lt;!-- 可以按下ctrl+回车键触发 --&gt; &lt;textarea @keyup.ctrl.enter=\"send\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;button @click=\"send\"&gt;发送&lt;/button&gt; // &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { // 系统修饰键 send(){ console.log('系统修饰键--发送了聊天信息'); } }, }; &lt;/script&gt; 鼠标按钮修饰符.left.right.middle Vue中key属性的作用 （考点） 作用：key的作用主要是为了高效的更新虚拟DOM 高效的Diff算法 &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue中遍历数据v-foe是否添加key 功能&lt;/h2&gt; &lt;p&gt;key作用：提高更新虚拟DOM速度 --底层diff算法--查思路&lt;/p&gt; &lt;!-- 默认不带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;!-- 带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\" :key=\"item\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [\"A\", \"B\", \"C\", \"D\", \"E\"], }; }, methods: { addF() { // 增加 F （给数组添加元素 arr.splice(下标,删除的个数,添加的值)） this.arr.splice(2, 0, \"F\"); }, }, }; &lt;/script&gt; 数组更新检测 说明：在列表渲染中，如果遍历是数组，当数组数据发生改变时，页面什么时候能自动更新(页面重新渲染) 实现数组视图同步更新 变更方法 （修改了原数组）push()pop()shift()unshift()splice()sort()reverse() 替换数组（修改后返回新的数组 原数据不修改 视图想同步更新 覆盖原数组）filter()、concat() 和 slice() &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组更新同步&lt;/h2&gt; &lt;p&gt;arr:{{ arr }}&lt;/p&gt; &lt;button @click=\"addArr\"&gt;追加数组&lt;/button&gt; &lt;button @click=\"sliceArr\"&gt;切割数组&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3], }; }, methods: { addArr() { // this.arr.push(100) this.arr.reverse(); }, sliceArr() { //slice() 返回新的数组 n ce(1); console.log(newArr); //替换 this.arr = newArr; }, }, }; &lt;/script&gt; 对象更新检测 说明：对象修改后 视图同步更新视图 – 内存：栈内存 堆内存 实现对象视图同步更新&lt;template&gt; &lt;div&gt; &lt;h2&gt;对象同步更新&lt;/h2&gt; &lt;p&gt;对象obj:{{ obj }}&lt;/p&gt; &lt;button @click=\"changeUname\"&gt;修改对象已存在的属性&lt;/button&gt; &lt;button @click=\"obj = { user: 'admin' }\"&gt;修改整个obj对象&lt;/button&gt; &lt;!-- //视图检测不到变化 --&gt; &lt;button @click=\"addAttribute\"&gt;给obj添加不存在的属性&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ obj:{ uname:'张三', age:20 } } }, methods:{ changeUname(){ this.obj.uname = '拉拉' }, addAttribute(){ // this.obj.love = '女' // 问题: 视图检测不到变化 vue认为obj没有修改 // 方法一:对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 // this.obj = {...this.obj} // 方法二: es6合并对象 Object.assign({},{},{}) // this.obj = Object.assign({},this.obj) // 方法三: vue官网解决方法 // Vue.set( target, propertyName/index, value ) /**参数： {对象 | 数组} target 目标元素 {string | number} propertyName/index (要添加的属性)数据类型名字或者index {any} value 属性的值 用法：向响应式对象中添加一个 property(属性)，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi') **/ //这里没有引入Vue了,因为组件实例对象vm身上有$set()方法 this.$set(this.obj,'love','女') //删除 同步视图 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。 this.$delete(this.obj,'age') } } } &lt;/script&gt; Class 与 Style 绑定介绍：动态的添加class或者是style样式1.绑定 HTML Class 直接绑定变量 &lt;div v-bind:class='变量'&gt;&lt;/div&gt; 对象语法 (最常用)&lt;div v-bind:class=\"{类名: 表达式-true显示类名、false隐藏 ,类名:boolean}\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:class=\"[变量1,变量2, {类名：boolean}]\"&gt;&lt;/div&gt; 2.绑定内联样式v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 对象语法 &lt;div v-bind:style=\"{css样式:变量,... }\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 直接变量&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; data: { styleObject: { color: 'red', fontSize: '13px' } } 完整练习案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;动态绑定样式class 和 style&lt;/h2&gt; &lt;h4&gt;动态绑定样式class&lt;/h4&gt; &lt;!-- 绑定变量 --&gt; &lt;button @click=\"active = 'box2'\"&gt;切换颜色-绑定变量&lt;/button&gt; &lt;div v-bind:class=\"active\"&gt;动态绑定样式class&lt;/div&gt; &lt;hr /&gt; &lt;!-- 对象语法 --&gt; &lt;div v-bind:class=\"{ box: flag }\"&gt;对象语法&lt;/div&gt; &lt;button @click=\"flag = !flag\"&gt;修改flag-对象语法&lt;/button&gt; &lt;hr /&gt; &lt;!-- 数组语法 --&gt; &lt;div class=\"aa\" v-bind:class=\"[active, { box2: true }]\"&gt;数组语法&lt;/div&gt; &lt;hr /&gt; &lt;h2&gt;动态绑定内联样式&lt;/h2&gt; &lt;p&gt;0. 默认的内联写法&lt;/p&gt; &lt;div style=\"width: 100px; height: 100px; background: orange\"&gt; 默认的内联写法 &lt;/div&gt; &lt;p&gt;1. 直接变量&lt;/p&gt; &lt;div v-bind:style=\"styleObject\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;2. 对象语法&lt;/p&gt; &lt;div v-bind:style=\"{color:'green',fontSize:'30px', width:'100px',height: '100px',backgroundColor:'blue'}\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;3. 数组语法&lt;/p&gt; &lt;div :style=\"[styleObject,{border:'5px solid #333'}]\"&gt;数组语法&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { active: \"box\", flag: \"true\", styleObject:{ width: '100px', height: '100px', background: 'orange', } }; }, methods: { changeColor() { this.active = \"box2\"; }, }, }; &lt;/script&gt; &lt;style&gt; .box { width: 200px; height: 200px; background-color: pink; } .box2 { width: 200px; height: 200px; background-color: rgb(21, 226, 253); } &lt;/style&gt; Vue-tab栏切换练习&lt;template&gt; &lt;div&gt; &lt;h2&gt;Vue-tab切换&lt;/h2&gt; &lt;ul class=\"nav\"&gt; &lt;li v-for=\"(item,index) in arr\" :key='item' :class=\"{active:index == num}\" @click=\"changeNav(index)\"&gt; {{item}}-{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"box1\"&gt; &lt;div v-for=\"(ele,n) in content \" :key=\"ele\" :class=\"{show:n == num}\"&gt;{{ele}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 0, arr: [\"选项1\", \"选项2\", \"选项3\"], content: [\"111\", \"222\", 333], }; }, methods: { changeNav(index){ this.num = index } }, }; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; .nav { overflow: hidden; list-style: none; li { display: inline; width: 100px; height: 40px; line-height: 40px; margin-right: 10px; } .active{ background: lightblue; } } .box1 { margin: auto; width: 400px; height: 200px; border: 1px solid #000; &gt;div { display: none; } .show { display: block; } } &lt;/style&gt; 表单输入绑定 (v-modele)1.介绍你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定通过指令 v-model=’’ 获取表单输入的信息数据 实现双向数据绑定 2.语法:会将文本框输入的数据实时传递给绑定到data里的msg中 &lt;input type='text' v-model='msg' /&gt; data(){ return{ msg:'' } } 案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;表单输入绑定&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" :value=\"msg\" name=\"\" id=\"\"&gt; --&gt; &lt;!-- 1. 文本/密码 v-model=''--&gt; &lt;input type=\"text\" placeholder=\"请输入\" v-model=\"formData.msg\" @keyup.enter=\"send\" name=\"\" id=\"\" /&gt; &lt;p&gt;msg:{{formData.msg}}&lt;/p&gt; &lt;!-- 2. 多行文本 --&gt; &lt;!-- 3. 单选按钮 --&gt; 性别: &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"1\" /&gt;男 &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"2\" /&gt;女 &lt;p&gt;选择的性别:{{ formData.sex }}&lt;/p&gt; &lt;!-- 爱好: --&gt; &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"a\" /&gt;吃 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"b\" /&gt;喝 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"c\" /&gt;玩 &lt;p&gt;选择的爱好:{{ formData.arr }}&lt;/p&gt; &lt;!-- 城市: --&gt; &lt;select name=\"\" id=\"\" v-model=\"formData.select\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"gaungzhou\"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;p&gt;城市选择:{{ formData.select }}&lt;/p&gt; &lt;button @click=\"submit\"&gt;注册信息&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'初始值', sex:'', //对象的语法--------存储表单数据 formData: { msg: \"\", //输入框 sex: 1, //性别 arr: [], select: \"\", }, }; }, methods:{ send() { console.log(\"输入的数据为:\", this.msg); }, submit() { //点击按钮--发送输入的数据给后台-- data -- msg sex arr ... console.log(\"提交注册信息表单\",this.formData); }, } }; &lt;/script&gt; 3.修饰符 lazy&nbsp; 只有当input失去焦点时才更新数据 number 把input标签中输入的内容转成数字，调用是parseFloat (Nunber()) trim 去除左右空格 案例： &lt;template&gt; &lt;div&gt; &lt;h3&gt;表单修饰符 -修饰符 &lt;/h3&gt; &lt;!-- .lazy 失去焦点或者回车 获取数据 --&gt; &lt;input type=\"text\" v-model.lazy=\"search\"&gt; &lt;p&gt;search:{{ search }}&lt;/p&gt; &lt;input type=\"text\" v-model.trim=\"msg\" name=\"\" id=\"\"&gt; &lt;p&gt;去空格:{{msg}}&lt;/p&gt; &lt;!-- .number 转数字 --&gt; &lt;input type=\"number\" v-model.number=\"num\" name=\"\" id=\"\"&gt; &lt;p&gt;num:{{ num }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ } }; &lt;/script&gt; 4.v-model实现原理v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发oninput 事件并传递数据v-model&nbsp;是什么。语法糖&nbsp;:value&nbsp;+&nbsp;@input。还要分为两种情况 &lt;input v-model=\"val\"&gt; &lt;!-- 基本等价于，因为内部还有一些其他的处理 --&gt; // $event是事件对象，$event.target.value表示input框中的输入值 &lt;input :value=\"val\" @input=\"val = $event.target.value\"&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;!-- v-model实现的原理 --&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;p&gt;inp:{{inp}}&lt;/p&gt; &lt;!-- v-model == v-bind:value='' @input='函数' --&gt; 表单值:&lt;input type=\"text\" :value=\"val\" @input=\"changeVal\" name=\"\" id=\"\"&gt; &lt;p&gt;val:{{val}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { val:'请输入', msg:'', inp:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ changeVal(e){ console.log(e); //表单的事件对象 console.log(e.target.value); //表单里的文本框内容 this.val = e.target.value; //将文本框内容 赋值给 data里的val 即使用v-bind又让数据进行双向绑定了 } } }; &lt;/script&gt; 计算属性和侦听器1. 计算属性 介绍: 处理数据后把数据缓存起来 使用数据的时候使用的缓存的数据,但是如果原数据修改了重新计算 语法&lt;template&gt; &lt;div&gt; &lt;h2&gt;计算属性computed&lt;/h2&gt; &lt;!-- 如果是字符串 取反操作实现 --&gt; &lt;p&gt;字符串:{{ msg }}&lt;/p&gt; &lt;!-- 不推荐: 模板语法里面写很多方法 多次使用不方便 --&gt; // split-先转换为数组， reverse-然后取反， join-最后转为字符串 &lt;p&gt;字符串-取反:{{ msg.split(\"\").reverse().join(\"\") }}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;button @click=\"msg = 'how are you'\"&gt;修改msg&lt;/button&gt; &lt;!-- 例子: v-for='' v-if不能在同一个元素使用 -- computed处理数据 --&gt; &lt;h4&gt;早市水果更新:&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=\"item in zaoshi2\" :key='item.id'&gt; {{item.fruit}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: \"hello vue\", zaoshi: [ { id: 100, fruit: \"苹果\", flag: false, }, { id: 101, fruit: \"阳光玫瑰\", flag: true, }, { id: 102, fruit: \"车厘子\", flag: false, }, { id: 103, fruit: \"榴莲\", flag: true, }, ], }; }, methods: { qufan() { console.log(\"执行了一次取反方法\"); return this.msg.split(\"\").reverse().join(\"\"); }, }, //计算属性: 对数据进行加工处理 缓存数据 computed: { msg2() { console.log(\"计算属性: 对数据进行加工处理 缓存数据\"); return this.msg.split(\"\").reverse().join(\"\"); }, //处理数据 zaoshi2(){ //过滤方法 返回的满足条件的数组 比如:[1,2,3,4] =&gt;[3,4] return this.zaoshi.filter((item)=&gt;{ // if(item.flag == true) { // return item.flag // } return item.flag }) } }, }; &lt;/script&gt; 2. 侦听器 介绍: Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化 &lt;template&gt; &lt;div&gt; &lt;h2&gt;侦听器-watch&lt;/h2&gt; &lt;p&gt;功能:监听数据修改了,然后做业务逻辑&lt;/p&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ inp:'', arr:[] } }, //侦听器--数据变化 (当前监听的是inp变化) watch:{ inp:function(n,o){ console.log('新值:',n ,'旧值:',o); //业务逻辑 比如输入东西后 网络请求 //模糊查询 } } } &lt;/script&gt; 3. computed和watch区别 （考点） 相同：computed和watch都是观察页面的数据变化的。 不同：computed：是计算属性，依赖其它属性值: 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化watch：没有缓存性，更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； Vue 的生命周期方法有哪些 一般在哪一步发请求生命周期：事物从诞生到消亡的过程Vue生命周期： v-if 和 v-show 的区别v-if: 控制元素的渲染或者销毁v-show:控制元素的 display:block/none 场景：频繁切换： v-show初次渲染优化：v-if Vue 修饰符有哪些v-for 为什么要加 key理解 Vue 的单向/双向 数据流首先了解一下数据绑定什么是绑定？比如当前href属性值取决于表达式school.url.toUpperCase()的结果，这两者之间就是有绑定关系，且通过v-bind指令完成数据绑定。 &lt;a v-bind:href=\"school.url.toUpperCase()\" v-bind:x=\"hello\"&gt;点我去{{school.name}}学习&lt;/a&gt; v-bind 单向数据原理前面学习的指令主要作用是将值插入到模板的内容当中但除了内容需要动态来决定外，某些属性也希望动态来绑定作用：动态绑定属性缩写：**:**预期：any (with argument) | Object (without argument)参数：attrOrProp (optional)v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到Vue进阶时介绍)在开发中，一般有哪些属性需要动态进行绑定呢？比如图片的链接src、网站的链接href、动态绑定一些类、样式等等例子：通过Vue实例中的data绑定元素的src和href，代码如下： 基本使用很多时候，我们希望动态的来切换class，比如：当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。 &lt;div id=\"app\"&gt; &lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt; &lt;!--&lt;img src=\"{{imgURL}}\" alt=\"\"&gt;--&gt; &lt;!-- 正确的做法: 使用v-bind指令 --&gt; &lt;img v-bind:src=\"imgURL\" alt=\"\"&gt; &lt;a v-bind:href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;!--&lt;h2&gt;{{}}&lt;/h2&gt;--&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=\"imgURL\" alt=\"\"&gt; &lt;a :href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', imgURL: 'https://img11.360buyimg.com/mobilecms/s350x250_jfs/t1/20559/1/1424/73138/5c125595E3cbaa3c8/74fc2f84e53a9c23.jpg!q90!cc_350x250.webp', aHref: 'http://www.baidu.com' } }) &lt;/script&gt; v-bind动态绑定class(对象语法) 绑定方式：对象语法含义是:class后面跟的是一个对象 直接通过{}绑定一个类&lt;h2 :class=\"{'active': isActive}\"&gt;Hello World&lt;/h2&gt; 也可以通过判断，传入多个值&lt;h2 :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=\"title\" :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 比如ul的li标签点击某个标签变颜色 &lt;div id=\"app\"&gt; &lt;!-- 当布尔值为true 这个类名1即 active 就会被添加到标签上 --&gt; &lt;!-- 一个 { } 表示对象 --&gt; &lt;h2 class=\"title\" v-bind:class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" v-bind:class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', isActive: true, isLine: true }, methods: { btnClick: function () { this.isActive = !this.isActive }, getClasses: function () { return {active: this.isActive} } } }) &lt;/script&gt; v-bind动态绑定class(数组语法) 数组语法的含义是:class后面跟的是一个数组。 直接通过{}绑定一个类&lt;h2 :class=\"['active']\"&gt;Hello World&lt;/h2&gt; 也可以传入多个值&lt;h2 :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：会有title/active/line三个类&lt;h2 class=\"title\" :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 例如： &lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"[active, line]\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', active: 'aaaaaa', line: 'bbbbbbb' }, methods: { getClasses: function () { return [this.active, this.line] } } }) &lt;/script&gt; 小案例 点击li标签变色（默认第一li为红色）分析： v-for绑定给li标签，同时v-on添加点击事件，并且li标签的class用v-bind动态绑定 使用v-for绑定到li标签上，自动遍历data中的数据，将下标（index）和每一项内容（item）用插值语法显示到页面 在data中添加一个isRed属性值为0，想让class样式显示，需要v-bind绑定的red值为true，即该值可以等等于index,因为index的第一个值就是0 v-on点击事件点击某一个li，将下标的值赋值给isRed，即当前点击的li标签的class样式显示 end~&lt;style&gt; .red { color: red; } &lt;/style&gt; &lt;!--作业需求: 点击列表中的哪一项, 那么该项的文字变成红色--&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=\"每一项,下标 in 数据源\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;li v-for=\"(item,index) in movie\" v-on:click=\"getColor(index)\" v-bind:class=\"{red:isRed==index}\" &gt;{{index}}--{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', data:{ isRed:0, movie:['海王','海尔兄弟','火影忍者','进击的巨人'] }, methods:{ getColor: function (index){ this.isRed = index console.log(this.isRed); } }, }) &lt;/script&gt; v-bind绑定style 一利用v-bind:style来绑定一些CSS内联样式在写CSS属性名的时候，比如font-size可以使用驼峰式 (camelCase) fontSize或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ v-model 双向数据原理Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。Vue中有两种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。备注： 双向绑定一般都应用在表单类元素上（如：input、select等） v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。&lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'哔哩哔哩', } }) &lt;/script&gt; 虚拟 DOM 是什么 有什么优缺点MVVM全称： Model-View-ViewModel ， Model 表示数据模型层。 view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。 Model层： 数据层数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。 View层： 视图层在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。 VueModel层： 视图模型层视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。 M：模型(Model) ：对应 data 中的数据 V：视图(View) ：模板 VM：视图模型(ViewModel) ： Vue 实例对象Vm（Vue实例对象）把左边的View和右边Model进行连接在一起 观察发现： data中所有的属性，最后都出现在了vm身上。 VM身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 执行过程 ：数据在data中经过 VM视图模型放到了页面View上页面上如果有地方需要更改要映射回数据就再给VM视图模型，然后视图模型再给data里的数据 &lt;!-- 1 准备好一个容器 也就是 view 视图 模板代码--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;!-- &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = fal se //阻止 vue 在启动时生成生产提示 const vm = new Vue({// 2 VM 视图模型ViewModel el:'#root', data:{ // 3 data里的是模型 model name:\"b站大学\", address:\"成都\", } }) console.log(vm) &lt;/script&gt; Vue的数据代理首先学习下 Object.defineProperty()方法Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。defineProperty()参数 Object.defineProperty(obj, prop, descriptor) obj 需要定义属性的对象 prop 需被定义或修改的属性名 descriptor 需被定义或修改的属性的描述符 例子：定义了一个person对象，里面包含name、sex属性和其它属性值。注意：age属性是通过defineProperty方法中 &lt;script type=\"text/javascript\"&gt; let number = 19 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { value:19, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value } }) console.log(Object.keys(person)) // Object.keys方法传入一个对象作为参数，可以把传入对象所有属性的属性名提取出来变成数组 console.log(person) &lt;/script&gt; Vue中的数据代理什么是数据代理数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） &lt;script type=\"text/javascript\" &gt; let obj = { x:100 } let obj2 = { y:200 Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; vue常用ui库移动端 mint-ui （http://mint-ui.github.io/#!/zh-cn） Vant（https://youzan.github.io/vant/#/zh-CN/home） VUX (https://vux.li/) pc端 element-ui（https://element.eleme.cn/2.13/#/zh-CN/component/installation） Ant Design of Vue（https://www.antdv.com/docs/vue/introduce-cn/） Avue (https://avuejs.com/) 常用webpack配置待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"}]},{"title":"axios学习","slug":"04-axios学习","date":"2022-04-17T06:12:00.000Z","updated":"2022-04-18T08:01:30.170Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://wuzimo233.github.io/posts/4.html","excerpt":"","text":"前置条件已经学习过ajax、Promise准备json-server包，快速搭建HTTP服务（用axios的时候需要向服务端发送请求即需要服务端这个角色来与axios结合做实践） json-server用于模拟服务端接口数据，可以根据json数据建立一个完整的web服务 1安装json-servernpm install -g json-server //查看版本号，安装成功 json-server -v 2在文件夹下创建一个db.json文件，存放一些数据。{ \"posts\": [ //文章 { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"《b站大学》\", \"author\": \"吴老师\" } ], \"comments\": [ //评论 { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }, { \"body\": \"喜大普奔\", \"postId\": 2, \"id\": 2 } ], \"profile\": { //个人信息 \"name\": \"typicode\" } } 3 启动服务进入终端。执行启动json-server命令:json-server --watch .\\db.json 认识axiosaxios 是什么?axios是目前前端使用非常广泛的基于 promise 的 HTTP 网络请求库，包括Vue/React也是推荐使用axios；本质是XMLHttpRequests请求 即ajax请求 axios 特性： 从浏览器中创建 XMLHttpRequests （浏览器中发送xml请求） 从 node.js 创建 http 请求 （在node.js中发送http请求） 支持 Promise API 相关操作 拦截请求和响应 转换请求数据和响应数据（对请求和响应的数据作转换） 取消请求 自动将结果转换成 JSON 数据 客户端支持防御 XSRF （阻止跨站攻击） axios安装 1 使用 npm安装:$ npm install axios 2 使用 yarn安装:$ yarn add axios 3 使用 jsDelivr CDN安装:&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.min.js\"&gt;&lt;/script&gt; console.log(axios); //ƒ() {for(var n=new Array(arguments.length),r=0;r&lt;n.length;r++)n[r]=arguments[r];return e.apply(t,n)} //建议使用国内CDN网速较快 //去这个网站引入 https://www.bootcdn.cn/axios/ axios的基本使用 前置：引入了axios准备四个按钮发送不同的请求 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; GET请求//获取按钮 const btns = document.querySelectorAll('button'); //第一个 （get 查询功能） btns[0].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'GET', //请求地址 刚启动好的json-server地址 且id为2的那篇文章 url: ' http://localhost:3000/posts/2' }).then(response =&gt; { console.log(response); }) } POST请求//添加一篇新的文章 （post 添加功能） btns[1].onclick = function () { //发送ajax请求 axios({ method: 'POST', //请求类型 url: ' http://localhost:3000/posts', //请求地址 data: { \"title\": \"招聘摄影\", //请求体 \"author\": \"小吴\" } }).then(response =&gt; { console.log(response); }) } PUT请求//更新文章 需要在url里加上id 比如这里要更新的是id为3的文章（put 更新功能） btns[2].onclick = function () { //发送ajax请求 axios({ method: 'PUT', //请求类型 url: ' http://localhost:3000/posts/3', //请求地址 data: { \"title\": \"招聘程序员吗\", //修改请求体的数据 \"author\": \"小瑶酱\" } }).then(response =&gt; { console.log(response); }) } DELETE请求//删除文章 （delete 删除功能） btns[3].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'DELETE', //请求地址 url: ' http://localhost:3000/posts/3', }).then(response =&gt; { console.log(response); }) } axios的其他发送请求使用request方法 发送 GET 请求 （接收一个对象类型参数）//获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ // axios() axios.request({ method:'GET', url:' http://localhost:3000/posts', // 返回结果依然是Promise对象 用then指定成功的回调 }).then((response) =&gt; { console.log(response); }) ; } //使用POST方法 发送post请求 增加数据//获取按钮 const btns = document.querySelectorAll('button'); btns[1].onclick = function(){ // axios() axios.post( 'http://localhost:3000/comments', { \"body\": \"喜大普奔\", \"postId\": 2 }).then(response =&gt; { console.log(response); }) } axios配置对象{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 baseURL: 'https://some-domain.com/api/', // `transformRequest` 对请求的数据做处理，处理后将结果像服务器发送 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 对响应的结果做一些改变，改变之后我们用自定义的回调去处理结果 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 对请求头信息做一个配置（身份校验） headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求体的设置 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时对coken的携带设置 withCredentials: false, //不携带 // `adapter` 对请求的适配器做设置 // 有两种一种是ajax、一种是node.js里发送http请求的 adapter: function (config) { /* ... */ }, // `auth` 对请求基础的验证设置用户名和密码 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // 响应结果的编码 responseEncoding: 'utf8', // `xsrfCookieName` 跨域请求标识对cookie的名称设置 xsrfCookieName: 'XSRF-TOKEN', // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 上传的一些回调 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 下载时的一些回调 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 对响应结果的成功做一个设置 什么情况下是成功的呢？默认值为响应状态码 大于等于200 小于300 validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 最大跳转的次数 默认5次 即向一个服务发送请求，它作了跳转后呢，我们是否需要让它继续往前进行请求 maxRedirects: 5, // 默认的 // 设置socket 文件的位置 作用是像docker的守护进程发送请求的 socketPath: null, // default // 对客户端的一些信息做一些设置 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 设置代理 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 对ajax请求作一个取消的设置 cancelToken: new CancelToken(function (cancel) { }) } axios的默认配置例子：点击按钮发送get请求//没有做默认配置时，每次访问都比较麻烦 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ axios({ method:'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log(response); }) } &lt;/script&gt; 使用默认配置后 //默认配置 axios.defaults.method = 'GET'; //设置默认的请求类型为 GET axios.defaults.baseURL = 'http://localhost:3000' //设置基础url btns[0].onclick = function () { axios({ url: '/posts', }).then(response =&gt; { console.log(response); }) //还有其他的默认配置项 // axios.defaults.params = {id:100}; 默认的请求url参数 即url后增加 ?id=100 // axios.defaults.timeout = 3000; 超时时间 axios创建实例对象主要用于：项目中接口数据服务不是来自于单一的服务器，比如有两个服务器A、B，都提供了数据服务。在发送请求时，比如给A发，就要去设置A的协议域名端口，如果用默认方法做只能满足一个服务器， &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 发送POST请求 &lt;/button&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //创建实例对象 /getJoke const duanzi = axios.create({ baseURL:'https://api.apiopen.top', timeout:2000 }); //这里duanzi 与 axios 对象的功能几近是一样的 duanzi({ url:'/getJoke', }).then((response)=&gt;{ console.log(response); }) duanzi.get('/getJoke').then((response) =&gt; { console.log(response.data); }) const another = axios.create({ baseURL:'http:b.com', timeout:2000 }) axios拦截器在请求或响应被 then 或 catch 处理前拦截它们。在发送请求之前，借助一些函数对请求的参数和内容作一些处理和检测。如果说都没有问题再去发送请求，有问题的话这个请求就停止或者取消。当服务器返回结果之后，可以通过自己指定的回调处理结果。那么响应拦截器可以在我们处理响应结果之前先对结果做一些预处理。如：失败了就对失败结果做一些提醒或者记录，还能对数据接口做一些格式化的处理。然后再交由我们自己自定义的回调来处理。如果有问题在响应拦截器中就处理掉了。执行顺序是，当用户发送请求后先执行请求拦截器成功/失败的回调，然后走响应拦截器成功/失败的回调，然后再走自定义的成功/失败的回调 一般情况// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); return config; }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }); 其他情况：请求拦截器成功但抛出错误，响应拦截器失败，自定义失败回调// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); // return config; throw '参数出了问题' //如果这里抛出错误即失败了，返回一个失败的Promise， //在执行后续的响应回调时就只能走失败的回调了， }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) 多个请求、响应的结果顺序请求拦截器 成功 2号请求拦截器 成功 1号响应拦截器 成功 1号响应拦截器 成功 2号自定义回调处理成功的结果{data: Array(2), status: 200, statusText: ‘OK’, headers: {…}, config: {…},&nbsp;…} // Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 1号'); //修改 config 中的参数 // config.params = {a:100}; return config; }, function (error) { console.log('请求拦截器 失败 1号'); return Promise.reject(error); }); axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 2号'); //修改 config 中的参数 config.timeout = 2000; return config; }, function (error) { console.log('请求拦截器 失败 2号'); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 1号'); return response; // return response; }, function (error) { console.log('响应拦截器 失败 1号') return Promise.reject(error); }); axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 2号') return response; }, function (error) { console.log('响应拦截器 失败 2号') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) axios取消请求 基本流程配置 cancelToken 对象缓存用于取消请求的 cancel 函数在后面特定时机调用 cancel 函数取消请求在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能点击按钮, 取消某个正在请求中的请求 在请求一个接口前, 取消前面一个未完成的请求 使用 canceltoken 取消请求Axios 的 cancel token API 基于cancelable promises proposal可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;axios取消请求&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 取消请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function(){ // 防止用户疯狂点击按钮发送请求 //检测上一次的请求是否已经完成 if(cancel !== null){ //取消上一次的请求 cancel(); } axios({ method: 'GET', url: 'http://localhost:3000/posts', //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function(c){ //3. 将 c 的值赋值给 cancel cancel = c; }) }).then(response =&gt; { console.log(response); //将 cancel 的值初始化 cancel = null; }) } //绑定第二个事件取消请求 btns[1].onclick = function(){ cancel(); } axios源码文件结构说明 ├── /dist/ # 项目打包后的文件即最终输出的axios整体文件 ├── /lib/ # 项目源码目录 │ ├── /adapters/ # 定义请求的适配器 xhr、http │ │ ├── http.js # 用来在node.js中向 远端服务发送HTTP请求的 │ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象) │ ├── /cancel/ # 定义取消功能 │ ├── /core/ # 一些核心功能 │ │ ├── Axios.js # axios 的核心主类 构造函数 │ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数 │ │ ├── InterceptorManager.js # 拦截器的管理器 │ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态 │ ├── /helpers/ # 一些辅助方法 │ ├── axios.js # 对外暴露接口 │ ├── defaults.js # axios 的默认配置 │ └── utils.js # 公用工具 ├── package.json # 项目信息 ├── index.d.ts # 配置 TypeScript 的声明文件 └── index.js # 入口文件 axios的创建过程axios对象创建过程模拟实现axios发送请求过程详解模拟实现axios发送请求axios拦截器工作原理模拟实现axios拦截器功能axios 取消请求工作原理模拟实现axios取消请求功能axios源码分析总结","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise学习","slug":"03-Promise学习","date":"2022-04-14T06:30:00.000Z","updated":"2022-04-18T13:59:32.062Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://wuzimo233.github.io/posts/3.html","excerpt":"","text":"认识 Promise 什么是 Promise 抽象表达: Promise 是一门新的技术(ES6 规范)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数 具体表达: 语法上来说: Promise 是一个构造函数从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 为什么要用 Promise指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题 什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用 终极解决方案? async/await 如何使用 PromisePromise 语法结构 语法结构： new Promise((resolve, reject) =&gt; { } 里面是一个函数类型的参数，参数里面的两个参数也是函数在花括号{ }里边包含一个异步操作,如果成功则调用 resolve ，同时只要 resolve 调用就会将 promise 对象 p 的状态设置为『成功』，如果失败则调用 reject，调完 reject 后会将 promise 对象 p 的状态设置为『失败』（即这两个可以修改 promise&gt;对象的状态）接着 promise 对象通过调用 then()方法去指定成功和失败时的回调如果成功就执行第一个回调函数，失败则执行第二个回调函数Promise 除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即下方Promise 形式实现案例的 n 值然后可以将 n 值传递给 resolve 和 reject 函数最后下方的 then 方法里的两个回调都能拿到这个结果值作为参数使用 Promise 初体验 案例：需求——点击抽奖按钮两秒后，告诉用户是否中奖，中奖的概率是百分之 30。如果中奖在页面中弹框告知恭喜中奖，没有就弹出再接再厉。 一般方法实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 定时器 setTimeout(() =&gt; { //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ alert(n+'恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券'); }else{ alert(n+'再接再厉'); } }, 1000); }) &lt;/script&gt; Promise 形式实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 使用 new Promise(接收一个函数参数) 创建实例 // resolve 解决 函数类型的数据 --成功时调用 // reject 拒绝 函数类型的数据 --失败时调用 const p = new Promise((resolve, reject) =&gt; { // promise对象可以包裹一个异步操作（直接将上方定时器拿过来） setTimeout(() =&gt; { //30% 1-100 1 2 30 //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ // Promise除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即这里的n值 // 可以将n值传递给resolve 和 reject函数 // 那么下方的then方法里的两个回调都能拿到这个结果值作为参数 resolve(n); // 调完resolve后会将 promise 对象 p 的状态设置为『成功』 }else{ reject(n); // 调完reject后会将 promise 对象 p 的状态设置为『失败』 } }, 1000); }); console.log(p); //调用 then（里边有两个回调函数参数） 方法 --- 每个promise对象上都有then方法 // 第一个回调是对象状态为成功时的回调，第二个是对象状态失败时的回调函数 // value 值 // reason 理由 p.then((value) =&gt; { alert('恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 ' + value); }, (reason) =&gt; { alert('再接再厉, 您的号码为 ' + reason); }); }) &lt;/script&gt; 实践练习 Promise 封装 AJAX// 需求点击按钮发送ajax请求拿到段子接口的数据 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 封装 AJAX 操作&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击发送 AJAX&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //接口地址 https://api.apiopen.top/getJoke //获取元素对象 const btn = document.querySelector('#btn'); // 给按钮绑定点击事件 btn.addEventListener('click', function(){ //首先创建 Promise 对象 p const p = new Promise((resolve, reject) =&gt; { //1.创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 get请求 给后边的接口发送 xhr.open('GET', 'https://api.apiopen.top/getJoke'); //3. 发送 xhr.send(); //4. 处理响应结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断响应状态码 2xx if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //控制台输出响应体 resolve(xhr.response); }else{ //控制台输出响应状态码 reject(xhr.status); } } } }); //调用then方法 p.then(value=&gt;{ console.log(value); }, reason=&gt;{ console.warn(reason); }); }); &lt;/script&gt; Promise的状态 『PromiseState』 的改变状态是Promise实例对象当中的一个属性，属性叫做 promiseState 有三种状态 pending 值未决定的、初始化的默认值 pending 变为 resolved / fullfilled 即成功 pending 变为 rejected 即失败说明: pending变化只有这 2 种情况, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据成功的结果数据一般称为 value, 失败的结果数据一般称为 reason Promise对象 『PromiseResult』的值保存着异步任务『成功/失败』的结果以下函数能够修改这个属性的值： resolve reject Promise的基本流程 首先通过new Promise 创造一个对象，在Promise内部封装异步操作。如果异步操作成功则调用resolve函数，resolve函数调用后会把Promise对象状态改为成功，成功在调用then方法时将调用的是第一个回调函数参数，返回一个新的promise对象如果在Promise内部封装的异步操作失败，则调用reject 函数，reject函数调用后会把Promise对象状态改为失败，失败之后调用的是then方法中的第二个回调函数参数，并且返回一个新的Promise对象 Promise的Api执行器函数Promise 构造函数: Promise (excutor) {}//new实例化对象需要接收一个参数，参数是一个函数类型的参数（也称之为执行器函数），而且函数当中有两个形参也是函数类型参数resolve、reject，这俩函数是内部定义的，异步任务成功就会调用resolve函数，失败就会调用reject函数。(1) executtor 函数: 执行器 (resolve, reject) =&gt; {}(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}说明: 执行器函数 executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行 let p = new Promise((resolv, reject) =&gt; // resolve('ok'); console.log(111); }) console.log(222); //结果控制台先打印111 ，后打印222。表明 p对象内部的代码是同步调用的 Promise.then方法Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}// 说明: then方法是用于指定回调的，传递两个参数，第一个参数是传递成功时的回调，第二个参数是传递失败时的回调。返回一个新的 promise 对象(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} Promise.catch方法Promise.prototype.catch 方法: (onRejected) =&gt; {}// 说明: catch() 方法是 then()的语法糖, 相当于: then(undefined, onRejected)，即只能指定失败的回调。 onRejected 函数: 失败的回调函数 (reason) =&gt; {let p = new Promise((resolv, reject) =&gt; // 修改Promise对象的状态 reject('error 失败了'); }) // 执行catch方法 p.catch(reason =&gt; { console.log(reason); }) Promise.resolve方法 Promise.resolve 方法: (value) =&gt; {}// 说明：它属于Promise函数对象，不是实例对象。接收一个参数，返回一个成功或失败的对象// 作用：就是快速得到一个Promise对象，还能封装一个值，将这个值转化为Promise对象 value: 成功的数据或 promise 对象 //如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象 //如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果 let zimo = Promise.resolve(\"I Love You\"); console.log(zimo); // Promise&nbsp;{&lt;fulfilled&gt;: 'I Love You' let p1 = Promise.resolve(new Promise((resolve, reject) =&gt; { resolve('OK'); // reject('Error'); })); p1.then((value) =&gt; { console.log(value); //ok },(reason)=&gt;{ console.log(reason); }) console.log(p1); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} let p2 = Promise.resolve(p1); console.log(p2); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} Promise.reject方法Promise.reject 方法: (reason) =&gt; {}说明: 快速返回一个失败的 promise 对象即便传入成功的Promise对象结果也是失败 reason: 失败的原因let p1 = Promise.reject(520); p1.catch((reason) =&gt;{ console.log(reason); // Promise&nbsp;{&lt;rejected&gt;: 520} }) console.log(p1); // 520 let p2 = Promise.reject('iloveyou'); let p3 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p2); // Promise&nbsp;{&lt;rejected&gt;: 'iloveyou'} console.log(p3); //Promise&nbsp;{&lt;rejected&gt;: Promise} Promise.all 方法Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败。let p1 = new Promise((resolve, reject) =&gt; { resolve('OK'); }) // let p2 = Promise.resolve('Success'); let p2 = Promise.reject('Error'); let p3 = Promise.resolve('Oh Yeah'); const result = Promise.all([p1, p2, p3]); console.log(result); //[PromiseState]]: \"rejected\" Promise.race 方法Promise.race 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 第一个改变状态的 promise对象就是最终的结果状态。let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }) let p3 = Promise.resolve('Oh Yeah'); let p2 = Promise.resolve('Success'); //调用 const result = Promise.race([p1, p3, p2]); console.log(result); // [[PromiseState]]: \"fulfilled\" // [[PromiseResult]]: \"Oh Yeah\" Promise的几个关键问题如何改变 promise 的状态? 第一种方式 调用 resolve 函数: 如果当前Promise对象是 pending状态就会变为fulfilled(resolve) 第二种方式 调用 reject 函数: 如果当前Promise对象是 pending状态就会变为 rejected 第三种方式 抛出异常: 如果当前是 pending 就会变为 rejectedlet p = new Promise((resolve, reject) =&gt; { //初始化状态是pending //第一种方式 调用 resolve 函数 // resolve('ok'); // pending =&gt; fulfilled (resolved) //第二种方式 调用 reject 函数 // reject(\"error\");// pending =&gt; rejected //3. 抛出错误 throw '出问题了'; //pending =&gt; rejected }); console.log(p); 一个 promise 指定多个成功/失败回调函数, 都会调用吗?简单说问题是：用then方法为一个Promise对象去指定多个回调，这些回调是否都会执行？答案：当 promise 改变为对应状态时都会调用 let p = new Promise((resolve, reject) =&gt; { resolve('OK'); }); ///指定回调 - 1 p.then(value =&gt; { console.log(value); }); //指定回调 - 2 p.then(value =&gt; { alert(value); }); 改变 promise 状态和指定回调函数谁先谁后?答案： 都有可能 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promise对象改变状态后才执行 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promi对象改变状态后才执行 }); p.then(value =&gt; { console.log(value); },reason=&gt;{ }) 如何先改状态再指定回调?① 在执行器中直接调用 resolve()/reject()② 延迟更长时间才调用 then() 什么时候才能得到数据?① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 promise.then()返回的新 promise 的结果状态由什么决定?(1) 简单表达: 由 then()指定的回调函数执行的结果决定(2) 详细表达:① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 promise 如何串连多个操作任务?(1) promise 的 then()返回一个新的 promise, 即可以在后边接着调用then()方法，可以看成 then()方法的链式调用(2) 通过 then 的链式调用串连多个同步/异步任务 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //异步任务 }); p.then(value =&gt; { return new Promise((resolve, reject) =&gt; { resolve(\"success\"); }); }).then(value =&gt; { //这里的Promise状态由他指定的回调函数的返回值绝定，此处回调函数没写返回值即为Undefined 所以这里的then方法返回结果就是一个成功的Promise且成功的结果就是回调函数返回的结果Undefined，因为成功了所以后边的then方法也会执行第一个回调函数，并且输出前边成功的结果所以依然是Undefined console.log(value); // success }).then(value =&gt; { console.log(value); //undefined }) promise 异常传透?(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理例如：下方启动了一个Promise，后续用then方法又进行了几个其他的任务，这时候只需要在最后的位置去指定失败的回调就可以。 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); // reject('Err'); }, 1000); }); p.then(value =&gt; { // console.log(111); throw '失败啦!'; }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); //失败啦! }); 中断 promise 链?(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }); p.then(value =&gt; { console.log(111); // 111 //有且只有一个方式 返回一个pending状态的Promise对象 return new Promise(() =&gt; {}); //下方的then方法因为没有发现前边的Promise对象状态发生改变所以就不执行了 }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); }); 自定义（手写）Promise(后续学习)定义整体结构Promise 构造函数的实现promise.then()/catch()的实现Promise.resolve()/reject()的实现Promise.all/race()的实现Promise.resolveDelay()/rejectDelay()的实现ES5 function 完整版本ES6 class 完整版本 async 与 awaitasync 函数 函数的返回结果为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定//和then方法返回规则一摸一样 async function main(){ //1. 如果返回值是一个非Promise类型的数据 // return 521; //2. 如果返回的是一个Promise对象 // return new Promise((resolve, reject) =&gt; { // // resolve('OK'); // reject('Error'); // }); //3. 抛出异常 throw \"Oh NO\"; //[PromiseState]]: \"rejected\" [PromiseResult]]: \"Oh NO\" } let result = main(); console.log(result); await 表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 async function lala(){ let p = new Promise((resolve, reject) =&gt; { // resolve('OK'); reject('Error'); }) //1. 右侧为promise的情况 await 返回的是 promise 成功的值即 'ok' // let res = await p; // console.log(res); //ok //2. 右侧为其他类型的数据 //let res2 = await 20; //console.log(res2); //20 //3. 如果promise是失败的状态 try{ let res3 = await p; }catch(e){ console.log(e); //抛出一个错误 使用try...catch } } lala() async与await结合/** * 读取同级目录resource文件夹下 有1.html 2.html 3.html 的文件内容 想去读取到 */ const fs = require('fs'); const util = require('util'); // util里有个方法可以将api转换成一个Promise形态的函数 const mineReadFile = util.promisify(fs.readFile); //回调函数的方式 // fs.readFile('./resource/1.html', (err, data1) =&gt; { // if(err) throw err; // fs.readFile('./resource/2.html', (err, data2) =&gt; { // if(err) throw err; // fs.readFile('./resource/3.html', (err, data3) =&gt; { // if(err) throw err; // console.log(data1 + data2 + data3); //读取到文件信息 // }); // }); // }); //async 与 await方式 就用不到回调函数 // 1.首先写一个async函数 async function main(){ try{ //2.读取第一个文件的内容 let data1 = await mineReadFile('./resource/1x.html'); let data2 = await mineReadFile('./resource/2.html'); let data3 = await mineReadFile('./resource/3.html'); console.log(data1 + data2 + data3); }catch(e){ // console.log(e); // Error: ENOENT: no such file or directory...... console.log(e.code); // ENOENT } } main(); async与await结合发送AJAX&lt;button id=\"btn\"&gt;点击获取段子&lt;/button&gt; &lt;script&gt; //一般使用axios封装好的 function sendAJAX(url){ return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.responseType = 'json'; xhr.open(\"GET\", url); xhr.send(); //处理结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //成功的结果 resolve(xhr.response); }else{ reject(xhr.status); } } } }); } //段子接口地址 https://api.apiopen.top/getJoke let btn = document.querySelector('#btn'); btn.addEventListener('click',async function(){ //获取段子信息 let duanzi = await sendAJAX('https://api.apiopen.top/getJoke'); //发送ajax请求的函数返回的结果是一个Promise对象 console.log(duanzi); }); &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"Ajax学习","slug":"02-ajax学习","date":"2022-04-14T02:22:11.000Z","updated":"2022-04-15T17:25:48.460Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://wuzimo233.github.io/posts/2.html","excerpt":"","text":"认识 Ajax什么是 Ajax Ajax 是一种异步请求数据的 web 开发技术，对于改善用户的体验和页面性能很有帮助。刚好回顾下什么是异步同步，大部分的请求是同步的，就是说我必须等待后台请求给我返回结果了才能往下操作。通俗讲的话，我要去烧水、水热了后去洗碗、扫地。同步来做的话就是依次等待水烧热后我再去洗碗，洗了碗后我再去扫地。异步做的话我把水壶接通电源（发送请求）、接着水壶它烧它的，我去扫地了，可能扫完地后水热了，再用水壶的水来洗碗。还可以说我今天一天没有逛朋友圈，晚上终于有空翻朋友圈，好不容易翻到了上午的朋友圈，突然觉得某个动态有意思我想评论一下或者点赞，如果页面上有刷新，那我点赞后直接就刷新了朋友圈，我又得从新翻很久才能回到刚才的动态页面。如果是不会刷新，即点赞后马上就显示了点赞记录。这就是无刷新技术通过Dom操作来实现的效果。所以Ajax通常会结合Dom一起操作。简单地说，在不需要重新刷新整个页面的情况下，Ajax 通过异步请求加载后台数据，能在网页的局部更新数据。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax 的目的是提高用户体验，较少网络数据的传输量。同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。AJAX=Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)Ajax 不是一门编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术 传统的网页(即不用 ajax 技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。 增加 B/S 体验性 （B/S 未来的主流，持续增长） Ajax 原理是什么在解释 Ajax 原理之前，我们不妨先举个 “领导想找小李汇报一下工作” 例子，领导想找小李问点事，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作。 Ajax 请求数据流程与“领导想找小李汇报一下工作”类似。其中最核心的依赖是浏览器提供的 XMLHttpRequest 对象，它扮演的角色相当于秘书，使得浏览器可以发出 HTTP 请求与接收 HTTP 响应。浏览器接着做其他事情，等收到 XHR 返回来的数据再渲染页面。 理解了 Ajax 的工作原理后，接下来我们探讨下如何使用 Ajax 利用 AJAX 可以做：注册时，输入用户名自动检测用户已经存在登陆时，提示用户密码错误删除数据时，将行 ID 发送到后台，后台在数据库中删除，数据库删除成功后，在页面 DOM 中将数据行也删除我们可以使用前端的一个标签来伪造一个 ajax 的样子。iframe 标签 &lt;!-- iframe 元素会创建包含另外一个文档的内联框架（即行内框架） --&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function () { var myDate = new Date(); //获取当前时间 并传递给p标签里的span document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage() { var targetUrl = document.getElementById('url').value; //获取input框的网址 console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; //把网址传给内联标签iframe标签的src属性 } &lt;/script&gt; 这里简单的制造了一个在当前页面打开其他页面不刷新整体页面的场景，ajax 可以实现更多更高级的类似功能 Ajax 的使用原生Ajax 的使用1.创建 Ajax 核心对象 XMLHttpRequest(记得考虑兼容性) var xhr=null; if (window.XMLHttpRequest) { // 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); } else { // 兼容 IE6, IE5 xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 2.向服务器发送请求 xhr.open(method,url,async); send(string);//post请求时才使用字符串参数，否则不用带参数。 。。。太麻烦了 后期再学原生吧 jQuery.ajax 的使用浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery Ajax 本质就是 XMLHttpRequest，对他进行了封装，方便调用！纯 JS 原生实现 Ajax 暂时不去了解了，直接使用 jquery 提供的，方便学习和使用，避免重复造轮子，有空再去了解下 JS 原生 的XMLHttpRequest把···Ajax 的核心是XMLHttpRequest对象(XHR)。XHR 为向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。 使用 jQuery 需要先从官网下载jQuery.js并导入到文件就可以使用$符号，它是jquery中代表jquery对象的引用,“jQuery”是核心对象。通过该对象可以获取jQuery对象，调用jQuery提供的方法等。$ &lt;==&gt; jQuery 通过 jQuery AJAX 方法，能够从远程服务器上请求文本、HTML、XML 或 JSON – 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery 中发起 Ajax 请求最常用的三个方法如下：$.get()$.post()$.ajax() $.get()函数的语法 jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求 将服务器上的资源请求到客户端来进行使用。 $.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 $.get()发起不带参数的请求使用 $.get() 函数发起不带参数的请求时，直接提供请求的 URL 地址和请求成功之后的回调函数即可，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', function(res) { console.log(res) // 这里的 res 是服务器返回的数据 }) $.get()发起带参数的请求使用 $.get() 函数发起带参数的请求时，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function(res) { console.log(res) }) $.post()函数的语法 jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。 $.post() 函数的语法如下： $.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 使用 $post() 向服务器提交数据的示例代码如下： $.post( 'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址 { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据 function(res) { // 回调函数 console.log(res) } ) $.ajax()函数的语法 相比于$.get()和$.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数 它允许我们对 Ajax 请求进行更详细的配置 $.ajax() 函数的基本语法如下： $.ajax({ type: '', // 请求的方式，例如 GET 或 POST url: '', // 请求的 URL 地址 data: { },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) 使用$.ajax()发起GET请求使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 ‘GET’ 即可： $.ajax({ type: 'GET', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址 data: { id: 1 },// 这次请求要携带的数据 success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) 使用$.ajax()发起POST请求使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 ‘POST’ 即可： $.ajax({ type: 'POST', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的 URL 地址 data: { // 要提交给服务器的数据 bookname:&nbsp;'水浒传', author:&nbsp;'施耐庵', publisher:&nbsp;'上海图书出版社' }, success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) jQuery.ajax(…) 部分参数： url：请求地址（待载入页面的URL地址） data：要发送的数据（待发送给后台的值key/value参数） success：载入成功之后执行的回调函数(全局) type：请求方式，GET、POST（1.9.0之后用method） // 下边的了解下不常用 headers：请求头 contentType：即将发送信息至服务器的内容编码类型(默认: “application/x-www-form-urlencoded; charset=UTF-8”) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 “xml”: 将服务器端返回的内容转换成xml格式 “text”: 将服务器端返回的内容转换成普通文本格式 “html”: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 “script”: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 “json”: 将服务器端返回的内容转换成相应的JavaScript对象 “jsonp”: JSONP 格式使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 接口相关知识 接口的概念 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。例如：www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求)www.liulongbin.top:3006/api/addbook 添加图书的接口（POST请求） 分析接口的请求过程 通过GET方式请求接口的过程 通过POST方式请求接口的过程 Ajax的优缺点优点1.无刷新更新数据。AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。2.异步与服务器通信。AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。3.前端和后端负载平衡。AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。4.基于标准被广泛支持。AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 5.界面与应用分离。Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点1.AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。2.AJAX的安全问题。3.因为网络延迟需要给用户提供必要提示","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-04-12T17:17:00.000Z","updated":"2022-04-15T06:14:16.957Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wuzimo233.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？因为学习一些知识总是学了就忘，或者敲了不复习，记得手写笔记也根本不爱翻动。花了大半天时间搭建个博客来记录未来学到的知识，勤能补拙吧~ 展望博客我会整理一些个人所学的知识（前端方向和一些其它数码、科技、摄影先暂时想这么多）或生活方面有兴趣的事发到博客上。 关于博主普普通通的社畜。。 勇敢就是，在你还没开始的时候就知道自己会输，但依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。 ​ go on！","categories":[{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"},{"name":"Vuex","slug":"Vuex","permalink":"https://wuzimo233.github.io/tags/Vuex/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wuzimo233.github.io/tags/uni-app/"},{"name":"vue案例","slug":"vue案例","permalink":"https://wuzimo233.github.io/tags/vue%E6%A1%88%E4%BE%8B/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"},{"name":"vue","slug":"vue","permalink":"https://wuzimo233.github.io/tags/vue/"},{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}