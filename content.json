{"meta":{"title":"zimo","subtitle":"zimoの博客","description":"人要接受自己的有限性，人的逻辑、理性、阅读都是有限的，整个人就是在偏见之中。人这一生就是在走出偏见。","author":"Zimo","url":"https://wuzimo233.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-04-14T05:28:56.000Z","updated":"2022-04-16T01:46:42.290Z","comments":false,"path":"about/index.html","permalink":"https://wuzimo233.github.io/about/index.html","excerpt":"","text":"普通人埼玉“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：普通人琦玉（萌新up） QQ：2772459092 座右铭：昨日之深渊,今日之浅谈"},{"title":"","date":"2022-04-15T18:40:45.848Z","updated":"2022-04-15T18:40:33.275Z","comments":true,"path":"bangumis/index.html","permalink":"https://wuzimo233.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-15T09:12:19.000Z","updated":"2022-04-15T09:30:45.183Z","comments":false,"path":"categories/index.html","permalink":"https://wuzimo233.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-15T09:33:49.000Z","updated":"2022-04-15T09:34:52.986Z","comments":true,"path":"link/index.html","permalink":"https://wuzimo233.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://wuzimo233.github.io/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-04-15T09:38:28.000Z","updated":"2022-04-15T09:38:20.951Z","comments":false,"path":"comments/index.html","permalink":"https://wuzimo233.github.io/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-15T09:09:39.000Z","updated":"2022-04-15T09:29:33.704Z","comments":false,"path":"tags/index.html","permalink":"https://wuzimo233.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-13T13:05:50.468Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wuzimo233.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wuzimo233.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-16T02:11:10.000Z","updated":"2022-04-16T02:18:08.424Z","comments":false,"path":"List/videos/index.html","permalink":"https://wuzimo233.github.io/List/videos/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-16T02:11:08.265Z","comments":false,"path":"List/movies/index.html","permalink":"https://wuzimo233.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-04-13T16:19:21.819Z","comments":false,"path":"List/music/index.html","permalink":"https://wuzimo233.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wuzimo233.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wuzimo233.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue-图书管理案例","slug":"10-Vue图书管理案例","date":"2022-04-26T04:00:00.000Z","updated":"2022-04-27T17:15:51.315Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://wuzimo233.github.io/posts/11.html","excerpt":"","text":"前置条件 安装Visual Studio Code（代码编辑器） 电脑已安装node.js 配置好vue相关文件 开始构建 电脑任意位置新建文件夹命名为”Vue-图书管理” 新建文件index.html 并创建基本html结构 因为是局部使用vue ，需要cdn方式引入Vue &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; 开始 new vue实例 并赋值为vm，在其内部构建 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ }, methods:{ } }) &lt;/script&gt; 将data里放入图书的数组数据 data:{ books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"20512\", }, { id: 4, name: \"西游记\", price: \"212\", }, ], }, 布局基本html样式 &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"\"&gt;编辑&lt;/a&gt; | &lt;a href=\"\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 增加添加图书功能 &lt;script&gt; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ obj:{ id:'', name:'', price:'', }, newobj:'', num:'', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ submit(){ // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.o // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newob // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, } }) &lt;/script&gt; 编辑图书功能 &lt;body&gt; &lt;h2&gt;图书管理&lt;/h2&gt; &lt;div id=\"app\"&gt; &lt;div &gt; 编号：&lt;input type=\"text\" v-model=\"obj.id\" :disabled=\"isDisabled\"&gt; 名称：&lt;input type=\"text\" v-model=\"obj.name\"&gt; 价格：&lt;input type=\"text\" v-model=\"obj.price\"&gt; &lt;button type=\"submit\" @click=\"submit\" :disabled=\"noSubmit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;p&gt;图书总数: {{num}}&lt;/p&gt; &lt;table border=\"1\" cellspacing='0' width=\"300px\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"(item,index) in books\" :key=\"item.id\"&gt; &lt;td&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.price}}&lt;/td&gt; &lt;td&gt; &lt;a href=\"##\" @click.prevent=\"editor(index)\"&gt;编辑&lt;/a&gt; | &lt;a href=\"##\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip= false; const vm = new Vue({ el:'#app', //获取vue的边界element元素 即展示的区域 data:{ noSubmit:false, //禁止提交按钮的状态 isDisabled:false, //默认可以点击 indexData:'', //存储index标识 obj:{ id:'', name:'', price:'', }, newobj:'', num:'2', books: [ { id: 1, name: \"三国演义\", price: \"12\", }, { id: 2, name: \"水浒传\", price: \"20\", }, { id: 3, name: \"红楼梦\", price: \"21\", }, { id: 4, name: \"西游记\", price: \"22\", }, ], }, methods:{ // 提交按钮 submit(){ // 判断是否是提交新数据还是修改旧数据 if(this.isDisabled) { //编辑功能: // 方法 1： 获取index 找操作的行元素 修改它 // console.log('编辑'); // console.log('编辑的当前行',this.books[this.indexData]); // this.books[this.indexData].name = this.obj.name // this.books[this.indexData].price = this.obj.price // 方法 2： 找id 获取编辑的id == books里面的id // 使用方法 some 查找原数组里是否有某元素 如果有返回true // ele 可以获取books数组的每一项 this.books.some( (ele) =&gt; { if( ele.id == this.obj.id){ //这个ele就是编辑的数据 ele.name = this.obj.name ele.price = this.obj.price return true } }) // 释放禁止按钮 this.isDisabled = false; }else { //添加功能 // 1.获取用户输入的信息 并保存到data里的obj里 this.newobj = this.obj // 2. 追加数组 将obj对象推入data中 books里 this.books.push(this.newobj) } // 3. 清空输入框的信息 this.obj = { id:'', name:'', price:'', } }, // 编辑按钮 editor(index){ //1 获取当前行的数据 渲染到文本框中 console.log(this.books[index]); // this.obj.id = this.books[index].id // this.obj.name = this.books[index].name // this.obj.price = this.books[index].price this.obj = this.books[index] // 2. 编辑的时候--编号禁止操作 this.isDisabled = true; // 3. 存储index下标---目的：提交的时候 修改的是哪个数据用 this.indexData = index; } }, //侦听器 watch:{ \"obj.name\":function(val){ console.log('监听了数据变化',val); var flag = this.books.some(ele =&gt; { return ele.name == val }) if(flag) { this.noSubmit = true alert('已经存在相同名称书籍') } else { this.noSubmit = false } } } }) &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"案例","slug":"案例","permalink":"https://wuzimo233.github.io/tags/%E6%A1%88%E4%BE%8B/"}]},{"title":"Vue路由拦截","slug":"09-Vue登录拦截案例","date":"2022-04-20T17:28:00.000Z","updated":"2022-04-22T01:23:20.678Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://wuzimo233.github.io/posts/9.html","excerpt":"","text":"路由拦截案例：从零开始创建一个新的项目安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve 配置路由组件 配置路由组件 – login登录界面 layout-布局界面（首页-新闻-我的） 简单说就是 layout组件里包含首页、新闻、我的 等界面，而在login组件里包含登录，且login和layout是平级的关系 删除HomeView.vue里的默认信息改名为Home，添加 首页 AboutView.vue组件改名About，里面 h1信息This is an about page改为 我的 添加News.vue组件，添加h1新闻界面 在views下新建Login组件，添加h1登录界面 在views下新建Layout组件 配置路由router下的index.js","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"TEST","slug":"test","date":"2022-04-20T08:15:00.000Z","updated":"2022-04-20T17:27:34.667Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://wuzimo233.github.io/posts/10.html","excerpt":"","text":"使用hexo发布文章遇到的问题使用两个花括号报错","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"JS进阶学习","slug":"08-JS进阶学习","date":"2022-04-18T13:53:00.000Z","updated":"2022-04-18T14:26:33.665Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://wuzimo233.github.io/posts/8.html","excerpt":"","text":"ES6高级待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue进阶知识学习","slug":"06-Vue进阶学习","date":"2022-04-18T13:42:00.000Z","updated":"2022-04-27T17:39:14.666Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://wuzimo233.github.io/posts/6.html","excerpt":"","text":"该页面假设你已经阅读过了组件基础。如果你还对组件不太了解，推荐你先阅读它。 注册局部组件 创建一个组件Mycomp.vue 在需要用到的地方引入：import Mycomp from './components/Mycomp.vue' 注册组件export default { name: 'App', components: { Mycomp } } 使用组件在 template &lt;Mycomp&gt;&lt;/Mycomp&gt; 组件组成 template 视图 script 逻辑 style 样式 全局组件 注册全局组件 在Vue对象身上有个Vue.component() 注册全局组件 在所有的组件中 不需要引入 可以直接使用 语法：Vue.component(‘my-component-name’, { // ... 选项 ... }) 代码演示 // import Vue from 'vue'//运行时：vue.runtime.js import Vue from 'vue/dist/vue' /注册全局组件(放到main.js) // Vue.component('组件名称',{内容配置}) Vue.component('my-comp',{ //视图 template :template作为属性使用 必须vue.js （完整版的vue.js） 默认引入-运行时-vue.runtime.js template:'&lt;div&gt; &lt;h2&gt;我是一个全局组件&lt;/h2&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/div&gt;', //数据 data(){ return { msg:'hello vue全局组件' } }, //方法 methods:{ } }) 全局组件–可以挂载创建好的局部组件 注册全局import MyBanner from ‘./components/MyBanner.vue’// Vue.component(‘MyBanner’,MyBanner)Vue.component(MyBanner.name,MyBanner) 组件中的data为什么是函数答案避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。 computed和watch的区别action 与 mutation 的区别 mutation 是同步更新， $watch 严格模式下会报错 action 是异步操作，可以获取数据后调用 mutation 提交最终数据 Vue 组件通讯有哪几种方式父传子通过props传递父亲提供数据通过属性 props传给儿子；儿子通过 $on 绑父亲的事件，再通过 $emit 触发自己的事件（发布订阅）利用父子关系 $parent 、 $children 子传父在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。父组件： &lt;child @receive = ‘receive’ /&gt;子组件: this.$emit(‘receive’,’传递的数据’) 兄弟组件传值通过中央通信 let bus = new Vue()prop 验证，和默认值 v-for 为什么要加 keyv-model 原理怎样理解 Vue 的单向数据流Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。 虚拟 DOM 是什么 有什么优缺点 谈一下对 vuex 的个人理解vuex是什么Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 怎么使用vuexvuex中有几个核心属性，分别是什么？ 一共有5个核心属性，分别是: state 唯一数据源,Vue 实例中的 data 遵循相同的规则 getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值. mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发 action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作 module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。 路由页面管理（vue-router）什么是vue-router怎么使用vue-router怎么定义vue-router的动态路由？怎么获取传过来的动态参数？vue-router 路由钩子函数是什么 执行顺序是什么路由拦截方法待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"}]},{"title":"JS基础知识","slug":"07-JS基础学习","date":"2022-04-17T17:00:00.000Z","updated":"2022-04-22T17:59:48.397Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://wuzimo233.github.io/posts/7.html","excerpt":"","text":"JavaScript基础知识点了解 JavaScriptJavaScript是什么 JavaScript是一种运行在客户端（浏览器）高级的、解释型的编程语言的，实现人机交互效果 由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持 JavaScript乍一听与Java在名字上相似，但其实是雷锋与雷锋塔、老婆和老婆饼的关系hhh 一般简称JS，以下都以JS称呼 JS的作用（做什么） 网页特效 （监听用户的一些行为让网页做出对应的反馈） 表单验证 （针对表单数据的合法性进行判断） 数据交互 （获取后台的数据，渲染到前端页面） 服务端编程（node.js） JS的组成（有什么）JS 是由ECMAScript和WebApi 组成。WebApi又由DOM（页面文档对象模型）和BOM（浏览器对象模型）构成 ECMAScript是由网景的布兰登·艾克开发的一种脚本语言的标准化规范；最初命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript[1]。 DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作 Bom 操作浏览器，比如页面弹窗，检测窗口宽度，存储数据到浏览器等 JS的位置内部引入 直接在HTML文件中引入（一般在标签的底部使用）&lt;script&gt; alert('我是内部引入的JS') &lt;/script&gt; 外部引入 是指将JS文件外置在HTML文件的外部，在head标签内引入相对路径中的JS文件 使代码更加有序，易于复用，且没有了脚本的混合，HTML也会更加易读&lt;head&gt; &lt;script src=\"./my.js\"&gt;&lt;/script&gt; &lt;/head&gt; 内联使用 在标签内部使用&lt;button onclick=\"alert('我是内联JS')\"&gt;我是按钮&lt;/button&gt; JS注释 单行注释 // xxx 多行注释 /* xxx */ 字面量 了解什么是字面量前，先知道什么是语法？ 是人和计算机打交道的规则—我们按照这个规则去敲代码 比如输入语法：document.write('输出的文字-文字展示到页面') document.write('&lt;h1&gt;我是嵌套的h1标签&lt;/h1&gt;') alert('要输出的内容-弹框形式展示到页面') console.log('控制台打印的内容') 在计算机科学中，字面量（literal）是在计算机中描述 事/物比如: 初级前端开发薪水是：8k 此时8k就是数字字面量 ‘hello world’ ：这是字符串字面量 还有其他数组字面量、对象字面量 变量变量是什么？ 通俗来讲：变量是计算机存储数据的“容器” 白话：变量就是一个装东西的盒子 变量不是数据本身，它们仅仅是一个用于存储数值的容器，可以理解为是一个个用来装东西的盒子~例如：用户在网页输入自己姓名或者电话等信息时候，就是通过变量存储。 变量的声明方式在JS中创建变量被称为声明变量，JS中变量声明又分为显示声明和隐式声明。其中显示声明中，声明关键字有var、let、const、function、class、import let 变量名 语法：声明关键字 + 变量名 let 即关键字（let：允许、让、要），所谓关键字是系统提供的专门用来声明（定义）变量的词语 注意let不能多次声明一个变量名 可以一次声明多个变量 let age=18,name=’zimo’;// 声明关键字 + 变量名 let age; age = 18; // 变量声明后一般会赋值 也可以连写let age = 18; age = 19; // 变量可以更新值 document.write(age); 案例：用户输入姓名后，页面显示刚才用户输入的姓名&lt;script&gt; let name = (prompt('请输入您的姓名')) document.write(name) &lt;/script&gt; 案例：交换变量的值需求：2个不同变量的变量去交换其值。&lt;script&gt; let num1 = 10 let num2 = 20 let num3 = '' num3 = num1 num1 = num2 num2 = num3 console.log(num1,num2); &lt;/script&gt; 变量本质先了解一下内存：是计算机存储数据的地方，相当于一个空间变量：是程序在内存中申请的一块用来存放数据的小空间 变量的命名规则与规范 不能用关键字比如：let var if for等 只能使用下划线、字母、数字、$组成，且数字不能开头 字母严格区分大小写 起名要有意义 遵守小驼峰命名法 （第一个单词首字母小写，后面每个单词首字母大写，如：UserName） 拓展 let 与 var 区别 let为了解决var的一些问题 var可以先使用 在声明（不合理） var声明过的变量可以重复声明（不合理） 比如变量提升、全局变量、没有块级作用域等等","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue基础知识学习","slug":"05-Vue基础学习","date":"2022-04-17T11:47:00.000Z","updated":"2022-04-26T03:52:07.847Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://wuzimo233.github.io/posts/5.html","excerpt":"","text":"Vue的安装安装环境安装Visual Studio Code 官网地址：(https://code.visualstudio.com/)下载安装 Visual Studio Code(VS Code)是微软2015年推出的一个轻量但功能强大的源代码编辑器，基于 Electron 开发，支持 Windows、Linux 和 macOS 操作系统。内置了对JavaScript，TypeScript和Node.js的支持并且具有丰富的其它语言和扩展的支持，功能超级强大。 简单来说就是我们编写代码的必备工具 安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 安装vue脚手架（vue-cli）官网地址：(https://cli.vuejs.org/zh/guide/installation.html) Window + R键打开运行界面，并输入cmd，点击确定。 输入命令：npm install -g @vue/cli 安装脚手架 或者 yarn global add @vue/cli 安装（前提先安装yarn 使用： npm i yarn -g） vue –version 或 vue -V 查看当前版本号 创建项目配置下载地址 （如果出现Unexpected token .. in JSON at position …. 那么执行） 下载慢可以切换成淘宝的国内镜像：npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功npm config get registry 强制清除npm缓存：npm cache clean –force 再执行安装npm：npm install -g npm 通过命令创建 任选一个文件夹位置创建，例如桌面的一个新建文件夹里 将新建文件夹拖入vscode里面 将鼠标移动到该文件夹上 右键终端打开 输入 vue create xxx (xxx是项目的名称为小写英文) 后续就根据项目配置进行选择，上下箭头是移动，空格是确认选择，回车是执行。如果没有，直接回车 运行项目 进入项目目录！！！ npm run serve 运行或者 yarn serve Vue介绍 Vue是渐进式（渐进式：项目中可以逐步使用vue框架 可以使用一部分 或者是整个项目） JavaScript 框架 框架为单页面的应用程序 （Vue项目入口：只有一个页面 index.html ） 跳转的页面路由功能- 路由 （其他页面组件） 框架里面使用的是虚拟DOM 没有js BOM DOM 特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。 Vue的优缺点优点： 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了angular的特点，在数据操作方面更为简单；组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。缺点： 单页面应用程序，首页加载速度慢 不利于搜索引擎优化 Vue的使用局部使用Vue 引入 Vue 的cnd网址 或者是下载到本地js文件 （类似：jquery.js） 创建vue实例 代码演示&lt;head&gt; //引入js文件夹里的vue &lt;script src=\"./JS/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 使用vue --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;这是vue的区域了 app--&lt;/p&gt; &lt;p&gt;获取vue的信息：{{msg}}&lt;/p&gt; &lt;/div&gt; &lt;!-- 创建vue实例 --&gt; &lt;script&gt; const vm = new Vue({ el:'#app',//获取element元素 data:{ msg:'hello vue', } }) &lt;/script&gt; &lt;/body&gt; 搭建vue项目1.兼容性Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 2.安装nodejs Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。 通俗点讲 Node.js是一个JavaScript编程语言的运行环境，在没有node.js之前，JavaScript代码几乎只能在浏览器中运行，通过浏览器解释执行。浏览器其实也是JavaScript的一个运行环境，JavaScript在浏览器中运行主要是面向客户端这方面的。后来node.js诞生了，JavaScript就可以在node.js中来运行了，JavaScript可以基于node.js环境做服务端开发。所以node.js也是JavaScript的服务端运行环境。 官方下载地址(https://nodejs.org/en/) 或者中文网站(https://nodejs.org/zh-cn/download/) 一般选LTS长期稳定版嘛 基本功能都差不多，点击下载并安装 安装时，安装路径可以自由更改，最后英文路径或者默认，其它点下一步 安装后，打开Win+R，输入cmd，窗口中输入：node -v 或 npm -v 查看版本号 3.安装vue 命令行工具 (CLI) 介绍：Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。CLI是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速搭建一个新项。 网址：https://cli.vuejs.org/zh/ 版本：Vue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上) 先安装yarn: npm i yarn -g (推荐) 安装vue-cli： npm install -g @vue/cli （下载模块：npm install 模块 ） 或者 yarn global add @vue/cli （下载模块：yarn add 模块 ） 检查其版本是否正确vue –version 4.创建一个vue项目–通过脚手架vue-cli 创建vue项目： vue create vue-project说明：vue项目名称最好是英文 不能包含驼峰命名法 按需项目需要的依赖配置 进入项目cd 项目名称 启动项目npm run serve或者yarn serve 打包项目npm run build 目录结构 node_moudles 安装包依赖 –模块public 单页面入口 - index.htmlsrc 资源文件 – 前端– – assets 静态文件资源 - 放置 css js images– – components 公共组件 - 组件化 （样式 布局 效果）– – App.vue 根组件– – main.js 入口配置文件.browserslistrc 浏览器配置.gitignore 上传git仓库 忽略的文件配置babel.config.js babel配置package.json 项目配置文件 （查看项目安装的依赖 版本 名称… ）readme.md 项目说明文件yarn.lock 配置信息 忽略 Vue组件组成 组成-三部分 template 视图标签 （template标签不会被渲染 只是包裹作用） 必写 script 逻辑代码 style 样式 lang=’less/scss’ scoped 创建组件 xxx.vue 后缀.vue结尾 三部分组件 快捷键 vue 组件使用 引入组件 注册组件 使用组件&lt;script&gt; //1. 引入组件 import Banner from './components/Banner.vue' export default { name: 'App', //2. 注册组件 components: { Banner, } } &lt;/script&gt; &lt;!-- 3. 使用组件 --&gt; &lt;Banner&gt;&lt;/Banner&gt; vue基础语法指令：就是以 v-指令=’js环境’ 具体特定的工具 ，指令。 插值操作 (模板语法) 作用：获取vue数据 显示视图 模板语法来声明式地将数据渲染进 DOM 语法： Mustache &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;!--mustache语法中,不仅仅可以直接写变量,也可以写简单的表达式--&gt; // 获取data里的数据 &lt;h2&gt;{{firstName + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName + ' ' + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{lastName}}&lt;/h2&gt; &lt;h2&gt;{{counter * 2}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', // 提供数据 data: { message: '你好啊', firstName: 'kobe', lastName: 'bryant', counter: 100 }, }) &lt;/script&gt; 指令介绍v-once在某些情况下，我们可能不希望界面随意的跟随改变这个时候，我们就可以使用一个Vue的指令v-once:该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。代码如下： &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-once&gt;{{message}},李银河&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-html -原生HTML某些情况下，我们从服务器请求到的数据本身就是一个HTML代码如果我们直接通过插值语法来输出，会将HTML代码也一起输出但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容可以使用v-html指令该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染 &lt;div id=\"app\"&gt; &lt;h2&gt;{{url}}&lt;/h2&gt; &lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' } }) &lt;/script&gt; v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中v-text通常情况下，接受一个string类型缺点是不够灵活：第二个h2不会显示李银河 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;, 李银河!&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-prev-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。比如下面的代码第一个h2元素中的内容会被编译解析出来对应的内容第二个h2元素中会直接显示 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; //你好啊 &lt;h2 v-pre&gt;{{message}}&lt;/h2&gt; //{{message}} &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-cloak在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签cloak: “斗篷” &lt;div id=\"app\" v-cloak&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 在vue解析之前, div中有一个属性v-cloak // 在vue解析之后, div中没有一个属性v-cloak setTimeout(function () { const app = new Vue({ el: '#app', data: { message: '你好啊' } }) }, 1000) &lt;/script&gt; 条件渲染条件渲染- v-if （v-else、v-else-if） 作用：是否显示元素/ true 显示 false 隐藏 语法： &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; v-else作用：是对 v-if=’’的结果取反 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else&gt;xxxx &lt;/span&gt; v-else-if作用：是否显示元素 与v-if v-else-if 多语句判断 &lt;span v-if=\"boolean表达式\"&gt;&lt;/span&gt; &lt;span v-else-if=\"boolean表达式\"&gt;&lt;/span&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;条件渲染 vue-if&lt;/h2&gt; &lt;!-- v-if='boolean' --&gt; &lt;p&gt;v-if的值：{{flag}}&lt;/p&gt; &lt;p v-if=\"flag\"&gt;我是v-if为true显示的&lt;/p&gt; &lt;h4 v-else&gt;我是v-else控制显示&lt;/h4&gt; &lt;button @click=\"change()\"&gt;点我控制v-if的值&lt;/button&gt; &lt;!-- 多语句 --&gt; &lt;p v-if=\"number&gt;5\"&gt; number&gt;5 &lt;/p&gt; &lt;p v-else-if=\" 2&lt; number &lt;=5\"&gt; number大于2小于等于5 &lt;/p&gt; &lt;p v-else&gt; number小于2 &lt;/p&gt; &lt;input type=\"text\" placeholder=\"请输入数字来判断number\" v-model=\"number\"&gt; &lt;br&gt; &lt;span&gt;{{number}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ flag:false, number:\"\", } }, methods:{ change(){ this.flag=!this.flag } } } &lt;/script&gt; v-show 作用：是否显示元素/ true 显示 false 隐藏 语法：特点：控制元素的 display:block/none &lt;span v-show=\"boolean表达式\"&gt;&lt;/span&gt; 列表渲染- v-for1. 遍历数组语法： &lt;li v-for=\"(item,index) in arr\" :key=\"\"&gt; {{ item }} &lt;/li&gt; 属性 item 第一个元素 表示数组的每一项内容 index 第二个元素 表示数组的下标 0 1 arr 数组数据(或者对象) :key其实是 v-bind属性 作用：做当前数据的唯一标识 一般写的是id 不推荐 index 2. 遍历对象 &lt;div v-for=\"(value, key, index) in object\"&gt; {{ index }}. {{ key }}: {{ value }} &lt;/div&gt; value 对象里每个键值对的值({key:value}中的value) key 对象里每个键值对的键名({key:value}中的key) index 下标0 1 object 要遍历的对象名 案例： &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组遍历- v-for&lt;/h2&gt; &lt;p&gt;直接获取数组数据：arr{{ arr }}&lt;/p&gt; &lt;p&gt;遍历数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in arr\" :key=\"item.id\"&gt; 每一项 {{ item }} -- 下标 {{ index }} &lt;/li&gt; &lt;/ul&gt; -------------------------------------------------- &lt;p&gt;遍历内部是对象的数组&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in books\" :key=\"index\"&gt; &lt;h3&gt;书名：{{ item.name }}&lt;/h3&gt; &lt;p&gt;价格：{{ item.price }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ---------------------------------------------------- &lt;p&gt;遍历对象&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"(ele,key) in obj \" :key=\"key\"&gt; &lt;p&gt;{{key}}：：{{ele}}&lt;/p&gt; &lt;!-- &lt;p&gt;姓名：{{ele.uname}}&lt;/p&gt; &lt;p&gt;年龄：{{ele.age}}&lt;/p&gt; --&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3, 4], books: [ { id: 1, name: \"三国\", price: 20, }, { id: 2, name: \"西游记\", price: 30, }, { id: 3, name: \"红楼梦\", price: 40, }, ], obj: { uname: \"张三\", age: 20, }, }; }, }; &lt;/script&gt; 3. v-for 与 v-if 一同使用 注意不推荐在同一元素上使用 v-if 和 v-for 、v-for 的优先级比 v-if 更高 解决办法： &lt;template&gt; &lt;div&gt; &lt;h4&gt;4 v-for 与 v-if 一同使用, v-for 的优先级比 v-if 更高&lt;/h4&gt; &lt;h4&gt;今天上架了什么水果：&lt;/h4&gt; &lt;ul&gt; &lt;template v-for=\"(item) in zaoshi\"&gt; &lt;li :key=\"item.id\" v-if=\"item.flag\"&gt; 种类：{{item.fruit}} &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { zaoshi:[ { id:100, fruit:'苹果', flag:true, }, { id:101, fruit:'香蕉', flag:false, }, { id:102, fruit:'阳光玫瑰', flag:true, }, { id:103, fruit:'车厘子', flag:false, }, ] }; }, }; &lt;/script&gt; Vue 事件处理 介绍可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码 定义事件语法：&lt;div&nbsp;v-on:事件名=’dosomething’&gt;函数dosomething定义的位置：要求定义mothds属性中 事件：this指向：事件的this指向 当前组件实例对象事件传递参数：事件传递参数 v-on:click=’canshu(1,2)’事件对象event： 函数不带参数 第一个参数默认是事件对象 event 函数带参数 事件对象需要手动传递 $eventv-on:事件名=’函数’简写：@事件名=’函数’ 事件修饰符Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop.prevent.capture.self.once.passive &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue事件处理&lt;/h2&gt; &lt;!-- 事件修饰符 --&gt; &lt;div @click=\"parent\"&gt; //父元素 我是小头爸爸 &lt;button @click.stop=\"child\"&gt;我是大头儿子&lt;/button&gt; //子元素 &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ parent(){ console.log('父元素'); }, child(){ console.log('子元素'); }, } } &lt;/script&gt; 按键修饰符在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：.enter *.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right &lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=\"submit\"&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 按键修饰符 --&gt; &lt;input type=\"text\" v-on:keyup.enter='getInput'&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ getInput(e){ //if(e.keyCode == 13) { // console.log('按下了回车键--触发是搜索。。。'); //} console.log('按下了回车键--触发是搜索。。。'); } } } &lt;/script&gt; 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。.ctrl.alt.shift.meta &lt;template&gt; &lt;div&gt; &lt;!-- 系统修饰键 --&gt; &lt;!-- 可以按下ctrl+回车键触发 --&gt; &lt;textarea @keyup.ctrl.enter=\"send\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;button @click=\"send\"&gt;发送&lt;/button&gt; // &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { // 系统修饰键 send(){ console.log('系统修饰键--发送了聊天信息'); } }, }; &lt;/script&gt; 鼠标按钮修饰符.left.right.middle Vue中key属性的作用 （考点） 作用：key的作用主要是为了高效的更新虚拟DOM 高效的Diff算法 &lt;template&gt; &lt;div&gt; &lt;h2&gt;vue中遍历数据v-foe是否添加key 功能&lt;/h2&gt; &lt;p&gt;key作用：提高更新虚拟DOM速度 --底层diff算法--查思路&lt;/p&gt; &lt;!-- 默认不带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;!-- 带key的遍历 --&gt; &lt;ul&gt; &lt;li v-for=\"item in arr\" :key=\"item\"&gt;{{ item }}&lt;/li&gt; &lt;button @click=\"addF\"&gt;插入F元素&lt;/button&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [\"A\", \"B\", \"C\", \"D\", \"E\"], }; }, methods: { addF() { // 增加 F （给数组添加元素 arr.splice(下标,删除的个数,添加的值)） this.arr.splice(2, 0, \"F\"); }, }, }; &lt;/script&gt; 数组更新检测 说明：在列表渲染中，如果遍历是数组，当数组数据发生改变时，页面什么时候能自动更新(页面重新渲染) 实现数组视图同步更新 变更方法 （修改了原数组）push()pop()shift()unshift()splice()sort()reverse() 替换数组（修改后返回新的数组 原数据不修改 视图想同步更新 覆盖原数组）filter()、concat() 和 slice() &lt;template&gt; &lt;div&gt; &lt;h2&gt;数组更新同步&lt;/h2&gt; &lt;p&gt;arr:{{ arr }}&lt;/p&gt; &lt;button @click=\"addArr\"&gt;追加数组&lt;/button&gt; &lt;button @click=\"sliceArr\"&gt;切割数组&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { arr: [1, 2, 3], }; }, methods: { addArr() { // this.arr.push(100) this.arr.reverse(); }, sliceArr() { //slice() 返回新的数组 n ce(1); console.log(newArr); //替换 this.arr = newArr; }, }, }; &lt;/script&gt; 对象更新检测 说明：对象修改后 视图同步更新视图 – 内存：栈内存 堆内存 实现对象视图同步更新&lt;template&gt; &lt;div&gt; &lt;h2&gt;对象同步更新&lt;/h2&gt; &lt;p&gt;对象obj:{{ obj }}&lt;/p&gt; &lt;button @click=\"changeUname\"&gt;修改对象已存在的属性&lt;/button&gt; &lt;button @click=\"obj = { user: 'admin' }\"&gt;修改整个obj对象&lt;/button&gt; &lt;!-- //视图检测不到变化 --&gt; &lt;button @click=\"addAttribute\"&gt;给obj添加不存在的属性&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ obj:{ uname:'张三', age:20 } } }, methods:{ changeUname(){ this.obj.uname = '拉拉' }, addAttribute(){ // this.obj.love = '女' // 问题: 视图检测不到变化 vue认为obj没有修改 // 方法一:对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 // this.obj = {...this.obj} // 方法二: es6合并对象 Object.assign({},{},{}) // this.obj = Object.assign({},this.obj) // 方法三: vue官网解决方法 // Vue.set( target, propertyName/index, value ) /**参数： {对象 | 数组} target 目标元素 {string | number} propertyName/index (要添加的属性)数据类型名字或者index {any} value 属性的值 用法：向响应式对象中添加一个 property(属性)，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi') **/ //这里没有引入Vue了,因为组件实例对象vm身上有$set()方法 this.$set(this.obj,'love','女') //删除 同步视图 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。 this.$delete(this.obj,'age') } } } &lt;/script&gt; Class 与 Style 绑定介绍：动态的添加class或者是style样式1.绑定 HTML Class 直接绑定变量 &lt;div v-bind:class='变量'&gt;&lt;/div&gt; 对象语法 (最常用)&lt;div v-bind:class=\"{类名: 表达式-true显示类名、false隐藏 ,类名:boolean}\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:class=\"[变量1,变量2, {类名：boolean}]\"&gt;&lt;/div&gt; 2.绑定内联样式v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 对象语法 &lt;div v-bind:style=\"{css样式:变量,... }\"&gt;&lt;/div&gt; 数组语法&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 直接变量&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; data: { styleObject: { color: 'red', fontSize: '13px' } } 完整练习案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;动态绑定样式class 和 style&lt;/h2&gt; &lt;h4&gt;动态绑定样式class&lt;/h4&gt; &lt;!-- 绑定变量 --&gt; &lt;button @click=\"active = 'box2'\"&gt;切换颜色-绑定变量&lt;/button&gt; &lt;div v-bind:class=\"active\"&gt;动态绑定样式class&lt;/div&gt; &lt;hr /&gt; &lt;!-- 对象语法 --&gt; &lt;div v-bind:class=\"{ box: flag }\"&gt;对象语法&lt;/div&gt; &lt;button @click=\"flag = !flag\"&gt;修改flag-对象语法&lt;/button&gt; &lt;hr /&gt; &lt;!-- 数组语法 --&gt; &lt;div class=\"aa\" v-bind:class=\"[active, { box2: true }]\"&gt;数组语法&lt;/div&gt; &lt;hr /&gt; &lt;h2&gt;动态绑定内联样式&lt;/h2&gt; &lt;p&gt;0. 默认的内联写法&lt;/p&gt; &lt;div style=\"width: 100px; height: 100px; background: orange\"&gt; 默认的内联写法 &lt;/div&gt; &lt;p&gt;1. 直接变量&lt;/p&gt; &lt;div v-bind:style=\"styleObject\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;2. 对象语法&lt;/p&gt; &lt;div v-bind:style=\"{color:'green',fontSize:'30px', width:'100px',height: '100px',backgroundColor:'blue'}\"&gt; 对象语法 &lt;/div&gt; &lt;p&gt;3. 数组语法&lt;/p&gt; &lt;div :style=\"[styleObject,{border:'5px solid #333'}]\"&gt;数组语法&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { active: \"box\", flag: \"true\", styleObject:{ width: '100px', height: '100px', background: 'orange', } }; }, methods: { changeColor() { this.active = \"box2\"; }, }, }; &lt;/script&gt; &lt;style&gt; .box { width: 200px; height: 200px; background-color: pink; } .box2 { width: 200px; height: 200px; background-color: rgb(21, 226, 253); } &lt;/style&gt; Vue-tab栏切换练习&lt;template&gt; &lt;div&gt; &lt;h2&gt;Vue-tab切换&lt;/h2&gt; &lt;ul class=\"nav\"&gt; &lt;li v-for=\"(item,index) in arr\" :key='item' :class=\"{active:index == num}\" @click=\"changeNav(index)\"&gt; {{item}}-{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"box1\"&gt; &lt;div v-for=\"(ele,n) in content \" :key=\"ele\" :class=\"{show:n == num}\"&gt;{{ele}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 0, arr: [\"选项1\", \"选项2\", \"选项3\"], content: [\"111\", \"222\", 333], }; }, methods: { changeNav(index){ this.num = index } }, }; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; .nav { overflow: hidden; list-style: none; li { display: inline; width: 100px; height: 40px; line-height: 40px; margin-right: 10px; } .active{ background: lightblue; } } .box1 { margin: auto; width: 400px; height: 200px; border: 1px solid #000; &gt;div { display: none; } .show { display: block; } } &lt;/style&gt; 表单输入绑定 (v-modele)1.介绍你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定通过指令 v-model=’’ 获取表单输入的信息数据 实现双向数据绑定 2.语法:会将文本框输入的数据实时传递给绑定到data里的msg中 &lt;input type='text' v-model='msg' /&gt; data(){ return{ msg:'' } } 案例: &lt;template&gt; &lt;div&gt; &lt;h2&gt;表单输入绑定&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" :value=\"msg\" name=\"\" id=\"\"&gt; --&gt; &lt;!-- 1. 文本/密码 v-model=''--&gt; &lt;input type=\"text\" placeholder=\"请输入\" v-model=\"formData.msg\" @keyup.enter=\"send\" name=\"\" id=\"\" /&gt; &lt;p&gt;msg:{{formData.msg}}&lt;/p&gt; &lt;!-- 2. 多行文本 --&gt; &lt;!-- 3. 单选按钮 --&gt; 性别: &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"1\" /&gt;男 &lt;input type=\"radio\" v-model=\"formData.sex\" name=\"aa\" value=\"2\" /&gt;女 &lt;p&gt;选择的性别:{{ formData.sex }}&lt;/p&gt; &lt;!-- 爱好: --&gt; &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"a\" /&gt;吃 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"b\" /&gt;喝 &lt;input type=\"checkbox\" v-model=\"formData.arr\" value=\"c\" /&gt;玩 &lt;p&gt;选择的爱好:{{ formData.arr }}&lt;/p&gt; &lt;!-- 城市: --&gt; &lt;select name=\"\" id=\"\" v-model=\"formData.select\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"gaungzhou\"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;p&gt;城市选择:{{ formData.select }}&lt;/p&gt; &lt;button @click=\"submit\"&gt;注册信息&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'初始值', sex:'', //对象的语法--------存储表单数据 formData: { msg: \"\", //输入框 sex: 1, //性别 arr: [], select: \"\", }, }; }, methods:{ send() { console.log(\"输入的数据为:\", this.msg); }, submit() { //点击按钮--发送输入的数据给后台-- data -- msg sex arr ... console.log(\"提交注册信息表单\",this.formData); }, } }; &lt;/script&gt; 3.修饰符 lazy&nbsp; 只有当input失去焦点时才更新数据 number 把input标签中输入的内容转成数字，调用是parseFloat (Nunber()) trim 去除左右空格 案例： &lt;template&gt; &lt;div&gt; &lt;h3&gt;表单修饰符 -修饰符 &lt;/h3&gt; &lt;!-- .lazy 失去焦点或者回车 获取数据 --&gt; &lt;input type=\"text\" v-model.lazy=\"search\"&gt; &lt;p&gt;search:{{ search }}&lt;/p&gt; &lt;input type=\"text\" v-model.trim=\"msg\" name=\"\" id=\"\"&gt; &lt;p&gt;去空格:{{msg}}&lt;/p&gt; &lt;!-- .number 转数字 --&gt; &lt;input type=\"number\" v-model.number=\"num\" name=\"\" id=\"\"&gt; &lt;p&gt;num:{{ num }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ } }; &lt;/script&gt; 4.v-model实现原理v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发oninput 事件并传递数据v-model&nbsp;是什么。语法糖&nbsp;:value&nbsp;+&nbsp;@input。还要分为两种情况 &lt;input v-model=\"val\"&gt; &lt;!-- 基本等价于，因为内部还有一些其他的处理 --&gt; // $event是事件对象，$event.target.value表示input框中的输入值 &lt;input :value=\"val\" @input=\"val = $event.target.value\"&gt; 案例： &lt;template&gt; &lt;div&gt; &lt;!-- v-model实现的原理 --&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;p&gt;inp:{{inp}}&lt;/p&gt; &lt;!-- v-model == v-bind:value='' @input='函数' --&gt; 表单值:&lt;input type=\"text\" :value=\"val\" @input=\"changeVal\" name=\"\" id=\"\"&gt; &lt;p&gt;val:{{val}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { val:'请输入', msg:'', inp:'', sex:'', search:'', num:'只能输入数字', }; }, methods:{ changeVal(e){ console.log(e); //表单的事件对象 console.log(e.target.value); //表单里的文本框内容 this.val = e.target.value; //将文本框内容 赋值给 data里的val 即使用v-bind又让数据进行双向绑定了 } } }; &lt;/script&gt; 计算属性和侦听器1. 计算属性 介绍: 处理数据后把数据缓存起来 使用数据的时候使用的缓存的数据,但是如果原数据修改了重新计算 语法&lt;template&gt; &lt;div&gt; &lt;h2&gt;计算属性computed&lt;/h2&gt; &lt;!-- 如果是字符串 取反操作实现 --&gt; &lt;p&gt;字符串:{{ msg }}&lt;/p&gt; &lt;!-- 不推荐: 模板语法里面写很多方法 多次使用不方便 --&gt; // split-先转换为数组， reverse-然后取反， join-最后转为字符串 &lt;p&gt;字符串-取反:{{ msg.split(\"\").reverse().join(\"\") }}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;封装函数-取反:{{qufan()}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;p&gt;计算属性-取反：{{msg2}}&lt;/p&gt; &lt;button @click=\"msg = 'how are you'\"&gt;修改msg&lt;/button&gt; &lt;!-- 例子: v-for='' v-if不能在同一个元素使用 -- computed处理数据 --&gt; &lt;h4&gt;早市水果更新:&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=\"item in zaoshi2\" :key='item.id'&gt; {{item.fruit}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: \"hello vue\", zaoshi: [ { id: 100, fruit: \"苹果\", flag: false, }, { id: 101, fruit: \"阳光玫瑰\", flag: true, }, { id: 102, fruit: \"车厘子\", flag: false, }, { id: 103, fruit: \"榴莲\", flag: true, }, ], }; }, methods: { qufan() { console.log(\"执行了一次取反方法\"); return this.msg.split(\"\").reverse().join(\"\"); }, }, //计算属性: 对数据进行加工处理 缓存数据 computed: { msg2() { console.log(\"计算属性: 对数据进行加工处理 缓存数据\"); return this.msg.split(\"\").reverse().join(\"\"); }, //处理数据 zaoshi2(){ //过滤方法 返回的满足条件的数组 比如:[1,2,3,4] =&gt;[3,4] return this.zaoshi.filter((item)=&gt;{ // if(item.flag == true) { // return item.flag // } return item.flag }) } }, }; &lt;/script&gt; 2. 侦听器 介绍: Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化 &lt;template&gt; &lt;div&gt; &lt;h2&gt;侦听器-watch&lt;/h2&gt; &lt;p&gt;功能:监听数据修改了,然后做业务逻辑&lt;/p&gt; &lt;input type=\"text\" v-model=\"inp\" name=\"\" id=\"\"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return{ inp:'', arr:[] } }, //侦听器--数据变化 (当前监听的是inp变化) watch:{ inp:function(n,o){ console.log('新值:',n ,'旧值:',o); //业务逻辑 比如输入东西后 网络请求 //模糊查询 } } } &lt;/script&gt; 3. computed和watch区别 （考点） 相同：computed和watch都是观察页面的数据变化的。 不同：computed：是计算属性，依赖其它属性值: 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化watch：没有缓存性，更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； Vue 的生命周期方法有哪些 一般在哪一步发请求生命周期：事物从诞生到消亡的过程Vue生命周期： v-if 和 v-show 的区别v-if: 控制元素的渲染或者销毁v-show:控制元素的 display:block/none 场景：频繁切换： v-show初次渲染优化：v-if Vue 修饰符有哪些v-for 为什么要加 key理解 Vue 的单向/双向 数据流首先了解一下数据绑定什么是绑定？比如当前href属性值取决于表达式school.url.toUpperCase()的结果，这两者之间就是有绑定关系，且通过v-bind指令完成数据绑定。 &lt;a v-bind:href=\"school.url.toUpperCase()\" v-bind:x=\"hello\"&gt;点我去{{school.name}}学习&lt;/a&gt; v-bind 单向数据原理前面学习的指令主要作用是将值插入到模板的内容当中但除了内容需要动态来决定外，某些属性也希望动态来绑定作用：动态绑定属性缩写：**:**预期：any (with argument) | Object (without argument)参数：attrOrProp (optional)v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到Vue进阶时介绍)在开发中，一般有哪些属性需要动态进行绑定呢？比如图片的链接src、网站的链接href、动态绑定一些类、样式等等例子：通过Vue实例中的data绑定元素的src和href，代码如下： 基本使用很多时候，我们希望动态的来切换class，比如：当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。 &lt;div id=\"app\"&gt; &lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt; &lt;!--&lt;img src=\"{{imgURL}}\" alt=\"\"&gt;--&gt; &lt;!-- 正确的做法: 使用v-bind指令 --&gt; &lt;img v-bind:src=\"imgURL\" alt=\"\"&gt; &lt;a v-bind:href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;!--&lt;h2&gt;{{}}&lt;/h2&gt;--&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=\"imgURL\" alt=\"\"&gt; &lt;a :href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', imgURL: 'https://img11.360buyimg.com/mobilecms/s350x250_jfs/t1/20559/1/1424/73138/5c125595E3cbaa3c8/74fc2f84e53a9c23.jpg!q90!cc_350x250.webp', aHref: 'http://www.baidu.com' } }) &lt;/script&gt; v-bind动态绑定class(对象语法) 绑定方式：对象语法含义是:class后面跟的是一个对象 直接通过{}绑定一个类&lt;h2 :class=\"{'active': isActive}\"&gt;Hello World&lt;/h2&gt; 也可以通过判断，传入多个值&lt;h2 :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=\"title\" :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 比如ul的li标签点击某个标签变颜色 &lt;div id=\"app\"&gt; &lt;!-- 当布尔值为true 这个类名1即 active 就会被添加到标签上 --&gt; &lt;!-- 一个 { } 表示对象 --&gt; &lt;h2 class=\"title\" v-bind:class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" v-bind:class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', isActive: true, isLine: true }, methods: { btnClick: function () { this.isActive = !this.isActive }, getClasses: function () { return {active: this.isActive} } } }) &lt;/script&gt; v-bind动态绑定class(数组语法) 数组语法的含义是:class后面跟的是一个数组。 直接通过{}绑定一个类&lt;h2 :class=\"['active']\"&gt;Hello World&lt;/h2&gt; 也可以传入多个值&lt;h2 :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：会有title/active/line三个类&lt;h2 class=\"title\" :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 例如： &lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"[active, line]\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', active: 'aaaaaa', line: 'bbbbbbb' }, methods: { getClasses: function () { return [this.active, this.line] } } }) &lt;/script&gt; 小案例 点击li标签变色（默认第一li为红色）分析： v-for绑定给li标签，同时v-on添加点击事件，并且li标签的class用v-bind动态绑定 使用v-for绑定到li标签上，自动遍历data中的数据，将下标（index）和每一项内容（item）用插值语法显示到页面 在data中添加一个isRed属性值为0，想让class样式显示，需要v-bind绑定的red值为true，即该值可以等等于index,因为index的第一个值就是0 v-on点击事件点击某一个li，将下标的值赋值给isRed，即当前点击的li标签的class样式显示 end~&lt;style&gt; .red { color: red; } &lt;/style&gt; &lt;!--作业需求: 点击列表中的哪一项, 那么该项的文字变成红色--&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=\"每一项,下标 in 数据源\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;li v-for=\"(item,index) in movie\" v-on:click=\"getColor(index)\" v-bind:class=\"{red:isRed==index}\" &gt;{{index}}--{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', data:{ isRed:0, movie:['海王','海尔兄弟','火影忍者','进击的巨人'] }, methods:{ getColor: function (index){ this.isRed = index console.log(this.isRed); } }, }) &lt;/script&gt; v-bind绑定style 一利用v-bind:style来绑定一些CSS内联样式在写CSS属性名的时候，比如font-size可以使用驼峰式 (camelCase) fontSize或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ v-model 双向数据原理Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。Vue中有两种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。备注： 双向绑定一般都应用在表单类元素上（如：input、select等） v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。&lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'哔哩哔哩', } }) &lt;/script&gt; 虚拟 DOM 是什么 有什么优缺点MVVM全称： Model-View-ViewModel ， Model 表示数据模型层。 view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。 Model层： 数据层数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。 View层： 视图层在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。 VueModel层： 视图模型层视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。 M：模型(Model) ：对应 data 中的数据 V：视图(View) ：模板 VM：视图模型(ViewModel) ： Vue 实例对象Vm（Vue实例对象）把左边的View和右边Model进行连接在一起 观察发现： data中所有的属性，最后都出现在了vm身上。 VM身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 执行过程 ：数据在data中经过 VM视图模型放到了页面View上页面上如果有地方需要更改要映射回数据就再给VM视图模型，然后视图模型再给data里的数据 &lt;!-- 1 准备好一个容器 也就是 view 视图 模板代码--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;!-- &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = fal se //阻止 vue 在启动时生成生产提示 const vm = new Vue({// 2 VM 视图模型ViewModel el:'#root', data:{ // 3 data里的是模型 model name:\"b站大学\", address:\"成都\", } }) console.log(vm) &lt;/script&gt; Vue的数据代理首先学习下 Object.defineProperty()方法Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。defineProperty()参数 Object.defineProperty(obj, prop, descriptor) obj 需要定义属性的对象 prop 需被定义或修改的属性名 descriptor 需被定义或修改的属性的描述符 例子：定义了一个person对象，里面包含name、sex属性和其它属性值。注意：age属性是通过defineProperty方法中 &lt;script type=\"text/javascript\"&gt; let number = 19 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { value:19, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value } }) console.log(Object.keys(person)) // Object.keys方法传入一个对象作为参数，可以把传入对象所有属性的属性名提取出来变成数组 console.log(person) &lt;/script&gt; Vue中的数据代理什么是数据代理数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） &lt;script type=\"text/javascript\" &gt; let obj = { x:100 } let obj2 = { y:200 Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; vue常用ui库移动端 mint-ui （http://mint-ui.github.io/#!/zh-cn） Vant（https://youzan.github.io/vant/#/zh-CN/home） VUX (https://vux.li/) pc端 element-ui（https://element.eleme.cn/2.13/#/zh-CN/component/installation） Ant Design of Vue（https://www.antdv.com/docs/vue/introduce-cn/） Avue (https://avuejs.com/) 常用webpack配置待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"}]},{"title":"axios学习","slug":"04-axios学习","date":"2022-04-17T06:12:00.000Z","updated":"2022-04-18T08:01:30.170Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://wuzimo233.github.io/posts/4.html","excerpt":"","text":"前置条件已经学习过ajax、Promise准备json-server包，快速搭建HTTP服务（用axios的时候需要向服务端发送请求即需要服务端这个角色来与axios结合做实践） json-server用于模拟服务端接口数据，可以根据json数据建立一个完整的web服务 1安装json-servernpm install -g json-server //查看版本号，安装成功 json-server -v 2在文件夹下创建一个db.json文件，存放一些数据。{ \"posts\": [ //文章 { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"《b站大学》\", \"author\": \"吴老师\" } ], \"comments\": [ //评论 { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }, { \"body\": \"喜大普奔\", \"postId\": 2, \"id\": 2 } ], \"profile\": { //个人信息 \"name\": \"typicode\" } } 3 启动服务进入终端。执行启动json-server命令:json-server --watch .\\db.json 认识axiosaxios 是什么?axios是目前前端使用非常广泛的基于 promise 的 HTTP 网络请求库，包括Vue/React也是推荐使用axios；本质是XMLHttpRequests请求 即ajax请求 axios 特性： 从浏览器中创建 XMLHttpRequests （浏览器中发送xml请求） 从 node.js 创建 http 请求 （在node.js中发送http请求） 支持 Promise API 相关操作 拦截请求和响应 转换请求数据和响应数据（对请求和响应的数据作转换） 取消请求 自动将结果转换成 JSON 数据 客户端支持防御 XSRF （阻止跨站攻击） axios安装 1 使用 npm安装:$ npm install axios 2 使用 yarn安装:$ yarn add axios 3 使用 jsDelivr CDN安装:&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.min.js\"&gt;&lt;/script&gt; console.log(axios); //ƒ() {for(var n=new Array(arguments.length),r=0;r&lt;n.length;r++)n[r]=arguments[r];return e.apply(t,n)} //建议使用国内CDN网速较快 //去这个网站引入 https://www.bootcdn.cn/axios/ axios的基本使用 前置：引入了axios准备四个按钮发送不同的请求 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; GET请求//获取按钮 const btns = document.querySelectorAll('button'); //第一个 （get 查询功能） btns[0].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'GET', //请求地址 刚启动好的json-server地址 且id为2的那篇文章 url: ' http://localhost:3000/posts/2' }).then(response =&gt; { console.log(response); }) } POST请求//添加一篇新的文章 （post 添加功能） btns[1].onclick = function () { //发送ajax请求 axios({ method: 'POST', //请求类型 url: ' http://localhost:3000/posts', //请求地址 data: { \"title\": \"招聘摄影\", //请求体 \"author\": \"小吴\" } }).then(response =&gt; { console.log(response); }) } PUT请求//更新文章 需要在url里加上id 比如这里要更新的是id为3的文章（put 更新功能） btns[2].onclick = function () { //发送ajax请求 axios({ method: 'PUT', //请求类型 url: ' http://localhost:3000/posts/3', //请求地址 data: { \"title\": \"招聘程序员吗\", //修改请求体的数据 \"author\": \"小瑶酱\" } }).then(response =&gt; { console.log(response); }) } DELETE请求//删除文章 （delete 删除功能） btns[3].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'DELETE', //请求地址 url: ' http://localhost:3000/posts/3', }).then(response =&gt; { console.log(response); }) } axios的其他发送请求使用request方法 发送 GET 请求 （接收一个对象类型参数）//获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ // axios() axios.request({ method:'GET', url:' http://localhost:3000/posts', // 返回结果依然是Promise对象 用then指定成功的回调 }).then((response) =&gt; { console.log(response); }) ; } //使用POST方法 发送post请求 增加数据//获取按钮 const btns = document.querySelectorAll('button'); btns[1].onclick = function(){ // axios() axios.post( 'http://localhost:3000/comments', { \"body\": \"喜大普奔\", \"postId\": 2 }).then(response =&gt; { console.log(response); }) } axios配置对象{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 baseURL: 'https://some-domain.com/api/', // `transformRequest` 对请求的数据做处理，处理后将结果像服务器发送 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 对响应的结果做一些改变，改变之后我们用自定义的回调去处理结果 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 对请求头信息做一个配置（身份校验） headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求体的设置 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时对coken的携带设置 withCredentials: false, //不携带 // `adapter` 对请求的适配器做设置 // 有两种一种是ajax、一种是node.js里发送http请求的 adapter: function (config) { /* ... */ }, // `auth` 对请求基础的验证设置用户名和密码 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // 响应结果的编码 responseEncoding: 'utf8', // `xsrfCookieName` 跨域请求标识对cookie的名称设置 xsrfCookieName: 'XSRF-TOKEN', // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 上传的一些回调 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 下载时的一些回调 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 对响应结果的成功做一个设置 什么情况下是成功的呢？默认值为响应状态码 大于等于200 小于300 validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 最大跳转的次数 默认5次 即向一个服务发送请求，它作了跳转后呢，我们是否需要让它继续往前进行请求 maxRedirects: 5, // 默认的 // 设置socket 文件的位置 作用是像docker的守护进程发送请求的 socketPath: null, // default // 对客户端的一些信息做一些设置 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 设置代理 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 对ajax请求作一个取消的设置 cancelToken: new CancelToken(function (cancel) { }) } axios的默认配置例子：点击按钮发送get请求//没有做默认配置时，每次访问都比较麻烦 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ axios({ method:'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log(response); }) } &lt;/script&gt; 使用默认配置后 //默认配置 axios.defaults.method = 'GET'; //设置默认的请求类型为 GET axios.defaults.baseURL = 'http://localhost:3000' //设置基础url btns[0].onclick = function () { axios({ url: '/posts', }).then(response =&gt; { console.log(response); }) //还有其他的默认配置项 // axios.defaults.params = {id:100}; 默认的请求url参数 即url后增加 ?id=100 // axios.defaults.timeout = 3000; 超时时间 axios创建实例对象主要用于：项目中接口数据服务不是来自于单一的服务器，比如有两个服务器A、B，都提供了数据服务。在发送请求时，比如给A发，就要去设置A的协议域名端口，如果用默认方法做只能满足一个服务器， &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 发送POST请求 &lt;/button&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //创建实例对象 /getJoke const duanzi = axios.create({ baseURL:'https://api.apiopen.top', timeout:2000 }); //这里duanzi 与 axios 对象的功能几近是一样的 duanzi({ url:'/getJoke', }).then((response)=&gt;{ console.log(response); }) duanzi.get('/getJoke').then((response) =&gt; { console.log(response.data); }) const another = axios.create({ baseURL:'http:b.com', timeout:2000 }) axios拦截器在请求或响应被 then 或 catch 处理前拦截它们。在发送请求之前，借助一些函数对请求的参数和内容作一些处理和检测。如果说都没有问题再去发送请求，有问题的话这个请求就停止或者取消。当服务器返回结果之后，可以通过自己指定的回调处理结果。那么响应拦截器可以在我们处理响应结果之前先对结果做一些预处理。如：失败了就对失败结果做一些提醒或者记录，还能对数据接口做一些格式化的处理。然后再交由我们自己自定义的回调来处理。如果有问题在响应拦截器中就处理掉了。执行顺序是，当用户发送请求后先执行请求拦截器成功/失败的回调，然后走响应拦截器成功/失败的回调，然后再走自定义的成功/失败的回调 一般情况// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); return config; }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }); 其他情况：请求拦截器成功但抛出错误，响应拦截器失败，自定义失败回调// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); // return config; throw '参数出了问题' //如果这里抛出错误即失败了，返回一个失败的Promise， //在执行后续的响应回调时就只能走失败的回调了， }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) 多个请求、响应的结果顺序请求拦截器 成功 2号请求拦截器 成功 1号响应拦截器 成功 1号响应拦截器 成功 2号自定义回调处理成功的结果{data: Array(2), status: 200, statusText: ‘OK’, headers: {…}, config: {…},&nbsp;…} // Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 1号'); //修改 config 中的参数 // config.params = {a:100}; return config; }, function (error) { console.log('请求拦截器 失败 1号'); return Promise.reject(error); }); axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 2号'); //修改 config 中的参数 config.timeout = 2000; return config; }, function (error) { console.log('请求拦截器 失败 2号'); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 1号'); return response; // return response; }, function (error) { console.log('响应拦截器 失败 1号') return Promise.reject(error); }); axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 2号') return response; }, function (error) { console.log('响应拦截器 失败 2号') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) axios取消请求 基本流程配置 cancelToken 对象缓存用于取消请求的 cancel 函数在后面特定时机调用 cancel 函数取消请求在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能点击按钮, 取消某个正在请求中的请求 在请求一个接口前, 取消前面一个未完成的请求 使用 canceltoken 取消请求Axios 的 cancel token API 基于cancelable promises proposal可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;axios取消请求&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 取消请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function(){ // 防止用户疯狂点击按钮发送请求 //检测上一次的请求是否已经完成 if(cancel !== null){ //取消上一次的请求 cancel(); } axios({ method: 'GET', url: 'http://localhost:3000/posts', //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function(c){ //3. 将 c 的值赋值给 cancel cancel = c; }) }).then(response =&gt; { console.log(response); //将 cancel 的值初始化 cancel = null; }) } //绑定第二个事件取消请求 btns[1].onclick = function(){ cancel(); } axios源码文件结构说明 ├── /dist/ # 项目打包后的文件即最终输出的axios整体文件 ├── /lib/ # 项目源码目录 │ ├── /adapters/ # 定义请求的适配器 xhr、http │ │ ├── http.js # 用来在node.js中向 远端服务发送HTTP请求的 │ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象) │ ├── /cancel/ # 定义取消功能 │ ├── /core/ # 一些核心功能 │ │ ├── Axios.js # axios 的核心主类 构造函数 │ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数 │ │ ├── InterceptorManager.js # 拦截器的管理器 │ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态 │ ├── /helpers/ # 一些辅助方法 │ ├── axios.js # 对外暴露接口 │ ├── defaults.js # axios 的默认配置 │ └── utils.js # 公用工具 ├── package.json # 项目信息 ├── index.d.ts # 配置 TypeScript 的声明文件 └── index.js # 入口文件 axios的创建过程axios对象创建过程模拟实现axios发送请求过程详解模拟实现axios发送请求axios拦截器工作原理模拟实现axios拦截器功能axios 取消请求工作原理模拟实现axios取消请求功能axios源码分析总结","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise学习","slug":"03-Promise学习","date":"2022-04-14T06:30:00.000Z","updated":"2022-04-18T13:59:32.062Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://wuzimo233.github.io/posts/3.html","excerpt":"","text":"认识 Promise 什么是 Promise 抽象表达: Promise 是一门新的技术(ES6 规范)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数 具体表达: 语法上来说: Promise 是一个构造函数从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 为什么要用 Promise指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题 什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用 终极解决方案? async/await 如何使用 PromisePromise 语法结构 语法结构： new Promise((resolve, reject) =&gt; { } 里面是一个函数类型的参数，参数里面的两个参数也是函数在花括号{ }里边包含一个异步操作,如果成功则调用 resolve ，同时只要 resolve 调用就会将 promise 对象 p 的状态设置为『成功』，如果失败则调用 reject，调完 reject 后会将 promise 对象 p 的状态设置为『失败』（即这两个可以修改 promise&gt;对象的状态）接着 promise 对象通过调用 then()方法去指定成功和失败时的回调如果成功就执行第一个回调函数，失败则执行第二个回调函数Promise 除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即下方Promise 形式实现案例的 n 值然后可以将 n 值传递给 resolve 和 reject 函数最后下方的 then 方法里的两个回调都能拿到这个结果值作为参数使用 Promise 初体验 案例：需求——点击抽奖按钮两秒后，告诉用户是否中奖，中奖的概率是百分之 30。如果中奖在页面中弹框告知恭喜中奖，没有就弹出再接再厉。 一般方法实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 定时器 setTimeout(() =&gt; { //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ alert(n+'恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券'); }else{ alert(n+'再接再厉'); } }, 1000); }) &lt;/script&gt; Promise 形式实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 使用 new Promise(接收一个函数参数) 创建实例 // resolve 解决 函数类型的数据 --成功时调用 // reject 拒绝 函数类型的数据 --失败时调用 const p = new Promise((resolve, reject) =&gt; { // promise对象可以包裹一个异步操作（直接将上方定时器拿过来） setTimeout(() =&gt; { //30% 1-100 1 2 30 //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ // Promise除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即这里的n值 // 可以将n值传递给resolve 和 reject函数 // 那么下方的then方法里的两个回调都能拿到这个结果值作为参数 resolve(n); // 调完resolve后会将 promise 对象 p 的状态设置为『成功』 }else{ reject(n); // 调完reject后会将 promise 对象 p 的状态设置为『失败』 } }, 1000); }); console.log(p); //调用 then（里边有两个回调函数参数） 方法 --- 每个promise对象上都有then方法 // 第一个回调是对象状态为成功时的回调，第二个是对象状态失败时的回调函数 // value 值 // reason 理由 p.then((value) =&gt; { alert('恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 ' + value); }, (reason) =&gt; { alert('再接再厉, 您的号码为 ' + reason); }); }) &lt;/script&gt; 实践练习 Promise 封装 AJAX// 需求点击按钮发送ajax请求拿到段子接口的数据 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 封装 AJAX 操作&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击发送 AJAX&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //接口地址 https://api.apiopen.top/getJoke //获取元素对象 const btn = document.querySelector('#btn'); // 给按钮绑定点击事件 btn.addEventListener('click', function(){ //首先创建 Promise 对象 p const p = new Promise((resolve, reject) =&gt; { //1.创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 get请求 给后边的接口发送 xhr.open('GET', 'https://api.apiopen.top/getJoke'); //3. 发送 xhr.send(); //4. 处理响应结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断响应状态码 2xx if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //控制台输出响应体 resolve(xhr.response); }else{ //控制台输出响应状态码 reject(xhr.status); } } } }); //调用then方法 p.then(value=&gt;{ console.log(value); }, reason=&gt;{ console.warn(reason); }); }); &lt;/script&gt; Promise的状态 『PromiseState』 的改变状态是Promise实例对象当中的一个属性，属性叫做 promiseState 有三种状态 pending 值未决定的、初始化的默认值 pending 变为 resolved / fullfilled 即成功 pending 变为 rejected 即失败说明: pending变化只有这 2 种情况, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据成功的结果数据一般称为 value, 失败的结果数据一般称为 reason Promise对象 『PromiseResult』的值保存着异步任务『成功/失败』的结果以下函数能够修改这个属性的值： resolve reject Promise的基本流程 首先通过new Promise 创造一个对象，在Promise内部封装异步操作。如果异步操作成功则调用resolve函数，resolve函数调用后会把Promise对象状态改为成功，成功在调用then方法时将调用的是第一个回调函数参数，返回一个新的promise对象如果在Promise内部封装的异步操作失败，则调用reject 函数，reject函数调用后会把Promise对象状态改为失败，失败之后调用的是then方法中的第二个回调函数参数，并且返回一个新的Promise对象 Promise的Api执行器函数Promise 构造函数: Promise (excutor) {}//new实例化对象需要接收一个参数，参数是一个函数类型的参数（也称之为执行器函数），而且函数当中有两个形参也是函数类型参数resolve、reject，这俩函数是内部定义的，异步任务成功就会调用resolve函数，失败就会调用reject函数。(1) executtor 函数: 执行器 (resolve, reject) =&gt; {}(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}说明: 执行器函数 executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行 let p = new Promise((resolv, reject) =&gt; // resolve('ok'); console.log(111); }) console.log(222); //结果控制台先打印111 ，后打印222。表明 p对象内部的代码是同步调用的 Promise.then方法Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}// 说明: then方法是用于指定回调的，传递两个参数，第一个参数是传递成功时的回调，第二个参数是传递失败时的回调。返回一个新的 promise 对象(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} Promise.catch方法Promise.prototype.catch 方法: (onRejected) =&gt; {}// 说明: catch() 方法是 then()的语法糖, 相当于: then(undefined, onRejected)，即只能指定失败的回调。 onRejected 函数: 失败的回调函数 (reason) =&gt; {let p = new Promise((resolv, reject) =&gt; // 修改Promise对象的状态 reject('error 失败了'); }) // 执行catch方法 p.catch(reason =&gt; { console.log(reason); }) Promise.resolve方法 Promise.resolve 方法: (value) =&gt; {}// 说明：它属于Promise函数对象，不是实例对象。接收一个参数，返回一个成功或失败的对象// 作用：就是快速得到一个Promise对象，还能封装一个值，将这个值转化为Promise对象 value: 成功的数据或 promise 对象 //如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象 //如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果 let zimo = Promise.resolve(\"I Love You\"); console.log(zimo); // Promise&nbsp;{&lt;fulfilled&gt;: 'I Love You' let p1 = Promise.resolve(new Promise((resolve, reject) =&gt; { resolve('OK'); // reject('Error'); })); p1.then((value) =&gt; { console.log(value); //ok },(reason)=&gt;{ console.log(reason); }) console.log(p1); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} let p2 = Promise.resolve(p1); console.log(p2); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} Promise.reject方法Promise.reject 方法: (reason) =&gt; {}说明: 快速返回一个失败的 promise 对象即便传入成功的Promise对象结果也是失败 reason: 失败的原因let p1 = Promise.reject(520); p1.catch((reason) =&gt;{ console.log(reason); // Promise&nbsp;{&lt;rejected&gt;: 520} }) console.log(p1); // 520 let p2 = Promise.reject('iloveyou'); let p3 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p2); // Promise&nbsp;{&lt;rejected&gt;: 'iloveyou'} console.log(p3); //Promise&nbsp;{&lt;rejected&gt;: Promise} Promise.all 方法Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败。let p1 = new Promise((resolve, reject) =&gt; { resolve('OK'); }) // let p2 = Promise.resolve('Success'); let p2 = Promise.reject('Error'); let p3 = Promise.resolve('Oh Yeah'); const result = Promise.all([p1, p2, p3]); console.log(result); //[PromiseState]]: \"rejected\" Promise.race 方法Promise.race 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 第一个改变状态的 promise对象就是最终的结果状态。let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }) let p3 = Promise.resolve('Oh Yeah'); let p2 = Promise.resolve('Success'); //调用 const result = Promise.race([p1, p3, p2]); console.log(result); // [[PromiseState]]: \"fulfilled\" // [[PromiseResult]]: \"Oh Yeah\" Promise的几个关键问题如何改变 promise 的状态? 第一种方式 调用 resolve 函数: 如果当前Promise对象是 pending状态就会变为fulfilled(resolve) 第二种方式 调用 reject 函数: 如果当前Promise对象是 pending状态就会变为 rejected 第三种方式 抛出异常: 如果当前是 pending 就会变为 rejectedlet p = new Promise((resolve, reject) =&gt; { //初始化状态是pending //第一种方式 调用 resolve 函数 // resolve('ok'); // pending =&gt; fulfilled (resolved) //第二种方式 调用 reject 函数 // reject(\"error\");// pending =&gt; rejected //3. 抛出错误 throw '出问题了'; //pending =&gt; rejected }); console.log(p); 一个 promise 指定多个成功/失败回调函数, 都会调用吗?简单说问题是：用then方法为一个Promise对象去指定多个回调，这些回调是否都会执行？答案：当 promise 改变为对应状态时都会调用 let p = new Promise((resolve, reject) =&gt; { resolve('OK'); }); ///指定回调 - 1 p.then(value =&gt; { console.log(value); }); //指定回调 - 2 p.then(value =&gt; { alert(value); }); 改变 promise 状态和指定回调函数谁先谁后?答案： 都有可能 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promise对象改变状态后才执行 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promi对象改变状态后才执行 }); p.then(value =&gt; { console.log(value); },reason=&gt;{ }) 如何先改状态再指定回调?① 在执行器中直接调用 resolve()/reject()② 延迟更长时间才调用 then() 什么时候才能得到数据?① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 promise.then()返回的新 promise 的结果状态由什么决定?(1) 简单表达: 由 then()指定的回调函数执行的结果决定(2) 详细表达:① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 promise 如何串连多个操作任务?(1) promise 的 then()返回一个新的 promise, 即可以在后边接着调用then()方法，可以看成 then()方法的链式调用(2) 通过 then 的链式调用串连多个同步/异步任务 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //异步任务 }); p.then(value =&gt; { return new Promise((resolve, reject) =&gt; { resolve(\"success\"); }); }).then(value =&gt; { //这里的Promise状态由他指定的回调函数的返回值绝定，此处回调函数没写返回值即为Undefined 所以这里的then方法返回结果就是一个成功的Promise且成功的结果就是回调函数返回的结果Undefined，因为成功了所以后边的then方法也会执行第一个回调函数，并且输出前边成功的结果所以依然是Undefined console.log(value); // success }).then(value =&gt; { console.log(value); //undefined }) promise 异常传透?(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理例如：下方启动了一个Promise，后续用then方法又进行了几个其他的任务，这时候只需要在最后的位置去指定失败的回调就可以。 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); // reject('Err'); }, 1000); }); p.then(value =&gt; { // console.log(111); throw '失败啦!'; }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); //失败啦! }); 中断 promise 链?(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }); p.then(value =&gt; { console.log(111); // 111 //有且只有一个方式 返回一个pending状态的Promise对象 return new Promise(() =&gt; {}); //下方的then方法因为没有发现前边的Promise对象状态发生改变所以就不执行了 }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); }); 自定义（手写）Promise(后续学习)定义整体结构Promise 构造函数的实现promise.then()/catch()的实现Promise.resolve()/reject()的实现Promise.all/race()的实现Promise.resolveDelay()/rejectDelay()的实现ES5 function 完整版本ES6 class 完整版本 async 与 awaitasync 函数 函数的返回结果为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定//和then方法返回规则一摸一样 async function main(){ //1. 如果返回值是一个非Promise类型的数据 // return 521; //2. 如果返回的是一个Promise对象 // return new Promise((resolve, reject) =&gt; { // // resolve('OK'); // reject('Error'); // }); //3. 抛出异常 throw \"Oh NO\"; //[PromiseState]]: \"rejected\" [PromiseResult]]: \"Oh NO\" } let result = main(); console.log(result); await 表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 async function lala(){ let p = new Promise((resolve, reject) =&gt; { // resolve('OK'); reject('Error'); }) //1. 右侧为promise的情况 await 返回的是 promise 成功的值即 'ok' // let res = await p; // console.log(res); //ok //2. 右侧为其他类型的数据 //let res2 = await 20; //console.log(res2); //20 //3. 如果promise是失败的状态 try{ let res3 = await p; }catch(e){ console.log(e); //抛出一个错误 使用try...catch } } lala() async与await结合/** * 读取同级目录resource文件夹下 有1.html 2.html 3.html 的文件内容 想去读取到 */ const fs = require('fs'); const util = require('util'); // util里有个方法可以将api转换成一个Promise形态的函数 const mineReadFile = util.promisify(fs.readFile); //回调函数的方式 // fs.readFile('./resource/1.html', (err, data1) =&gt; { // if(err) throw err; // fs.readFile('./resource/2.html', (err, data2) =&gt; { // if(err) throw err; // fs.readFile('./resource/3.html', (err, data3) =&gt; { // if(err) throw err; // console.log(data1 + data2 + data3); //读取到文件信息 // }); // }); // }); //async 与 await方式 就用不到回调函数 // 1.首先写一个async函数 async function main(){ try{ //2.读取第一个文件的内容 let data1 = await mineReadFile('./resource/1x.html'); let data2 = await mineReadFile('./resource/2.html'); let data3 = await mineReadFile('./resource/3.html'); console.log(data1 + data2 + data3); }catch(e){ // console.log(e); // Error: ENOENT: no such file or directory...... console.log(e.code); // ENOENT } } main(); async与await结合发送AJAX&lt;button id=\"btn\"&gt;点击获取段子&lt;/button&gt; &lt;script&gt; //一般使用axios封装好的 function sendAJAX(url){ return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.responseType = 'json'; xhr.open(\"GET\", url); xhr.send(); //处理结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //成功的结果 resolve(xhr.response); }else{ reject(xhr.status); } } } }); } //段子接口地址 https://api.apiopen.top/getJoke let btn = document.querySelector('#btn'); btn.addEventListener('click',async function(){ //获取段子信息 let duanzi = await sendAJAX('https://api.apiopen.top/getJoke'); //发送ajax请求的函数返回的结果是一个Promise对象 console.log(duanzi); }); &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"Ajax学习","slug":"02-ajax学习","date":"2022-04-14T02:22:11.000Z","updated":"2022-04-15T17:25:48.460Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://wuzimo233.github.io/posts/2.html","excerpt":"","text":"认识 Ajax什么是 Ajax Ajax 是一种异步请求数据的 web 开发技术，对于改善用户的体验和页面性能很有帮助。刚好回顾下什么是异步同步，大部分的请求是同步的，就是说我必须等待后台请求给我返回结果了才能往下操作。通俗讲的话，我要去烧水、水热了后去洗碗、扫地。同步来做的话就是依次等待水烧热后我再去洗碗，洗了碗后我再去扫地。异步做的话我把水壶接通电源（发送请求）、接着水壶它烧它的，我去扫地了，可能扫完地后水热了，再用水壶的水来洗碗。还可以说我今天一天没有逛朋友圈，晚上终于有空翻朋友圈，好不容易翻到了上午的朋友圈，突然觉得某个动态有意思我想评论一下或者点赞，如果页面上有刷新，那我点赞后直接就刷新了朋友圈，我又得从新翻很久才能回到刚才的动态页面。如果是不会刷新，即点赞后马上就显示了点赞记录。这就是无刷新技术通过Dom操作来实现的效果。所以Ajax通常会结合Dom一起操作。简单地说，在不需要重新刷新整个页面的情况下，Ajax 通过异步请求加载后台数据，能在网页的局部更新数据。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax 的目的是提高用户体验，较少网络数据的传输量。同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。AJAX=Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)Ajax 不是一门编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术 传统的网页(即不用 ajax 技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。 增加 B/S 体验性 （B/S 未来的主流，持续增长） Ajax 原理是什么在解释 Ajax 原理之前，我们不妨先举个 “领导想找小李汇报一下工作” 例子，领导想找小李问点事，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作。 Ajax 请求数据流程与“领导想找小李汇报一下工作”类似。其中最核心的依赖是浏览器提供的 XMLHttpRequest 对象，它扮演的角色相当于秘书，使得浏览器可以发出 HTTP 请求与接收 HTTP 响应。浏览器接着做其他事情，等收到 XHR 返回来的数据再渲染页面。 理解了 Ajax 的工作原理后，接下来我们探讨下如何使用 Ajax 利用 AJAX 可以做：注册时，输入用户名自动检测用户已经存在登陆时，提示用户密码错误删除数据时，将行 ID 发送到后台，后台在数据库中删除，数据库删除成功后，在页面 DOM 中将数据行也删除我们可以使用前端的一个标签来伪造一个 ajax 的样子。iframe 标签 &lt;!-- iframe 元素会创建包含另外一个文档的内联框架（即行内框架） --&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function () { var myDate = new Date(); //获取当前时间 并传递给p标签里的span document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage() { var targetUrl = document.getElementById('url').value; //获取input框的网址 console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; //把网址传给内联标签iframe标签的src属性 } &lt;/script&gt; 这里简单的制造了一个在当前页面打开其他页面不刷新整体页面的场景，ajax 可以实现更多更高级的类似功能 Ajax 的使用原生Ajax 的使用1.创建 Ajax 核心对象 XMLHttpRequest(记得考虑兼容性) var xhr=null; if (window.XMLHttpRequest) { // 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); } else { // 兼容 IE6, IE5 xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 2.向服务器发送请求 xhr.open(method,url,async); send(string);//post请求时才使用字符串参数，否则不用带参数。 。。。太麻烦了 后期再学原生吧 jQuery.ajax 的使用浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery Ajax 本质就是 XMLHttpRequest，对他进行了封装，方便调用！纯 JS 原生实现 Ajax 暂时不去了解了，直接使用 jquery 提供的，方便学习和使用，避免重复造轮子，有空再去了解下 JS 原生 的XMLHttpRequest把···Ajax 的核心是XMLHttpRequest对象(XHR)。XHR 为向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。 使用 jQuery 需要先从官网下载jQuery.js并导入到文件就可以使用$符号，它是jquery中代表jquery对象的引用,“jQuery”是核心对象。通过该对象可以获取jQuery对象，调用jQuery提供的方法等。$ &lt;==&gt; jQuery 通过 jQuery AJAX 方法，能够从远程服务器上请求文本、HTML、XML 或 JSON – 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery 中发起 Ajax 请求最常用的三个方法如下：$.get()$.post()$.ajax() $.get()函数的语法 jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求 将服务器上的资源请求到客户端来进行使用。 $.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 $.get()发起不带参数的请求使用 $.get() 函数发起不带参数的请求时，直接提供请求的 URL 地址和请求成功之后的回调函数即可，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', function(res) { console.log(res) // 这里的 res 是服务器返回的数据 }) $.get()发起带参数的请求使用 $.get() 函数发起带参数的请求时，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function(res) { console.log(res) }) $.post()函数的语法 jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。 $.post() 函数的语法如下： $.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 使用 $post() 向服务器提交数据的示例代码如下： $.post( 'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址 { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据 function(res) { // 回调函数 console.log(res) } ) $.ajax()函数的语法 相比于$.get()和$.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数 它允许我们对 Ajax 请求进行更详细的配置 $.ajax() 函数的基本语法如下： $.ajax({ type: '', // 请求的方式，例如 GET 或 POST url: '', // 请求的 URL 地址 data: { },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) 使用$.ajax()发起GET请求使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 ‘GET’ 即可： $.ajax({ type: 'GET', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址 data: { id: 1 },// 这次请求要携带的数据 success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) 使用$.ajax()发起POST请求使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 ‘POST’ 即可： $.ajax({ type: 'POST', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的 URL 地址 data: { // 要提交给服务器的数据 bookname:&nbsp;'水浒传', author:&nbsp;'施耐庵', publisher:&nbsp;'上海图书出版社' }, success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) jQuery.ajax(…) 部分参数： url：请求地址（待载入页面的URL地址） data：要发送的数据（待发送给后台的值key/value参数） success：载入成功之后执行的回调函数(全局) type：请求方式，GET、POST（1.9.0之后用method） // 下边的了解下不常用 headers：请求头 contentType：即将发送信息至服务器的内容编码类型(默认: “application/x-www-form-urlencoded; charset=UTF-8”) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 “xml”: 将服务器端返回的内容转换成xml格式 “text”: 将服务器端返回的内容转换成普通文本格式 “html”: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 “script”: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 “json”: 将服务器端返回的内容转换成相应的JavaScript对象 “jsonp”: JSONP 格式使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 接口相关知识 接口的概念 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。例如：www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求)www.liulongbin.top:3006/api/addbook 添加图书的接口（POST请求） 分析接口的请求过程 通过GET方式请求接口的过程 通过POST方式请求接口的过程 Ajax的优缺点优点1.无刷新更新数据。AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。2.异步与服务器通信。AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。3.前端和后端负载平衡。AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。4.基于标准被广泛支持。AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 5.界面与应用分离。Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点1.AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。2.AJAX的安全问题。3.因为网络延迟需要给用户提供必要提示","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-04-12T17:17:00.000Z","updated":"2022-04-15T06:14:16.957Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wuzimo233.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？因为学习一些知识总是学了就忘，或者敲了不复习，记得手写笔记也根本不爱翻动。花了大半天时间搭建个博客来记录未来学到的知识，勤能补拙吧~ 展望博客我会整理一些个人所学的知识（前端方向和一些其它数码、科技、摄影先暂时想这么多）或生活方面有兴趣的事发到博客上。 关于博主普普通通的社畜。。 勇敢就是，在你还没开始的时候就知道自己会输，但依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。 ​ go on！","categories":[{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"案例","slug":"案例","permalink":"https://wuzimo233.github.io/tags/%E6%A1%88%E4%BE%8B/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"},{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}