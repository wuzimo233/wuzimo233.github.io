{"meta":{"title":"zimo","subtitle":"zimoの博客","description":"人要接受自己的有限性，人的逻辑、理性、阅读都是有限的，整个人就是在偏见之中。人这一生就是在走出偏见。","author":"Zimo","url":"https://wuzimo233.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-04-14T05:28:56.000Z","updated":"2022-04-16T01:46:42.290Z","comments":false,"path":"about/index.html","permalink":"https://wuzimo233.github.io/about/index.html","excerpt":"","text":"普通人埼玉“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：普通人琦玉（萌新up） QQ：2772459092 座右铭：昨日之深渊,今日之浅谈"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wuzimo233.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-15T18:40:45.848Z","updated":"2022-04-15T18:40:33.275Z","comments":true,"path":"bangumis/index.html","permalink":"https://wuzimo233.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-04-15T09:38:28.000Z","updated":"2022-04-15T09:38:20.951Z","comments":false,"path":"comments/index.html","permalink":"https://wuzimo233.github.io/comments/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-15T09:12:19.000Z","updated":"2022-04-15T09:30:45.183Z","comments":false,"path":"categories/index.html","permalink":"https://wuzimo233.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-15T09:33:49.000Z","updated":"2022-04-15T09:34:52.986Z","comments":true,"path":"link/index.html","permalink":"https://wuzimo233.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://wuzimo233.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-15T09:09:39.000Z","updated":"2022-04-15T09:29:33.704Z","comments":false,"path":"tags/index.html","permalink":"https://wuzimo233.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-16T02:11:08.265Z","comments":false,"path":"List/movies/index.html","permalink":"https://wuzimo233.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-13T13:05:50.468Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wuzimo233.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-04-13T16:19:21.819Z","comments":false,"path":"List/music/index.html","permalink":"https://wuzimo233.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-16T02:11:10.000Z","updated":"2022-04-16T02:18:08.424Z","comments":false,"path":"List/videos/index.html","permalink":"https://wuzimo233.github.io/List/videos/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wuzimo233.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wuzimo233.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"TEST","slug":"test","date":"2022-04-20T08:15:00.000Z","updated":"2022-04-20T09:23:14.625Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://wuzimo233.github.io/posts/9.html","excerpt":"","text":"使用hexo发布文章遇到的问题使用两个花括号报错","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"JS进阶学习","slug":"08-JS进阶学习","date":"2022-04-18T13:53:00.000Z","updated":"2022-04-18T14:26:33.665Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://wuzimo233.github.io/posts/8.html","excerpt":"","text":"ES6高级待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue进阶知识学习","slug":"06-Vue进阶学习","date":"2022-04-18T13:42:00.000Z","updated":"2022-04-20T12:15:39.841Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://wuzimo233.github.io/posts/6.html","excerpt":"","text":"Vue 进阶知识点组件中的data为什么是函数答案避免组件中的数据互相影响。同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。 computed和watch的区别action 与 mutation 的区别 mutation 是同步更新， $watch 严格模式下会报错 action 是异步操作，可以获取数据后调用 mutation 提交最终数据 Vue 组件通讯有哪几种方式父传子通过props传递父亲提供数据通过属性 props传给儿子；儿子通过 $on 绑父亲的事件，再通过 $emit 触发自己的事件（发布订阅）利用父子关系 $parent 、 $children 子传父在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。父组件： &lt;child @receive = ‘receive’ /&gt;子组件: this.$emit(‘receive’,’传递的数据’) 兄弟组件传值通过中央通信 let bus = new Vue()prop 验证，和默认值 v-for 为什么要加 keyv-model 原理怎样理解 Vue 的单向数据流Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。 虚拟 DOM 是什么 有什么优缺点 谈一下对 vuex 的个人理解vuex是什么Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 怎么使用vuexvuex中有几个核心属性，分别是什么？ 一共有5个核心属性，分别是: state 唯一数据源,Vue 实例中的 data 遵循相同的规则 getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值. mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发 action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作 module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。 路由页面管理（vue-router）什么是vue-router怎么使用vue-router怎么定义vue-router的动态路由？怎么获取传过来的动态参数？vue-router 路由钩子函数是什么 执行顺序是什么路由拦截方法待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"}]},{"title":"JS基础知识","slug":"07-JS基础学习","date":"2022-04-17T17:00:00.000Z","updated":"2022-04-18T14:26:29.793Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://wuzimo233.github.io/posts/7.html","excerpt":"","text":"JS基础知识点待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"}]},{"title":"Vue基础知识学习","slug":"05-Vue基础学习","date":"2022-04-17T11:47:00.000Z","updated":"2022-04-20T12:17:06.663Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://wuzimo233.github.io/posts/5.html","excerpt":"","text":"Vue 基础知识点谈谈对Vue的理解Vue是渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。 vue的优点 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；双向数据绑定：保留了angular的特点，在数据操作方面更为简单；组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。 Vue 的生命周期方法有哪些 一般在哪一步发请求生命周期：事物从诞生到消亡的过程Vue生命周期： vue基本指令插值操作Mustache &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;!--mustache语法中,不仅仅可以直接写变量,也可以写简单的表达式--&gt; &lt;h2&gt;{{firstName + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName + ' ' + lastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{lastName}}&lt;/h2&gt; &lt;h2&gt;{{counter * 2}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', firstName: 'kobe', lastName: 'bryant', counter: 100 }, }) &lt;/script&gt; v-once在某些情况下，我们可能不希望界面随意的跟随改变这个时候，我们就可以使用一个Vue的指令v-once:该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。代码如下： &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-once&gt;{{message}},李银河&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-html某些情况下，我们从服务器请求到的数据本身就是一个HTML代码如果我们直接通过插值语法来输出，会将HTML代码也一起输出但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容如果我们希望解析出HTML展示可以使用v-html指令该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染 &lt;div id=\"app\"&gt; &lt;h2&gt;{{url}}&lt;/h2&gt; &lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' } }) &lt;/script&gt; v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中v-text通常情况下，接受一个string类型缺点是不够灵活：第二个h2不会显示李银河 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}, 李银河!&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;, 李银河!&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-prev-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。比如下面的代码第一个h2元素中的内容会被编译解析出来对应的内容第二个h2元素中会直接显示 &lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-pre&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊' } }) &lt;/script&gt; v-cloak在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签cloak: “斗篷” &lt;div id=\"app\" v-cloak&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 在vue解析之前, div中有一个属性v-cloak // 在vue解析之后, div中没有一个属性v-cloak setTimeout(function () { const app = new Vue({ el: '#app', data: { message: '你好啊' } }) }, 1000) &lt;/script&gt; v-if 和 v-show 的区别Vue 修饰符有哪些v-for 为什么要加 key理解 Vue 的单向/双向 数据流首先了解一下数据绑定什么是绑定？比如当前href属性值取决于表达式school.url.toUpperCase()的结果，这两者之间就是有绑定关系，且通过v-bind指令完成数据绑定。 &lt;a v-bind:href=\"school.url.toUpperCase()\" v-bind:x=\"hello\"&gt;点我去{{school.name}}学习&lt;/a&gt; v-bind 单向数据原理前面学习的指令主要作用是将值插入到模板的内容当中但除了内容需要动态来决定外，某些属性也希望动态来绑定作用：动态绑定属性缩写：**:**预期：any (with argument) | Object (without argument)参数：attrOrProp (optional)v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到Vue进阶时介绍)在开发中，一般有哪些属性需要动态进行绑定呢？比如图片的链接src、网站的链接href、动态绑定一些类、样式等等例子：通过Vue实例中的data绑定元素的src和href，代码如下： 基本使用很多时候，我们希望动态的来切换class，比如：当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。 &lt;div id=\"app\"&gt; &lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt; &lt;!--&lt;img src=\"{{imgURL}}\" alt=\"\"&gt;--&gt; &lt;!-- 正确的做法: 使用v-bind指令 --&gt; &lt;img v-bind:src=\"imgURL\" alt=\"\"&gt; &lt;a v-bind:href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;!--&lt;h2&gt;{{}}&lt;/h2&gt;--&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=\"imgURL\" alt=\"\"&gt; &lt;a :href=\"aHref\"&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', imgURL: 'https://img11.360buyimg.com/mobilecms/s350x250_jfs/t1/20559/1/1424/73138/5c125595E3cbaa3c8/74fc2f84e53a9c23.jpg!q90!cc_350x250.webp', aHref: 'http://www.baidu.com' } }) &lt;/script&gt; 动态绑定class(对象语法) 绑定方式：对象语法含义是:class后面跟的是一个对象 直接通过{}绑定一个类&lt;h2 :class=\"{'active': isActive}\"&gt;Hello World&lt;/h2&gt; 也可以通过判断，传入多个值&lt;h2 :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类&lt;h2 class=\"title\" :class=\"{'active': isActive, 'line': isLine}\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 比如ul的li标签点击某个标签变颜色 &lt;div id=\"app\"&gt; &lt;!-- 当布尔值为true 这个类名1即 active 就会被添加到标签上 --&gt; &lt;!-- 一个 { } 表示对象 --&gt; &lt;h2 class=\"title\" v-bind:class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" v-bind:class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', isActive: true, isLine: true }, methods: { btnClick: function () { this.isActive = !this.isActive }, getClasses: function () { return {active: this.isActive} } } }) &lt;/script&gt; 动态绑定class(数组语法) 数组语法的含义是:class后面跟的是一个数组。 直接通过{}绑定一个类&lt;h2 :class=\"['active']\"&gt;Hello World&lt;/h2&gt; 也可以传入多个值&lt;h2 :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突注：会有title/active/line三个类&lt;h2 class=\"title\" :class=“[‘active’, 'line']\"&gt;Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性&lt;h2 class=\"title\" :class=\"classes\"&gt;Hello World&lt;/h2&gt; 例如： &lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"[active, line]\"&gt;{{message}}&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;{{message}}&lt;/h2&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue({ el: '#app', data: { message: '你好啊', active: 'aaaaaa', line: 'bbbbbbb' }, methods: { getClasses: function () { return [this.active, this.line] } } }) &lt;/script&gt; 小案例 点击li标签变色（默认第一li为红色）分析： v-for绑定给li标签，同时v-on添加点击事件，并且li标签的class用v-bind动态绑定 使用v-for绑定到li标签上，自动遍历data中的数据，将下标（index）和每一项内容（item）用插值语法显示到页面 在data中添加一个isRed属性值为0，想让class样式显示，需要v-bind绑定的red值为true，即该值可以等等于index,因为index的第一个值就是0 v-on点击事件点击某一个li，将下标的值赋值给isRed，即当前点击的li标签的class样式显示 end~&lt;style&gt; .red { color: red; } &lt;/style&gt; &lt;!--作业需求: 点击列表中的哪一项, 那么该项的文字变成红色--&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- &lt;li v-for=\"每一项,下标 in 数据源\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;li v-for=\"(item,index) in movie\" v-on:click=\"getColor(index)\" v-bind:class=\"{red:isRed==index}\" &gt;{{index}}--{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', data:{ isRed:0, movie:['海王','海尔兄弟','火影忍者','进击的巨人'] }, methods:{ getColor: function (index){ this.isRed = index console.log(this.isRed); } }, }) &lt;/script&gt; v-bind绑定style 一利用v-bind:style来绑定一些CSS内联样式在写CSS属性名的时候，比如font-size可以使用驼峰式 (camelCase) fontSize或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ v-model 双向数据原理Vue2.x响应式数据/双向绑定原理整体思路是数据劫持+观察者模式Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。Vue中有两种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。备注： 双向绑定一般都应用在表单类元素上（如：input、select等） v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。&lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'哔哩哔哩', } }) &lt;/script&gt; 虚拟 DOM 是什么 有什么优缺点MVVM全称： Model-View-ViewModel ， Model 表示数据模型层。 view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。 Model层： 数据层数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。 View层： 视图层在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。 VueModel层： 视图模型层视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。 M：模型(Model) ：对应 data 中的数据 V：视图(View) ：模板 VM：视图模型(ViewModel) ： Vue 实例对象Vm（Vue实例对象）把左边的View和右边Model进行连接在一起 观察发现： data中所有的属性，最后都出现在了vm身上。 VM身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 执行过程 ：数据在data中经过 VM视图模型放到了页面View上页面上如果有地方需要更改要映射回数据就再给VM视图模型，然后视图模型再给data里的数据 &lt;!-- 1 准备好一个容器 也就是 view 视图 模板代码--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;!-- &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = fal se //阻止 vue 在启动时生成生产提示 const vm = new Vue({// 2 VM 视图模型ViewModel el:'#root', data:{ // 3 data里的是模型 model name:\"b站大学\", address:\"成都\", } }) console.log(vm) &lt;/script&gt; Vue的数据代理首先学习下 Object.defineProperty()方法Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。defineProperty()参数 Object.defineProperty(obj, prop, descriptor) obj 需要定义属性的对象 prop 需被定义或修改的属性名 descriptor 需被定义或修改的属性的描述符 例子：定义了一个person对象，里面包含name、sex属性和其它属性值。注意：age属性是通过defineProperty方法中 &lt;script type=\"text/javascript\"&gt; let number = 19 let person = { name: '张三', sex: '男', } Object.defineProperty(person, 'age', { value:19, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get() { console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value) { console.log('有人修改了age属性，且值是', value) number = value } }) console.log(Object.keys(person)) // Object.keys方法传入一个对象作为参数，可以把传入对象所有属性的属性名提取出来变成数组 console.log(person) &lt;/script&gt; 什么是数据代理数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） &lt;script type=\"text/javascript\" &gt; let obj = { x:100 } let obj2 = { y:200 Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; Vue中的数据代理### vue常用ui库移动端 mint-ui （http://mint-ui.github.io/#!/zh-cn） Vant（https://youzan.github.io/vant/#/zh-CN/home） VUX (https://vux.li/) pc端 element-ui（https://element.eleme.cn/2.13/#/zh-CN/component/installation） Ant Design of Vue（https://www.antdv.com/docs/vue/introduce-cn/） Avue (https://avuejs.com/) 常用webpack配置待更新。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"}]},{"title":"axios学习","slug":"04-axios学习","date":"2022-04-17T06:12:00.000Z","updated":"2022-04-18T08:01:30.170Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://wuzimo233.github.io/posts/4.html","excerpt":"","text":"前置条件已经学习过ajax、Promise准备json-server包，快速搭建HTTP服务（用axios的时候需要向服务端发送请求即需要服务端这个角色来与axios结合做实践） json-server用于模拟服务端接口数据，可以根据json数据建立一个完整的web服务 1安装json-servernpm install -g json-server //查看版本号，安装成功 json-server -v 2在文件夹下创建一个db.json文件，存放一些数据。{ \"posts\": [ //文章 { \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }, { \"id\": 2, \"title\": \"《b站大学》\", \"author\": \"吴老师\" } ], \"comments\": [ //评论 { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }, { \"body\": \"喜大普奔\", \"postId\": 2, \"id\": 2 } ], \"profile\": { //个人信息 \"name\": \"typicode\" } } 3 启动服务进入终端。执行启动json-server命令:json-server --watch .\\db.json 认识axiosaxios 是什么?axios是目前前端使用非常广泛的基于 promise 的 HTTP 网络请求库，包括Vue/React也是推荐使用axios；本质是XMLHttpRequests请求 即ajax请求 axios 特性： 从浏览器中创建 XMLHttpRequests （浏览器中发送xml请求） 从 node.js 创建 http 请求 （在node.js中发送http请求） 支持 Promise API 相关操作 拦截请求和响应 转换请求数据和响应数据（对请求和响应的数据作转换） 取消请求 自动将结果转换成 JSON 数据 客户端支持防御 XSRF （阻止跨站攻击） axios安装 1 使用 npm安装:$ npm install axios 2 使用 yarn安装:$ yarn add axios 3 使用 jsDelivr CDN安装:&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.min.js\"&gt;&lt;/script&gt; console.log(axios); //ƒ() {for(var n=new Array(arguments.length),r=0;r&lt;n.length;r++)n[r]=arguments[r];return e.apply(t,n)} //建议使用国内CDN网速较快 //去这个网站引入 https://www.bootcdn.cn/axios/ axios的基本使用 前置：引入了axios准备四个按钮发送不同的请求 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; GET请求//获取按钮 const btns = document.querySelectorAll('button'); //第一个 （get 查询功能） btns[0].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'GET', //请求地址 刚启动好的json-server地址 且id为2的那篇文章 url: ' http://localhost:3000/posts/2' }).then(response =&gt; { console.log(response); }) } POST请求//添加一篇新的文章 （post 添加功能） btns[1].onclick = function () { //发送ajax请求 axios({ method: 'POST', //请求类型 url: ' http://localhost:3000/posts', //请求地址 data: { \"title\": \"招聘摄影\", //请求体 \"author\": \"小吴\" } }).then(response =&gt; { console.log(response); }) } PUT请求//更新文章 需要在url里加上id 比如这里要更新的是id为3的文章（put 更新功能） btns[2].onclick = function () { //发送ajax请求 axios({ method: 'PUT', //请求类型 url: ' http://localhost:3000/posts/3', //请求地址 data: { \"title\": \"招聘程序员吗\", //修改请求体的数据 \"author\": \"小瑶酱\" } }).then(response =&gt; { console.log(response); }) } DELETE请求//删除文章 （delete 删除功能） btns[3].onclick = function () { //发送ajax请求 axios({ //请求类型 method: 'DELETE', //请求地址 url: ' http://localhost:3000/posts/3', }).then(response =&gt; { console.log(response); }) } axios的其他发送请求使用request方法 发送 GET 请求 （接收一个对象类型参数）//获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ // axios() axios.request({ method:'GET', url:' http://localhost:3000/posts', // 返回结果依然是Promise对象 用then指定成功的回调 }).then((response) =&gt; { console.log(response); }) ; } //使用POST方法 发送post请求 增加数据//获取按钮 const btns = document.querySelectorAll('button'); btns[1].onclick = function(){ // axios() axios.post( 'http://localhost:3000/comments', { \"body\": \"喜大普奔\", \"postId\": 2 }).then(response =&gt; { console.log(response); }) } axios配置对象{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 baseURL: 'https://some-domain.com/api/', // `transformRequest` 对请求的数据做处理，处理后将结果像服务器发送 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 对响应的结果做一些改变，改变之后我们用自定义的回调去处理结果 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 对请求头信息做一个配置（身份校验） headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `data` 是作为请求体的设置 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时对coken的携带设置 withCredentials: false, //不携带 // `adapter` 对请求的适配器做设置 // 有两种一种是ajax、一种是node.js里发送http请求的 adapter: function (config) { /* ... */ }, // `auth` 对请求基础的验证设置用户名和密码 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // 响应结果的编码 responseEncoding: 'utf8', // `xsrfCookieName` 跨域请求标识对cookie的名称设置 xsrfCookieName: 'XSRF-TOKEN', // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 上传的一些回调 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 下载时的一些回调 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 对响应结果的成功做一个设置 什么情况下是成功的呢？默认值为响应状态码 大于等于200 小于300 validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 最大跳转的次数 默认5次 即向一个服务发送请求，它作了跳转后呢，我们是否需要让它继续往前进行请求 maxRedirects: 5, // 默认的 // 设置socket 文件的位置 作用是像docker的守护进程发送请求的 socketPath: null, // default // 对客户端的一些信息做一些设置 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 设置代理 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 对ajax请求作一个取消的设置 cancelToken: new CancelToken(function (cancel) { }) } axios的默认配置例子：点击按钮发送get请求//没有做默认配置时，每次访问都比较麻烦 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt; 发送POST请求 &lt;/button&gt; &lt;button class=\"btn btn-success\"&gt; 发送 PUT 请求 &lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt; 发送 DELETE 请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 获取按钮 const btns = document.querySelectorAll('button'); btns[0].onclick = function(){ axios({ method:'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log(response); }) } &lt;/script&gt; 使用默认配置后 //默认配置 axios.defaults.method = 'GET'; //设置默认的请求类型为 GET axios.defaults.baseURL = 'http://localhost:3000' //设置基础url btns[0].onclick = function () { axios({ url: '/posts', }).then(response =&gt; { console.log(response); }) //还有其他的默认配置项 // axios.defaults.params = {id:100}; 默认的请求url参数 即url后增加 ?id=100 // axios.defaults.timeout = 3000; 超时时间 axios创建实例对象主要用于：项目中接口数据服务不是来自于单一的服务器，比如有两个服务器A、B，都提供了数据服务。在发送请求时，比如给A发，就要去设置A的协议域名端口，如果用默认方法做只能满足一个服务器， &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;基本使用&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送GET请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 发送POST请求 &lt;/button&gt; &lt;br&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //创建实例对象 /getJoke const duanzi = axios.create({ baseURL:'https://api.apiopen.top', timeout:2000 }); //这里duanzi 与 axios 对象的功能几近是一样的 duanzi({ url:'/getJoke', }).then((response)=&gt;{ console.log(response); }) duanzi.get('/getJoke').then((response) =&gt; { console.log(response.data); }) const another = axios.create({ baseURL:'http:b.com', timeout:2000 }) axios拦截器在请求或响应被 then 或 catch 处理前拦截它们。在发送请求之前，借助一些函数对请求的参数和内容作一些处理和检测。如果说都没有问题再去发送请求，有问题的话这个请求就停止或者取消。当服务器返回结果之后，可以通过自己指定的回调处理结果。那么响应拦截器可以在我们处理响应结果之前先对结果做一些预处理。如：失败了就对失败结果做一些提醒或者记录，还能对数据接口做一些格式化的处理。然后再交由我们自己自定义的回调来处理。如果有问题在响应拦截器中就处理掉了。执行顺序是，当用户发送请求后先执行请求拦截器成功/失败的回调，然后走响应拦截器成功/失败的回调，然后再走自定义的成功/失败的回调 一般情况// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); return config; }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }); 其他情况：请求拦截器成功但抛出错误，响应拦截器失败，自定义失败回调// Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功'); // return config; throw '参数出了问题' //如果这里抛出错误即失败了，返回一个失败的Promise， //在执行后续的响应回调时就只能走失败的回调了， }, function (error) { console.log('请求拦截器 失败 '); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功'); return response; // return response; }, function (error) { console.log('响应拦截器 失败') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) 多个请求、响应的结果顺序请求拦截器 成功 2号请求拦截器 成功 1号响应拦截器 成功 1号响应拦截器 成功 2号自定义回调处理成功的结果{data: Array(2), status: 200, statusText: ‘OK’, headers: {…}, config: {…},&nbsp;…} // Promise相关 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 1号'); //修改 config 中的参数 // config.params = {a:100}; return config; }, function (error) { console.log('请求拦截器 失败 1号'); return Promise.reject(error); }); axios.interceptors.request.use(function (config) { console.log('请求拦截器 成功 2号'); //修改 config 中的参数 config.timeout = 2000; return config; }, function (error) { console.log('请求拦截器 失败 2号'); return Promise.reject(error); }); // 设置响应拦截器 axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 1号'); return response; // return response; }, function (error) { console.log('响应拦截器 失败 1号') return Promise.reject(error); }); axios.interceptors.response.use(function (response) { console.log('响应拦截器 成功 2号') return response; }, function (error) { console.log('响应拦截器 失败 2号') return Promise.reject(error); }); //发送请求 axios({ method: 'GET', url: 'http://localhost:3000/posts' }).then(response =&gt; { console.log('自定义回调处理成功的结果'); console.log(response); }).catch(reason =&gt; { console.log('自定义回调处理失败的结果'); console.log(reason); }) axios取消请求 基本流程配置 cancelToken 对象缓存用于取消请求的 cancel 函数在后面特定时机调用 cancel 函数取消请求在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能点击按钮, 取消某个正在请求中的请求 在请求一个接口前, 取消前面一个未完成的请求 使用 canceltoken 取消请求Axios 的 cancel token API 基于cancelable promises proposal可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;axios取消请求&lt;/h2&gt; &lt;button class=\"btn btn-primary\"&gt; 发送请求 &lt;/button&gt; &lt;button class=\"btn btn-warning\" &gt; 取消请求 &lt;/button&gt; &lt;/div&gt; &lt;script&gt; //获取按钮 const btns = document.querySelectorAll('button'); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function(){ // 防止用户疯狂点击按钮发送请求 //检测上一次的请求是否已经完成 if(cancel !== null){ //取消上一次的请求 cancel(); } axios({ method: 'GET', url: 'http://localhost:3000/posts', //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function(c){ //3. 将 c 的值赋值给 cancel cancel = c; }) }).then(response =&gt; { console.log(response); //将 cancel 的值初始化 cancel = null; }) } //绑定第二个事件取消请求 btns[1].onclick = function(){ cancel(); } axios源码文件结构说明 ├── /dist/ # 项目打包后的文件即最终输出的axios整体文件 ├── /lib/ # 项目源码目录 │ ├── /adapters/ # 定义请求的适配器 xhr、http │ │ ├── http.js # 用来在node.js中向 远端服务发送HTTP请求的 │ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象) │ ├── /cancel/ # 定义取消功能 │ ├── /core/ # 一些核心功能 │ │ ├── Axios.js # axios 的核心主类 构造函数 │ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数 │ │ ├── InterceptorManager.js # 拦截器的管理器 │ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态 │ ├── /helpers/ # 一些辅助方法 │ ├── axios.js # 对外暴露接口 │ ├── defaults.js # axios 的默认配置 │ └── utils.js # 公用工具 ├── package.json # 项目信息 ├── index.d.ts # 配置 TypeScript 的声明文件 └── index.js # 入口文件 axios的创建过程axios对象创建过程模拟实现axios发送请求过程详解模拟实现axios发送请求axios拦截器工作原理模拟实现axios拦截器功能axios 取消请求工作原理模拟实现axios取消请求功能axios源码分析总结","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"}]},{"title":"Promise学习","slug":"03-Promise学习","date":"2022-04-14T06:30:00.000Z","updated":"2022-04-18T13:59:32.062Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://wuzimo233.github.io/posts/3.html","excerpt":"","text":"认识 Promise 什么是 Promise 抽象表达: Promise 是一门新的技术(ES6 规范)Promise 是 JS 中进行异步编程的新解决方案备注：旧方案是单纯使用回调函数 具体表达: 语法上来说: Promise 是一个构造函数从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 为什么要用 Promise指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题 什么是回调地狱? 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用 终极解决方案? async/await 如何使用 PromisePromise 语法结构 语法结构： new Promise((resolve, reject) =&gt; { } 里面是一个函数类型的参数，参数里面的两个参数也是函数在花括号{ }里边包含一个异步操作,如果成功则调用 resolve ，同时只要 resolve 调用就会将 promise 对象 p 的状态设置为『成功』，如果失败则调用 reject，调完 reject 后会将 promise 对象 p 的状态设置为『失败』（即这两个可以修改 promise&gt;对象的状态）接着 promise 对象通过调用 then()方法去指定成功和失败时的回调如果成功就执行第一个回调函数，失败则执行第二个回调函数Promise 除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即下方Promise 形式实现案例的 n 值然后可以将 n 值传递给 resolve 和 reject 函数最后下方的 then 方法里的两个回调都能拿到这个结果值作为参数使用 Promise 初体验 案例：需求——点击抽奖按钮两秒后，告诉用户是否中奖，中奖的概率是百分之 30。如果中奖在页面中弹框告知恭喜中奖，没有就弹出再接再厉。 一般方法实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 定时器 setTimeout(() =&gt; { //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ alert(n+'恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券'); }else{ alert(n+'再接再厉'); } }, 1000); }) &lt;/script&gt; Promise 形式实现 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 初体验&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //生成随机数 function rand(m,n){ return Math.ceil(Math.random() * (n-m+1)) + m-1; } //获取元素对象 const btn = document.querySelector('#btn'); //绑定单击事件 btn.addEventListener('click', function(){ // 使用 new Promise(接收一个函数参数) 创建实例 // resolve 解决 函数类型的数据 --成功时调用 // reject 拒绝 函数类型的数据 --失败时调用 const p = new Promise((resolve, reject) =&gt; { // promise对象可以包裹一个异步操作（直接将上方定时器拿过来） setTimeout(() =&gt; { //30% 1-100 1 2 30 //获取从1 - 100的一个随机数 let n = rand(1, 100); //判断 if(n &lt;= 30){ // Promise除了可以封装异步操作之外，还能获取异步操作里成功和失败的结果值 即这里的n值 // 可以将n值传递给resolve 和 reject函数 // 那么下方的then方法里的两个回调都能拿到这个结果值作为参数 resolve(n); // 调完resolve后会将 promise 对象 p 的状态设置为『成功』 }else{ reject(n); // 调完reject后会将 promise 对象 p 的状态设置为『失败』 } }, 1000); }); console.log(p); //调用 then（里边有两个回调函数参数） 方法 --- 每个promise对象上都有then方法 // 第一个回调是对象状态为成功时的回调，第二个是对象状态失败时的回调函数 // value 值 // reason 理由 p.then((value) =&gt; { alert('恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为 ' + value); }, (reason) =&gt; { alert('再接再厉, 您的号码为 ' + reason); }); }) &lt;/script&gt; 实践练习 Promise 封装 AJAX// 需求点击按钮发送ajax请求拿到段子接口的数据 &lt;div class=\"container\"&gt; &lt;h2 class=\"page-header\"&gt;Promise 封装 AJAX 操作&lt;/h2&gt; &lt;button class=\"btn btn-primary\" id=\"btn\"&gt;点击发送 AJAX&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //接口地址 https://api.apiopen.top/getJoke //获取元素对象 const btn = document.querySelector('#btn'); // 给按钮绑定点击事件 btn.addEventListener('click', function(){ //首先创建 Promise 对象 p const p = new Promise((resolve, reject) =&gt; { //1.创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 get请求 给后边的接口发送 xhr.open('GET', 'https://api.apiopen.top/getJoke'); //3. 发送 xhr.send(); //4. 处理响应结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断响应状态码 2xx if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //控制台输出响应体 resolve(xhr.response); }else{ //控制台输出响应状态码 reject(xhr.status); } } } }); //调用then方法 p.then(value=&gt;{ console.log(value); }, reason=&gt;{ console.warn(reason); }); }); &lt;/script&gt; Promise的状态 『PromiseState』 的改变状态是Promise实例对象当中的一个属性，属性叫做 promiseState 有三种状态 pending 值未决定的、初始化的默认值 pending 变为 resolved / fullfilled 即成功 pending 变为 rejected 即失败说明: pending变化只有这 2 种情况, 且一个 promise 对象只能改变一次无论变为成功还是失败, 都会有一个结果数据成功的结果数据一般称为 value, 失败的结果数据一般称为 reason Promise对象 『PromiseResult』的值保存着异步任务『成功/失败』的结果以下函数能够修改这个属性的值： resolve reject Promise的基本流程 首先通过new Promise 创造一个对象，在Promise内部封装异步操作。如果异步操作成功则调用resolve函数，resolve函数调用后会把Promise对象状态改为成功，成功在调用then方法时将调用的是第一个回调函数参数，返回一个新的promise对象如果在Promise内部封装的异步操作失败，则调用reject 函数，reject函数调用后会把Promise对象状态改为失败，失败之后调用的是then方法中的第二个回调函数参数，并且返回一个新的Promise对象 Promise的Api执行器函数Promise 构造函数: Promise (excutor) {}//new实例化对象需要接收一个参数，参数是一个函数类型的参数（也称之为执行器函数），而且函数当中有两个形参也是函数类型参数resolve、reject，这俩函数是内部定义的，异步任务成功就会调用resolve函数，失败就会调用reject函数。(1) executtor 函数: 执行器 (resolve, reject) =&gt; {}(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}说明: 执行器函数 executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行 let p = new Promise((resolv, reject) =&gt; // resolve('ok'); console.log(111); }) console.log(222); //结果控制台先打印111 ，后打印222。表明 p对象内部的代码是同步调用的 Promise.then方法Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}// 说明: then方法是用于指定回调的，传递两个参数，第一个参数是传递成功时的回调，第二个参数是传递失败时的回调。返回一个新的 promise 对象(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} Promise.catch方法Promise.prototype.catch 方法: (onRejected) =&gt; {}// 说明: catch() 方法是 then()的语法糖, 相当于: then(undefined, onRejected)，即只能指定失败的回调。 onRejected 函数: 失败的回调函数 (reason) =&gt; {let p = new Promise((resolv, reject) =&gt; // 修改Promise对象的状态 reject('error 失败了'); }) // 执行catch方法 p.catch(reason =&gt; { console.log(reason); }) Promise.resolve方法 Promise.resolve 方法: (value) =&gt; {}// 说明：它属于Promise函数对象，不是实例对象。接收一个参数，返回一个成功或失败的对象// 作用：就是快速得到一个Promise对象，还能封装一个值，将这个值转化为Promise对象 value: 成功的数据或 promise 对象 //如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象 //如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果 let zimo = Promise.resolve(\"I Love You\"); console.log(zimo); // Promise&nbsp;{&lt;fulfilled&gt;: 'I Love You' let p1 = Promise.resolve(new Promise((resolve, reject) =&gt; { resolve('OK'); // reject('Error'); })); p1.then((value) =&gt; { console.log(value); //ok },(reason)=&gt;{ console.log(reason); }) console.log(p1); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} let p2 = Promise.resolve(p1); console.log(p2); // Promise&nbsp;{&lt;fulfilled&gt;: 'OK'} Promise.reject方法Promise.reject 方法: (reason) =&gt; {}说明: 快速返回一个失败的 promise 对象即便传入成功的Promise对象结果也是失败 reason: 失败的原因let p1 = Promise.reject(520); p1.catch((reason) =&gt;{ console.log(reason); // Promise&nbsp;{&lt;rejected&gt;: 520} }) console.log(p1); // 520 let p2 = Promise.reject('iloveyou'); let p3 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p2); // Promise&nbsp;{&lt;rejected&gt;: 'iloveyou'} console.log(p3); //Promise&nbsp;{&lt;rejected&gt;: Promise} Promise.all 方法Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败。let p1 = new Promise((resolve, reject) =&gt; { resolve('OK'); }) // let p2 = Promise.resolve('Success'); let p2 = Promise.reject('Error'); let p3 = Promise.resolve('Oh Yeah'); const result = Promise.all([p1, p2, p3]); console.log(result); //[PromiseState]]: \"rejected\" Promise.race 方法Promise.race 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组说明: 接收一个参数，参数一般是Promise组成的数组，返回一个新的 promise, 第一个改变状态的 promise对象就是最终的结果状态。let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }) let p3 = Promise.resolve('Oh Yeah'); let p2 = Promise.resolve('Success'); //调用 const result = Promise.race([p1, p3, p2]); console.log(result); // [[PromiseState]]: \"fulfilled\" // [[PromiseResult]]: \"Oh Yeah\" Promise的几个关键问题如何改变 promise 的状态? 第一种方式 调用 resolve 函数: 如果当前Promise对象是 pending状态就会变为fulfilled(resolve) 第二种方式 调用 reject 函数: 如果当前Promise对象是 pending状态就会变为 rejected 第三种方式 抛出异常: 如果当前是 pending 就会变为 rejectedlet p = new Promise((resolve, reject) =&gt; { //初始化状态是pending //第一种方式 调用 resolve 函数 // resolve('ok'); // pending =&gt; fulfilled (resolved) //第二种方式 调用 reject 函数 // reject(\"error\");// pending =&gt; rejected //3. 抛出错误 throw '出问题了'; //pending =&gt; rejected }); console.log(p); 一个 promise 指定多个成功/失败回调函数, 都会调用吗?简单说问题是：用then方法为一个Promise对象去指定多个回调，这些回调是否都会执行？答案：当 promise 改变为对应状态时都会调用 let p = new Promise((resolve, reject) =&gt; { resolve('OK'); }); ///指定回调 - 1 p.then(value =&gt; { console.log(value); }); //指定回调 - 2 p.then(value =&gt; { alert(value); }); 改变 promise 状态和指定回调函数谁先谁后?答案： 都有可能 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promise对象改变状态后才执行 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //当这个执行器函数是异步任务时候时then方法先执行，但then方法需要在Promi对象改变状态后才执行 }); p.then(value =&gt; { console.log(value); },reason=&gt;{ }) 如何先改状态再指定回调?① 在执行器中直接调用 resolve()/reject()② 延迟更长时间才调用 then() 什么时候才能得到数据?① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 promise.then()返回的新 promise 的结果状态由什么决定?(1) 简单表达: 由 then()指定的回调函数执行的结果决定(2) 详细表达:① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 promise 如何串连多个操作任务?(1) promise 的 then()返回一个新的 promise, 即可以在后边接着调用then()方法，可以看成 then()方法的链式调用(2) 通过 then 的链式调用串连多个同步/异步任务 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); //异步任务 }); p.then(value =&gt; { return new Promise((resolve, reject) =&gt; { resolve(\"success\"); }); }).then(value =&gt; { //这里的Promise状态由他指定的回调函数的返回值绝定，此处回调函数没写返回值即为Undefined 所以这里的then方法返回结果就是一个成功的Promise且成功的结果就是回调函数返回的结果Undefined，因为成功了所以后边的then方法也会执行第一个回调函数，并且输出前边成功的结果所以依然是Undefined console.log(value); // success }).then(value =&gt; { console.log(value); //undefined }) promise 异常传透?(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理例如：下方启动了一个Promise，后续用then方法又进行了几个其他的任务，这时候只需要在最后的位置去指定失败的回调就可以。 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); // reject('Err'); }, 1000); }); p.then(value =&gt; { // console.log(111); throw '失败啦!'; }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); //失败啦! }); 中断 promise 链?(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }); p.then(value =&gt; { console.log(111); // 111 //有且只有一个方式 返回一个pending状态的Promise对象 return new Promise(() =&gt; {}); //下方的then方法因为没有发现前边的Promise对象状态发生改变所以就不执行了 }).then(value =&gt; { console.log(222); }).then(value =&gt; { console.log(333); }).catch(reason =&gt; { console.warn(reason); }); 自定义（手写）Promise(后续学习)定义整体结构Promise 构造函数的实现promise.then()/catch()的实现Promise.resolve()/reject()的实现Promise.all/race()的实现Promise.resolveDelay()/rejectDelay()的实现ES5 function 完整版本ES6 class 完整版本 async 与 awaitasync 函数 函数的返回结果为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定//和then方法返回规则一摸一样 async function main(){ //1. 如果返回值是一个非Promise类型的数据 // return 521; //2. 如果返回的是一个Promise对象 // return new Promise((resolve, reject) =&gt; { // // resolve('OK'); // reject('Error'); // }); //3. 抛出异常 throw \"Oh NO\"; //[PromiseState]]: \"rejected\" [PromiseResult]]: \"Oh NO\" } let result = main(); console.log(result); await 表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 async function lala(){ let p = new Promise((resolve, reject) =&gt; { // resolve('OK'); reject('Error'); }) //1. 右侧为promise的情况 await 返回的是 promise 成功的值即 'ok' // let res = await p; // console.log(res); //ok //2. 右侧为其他类型的数据 //let res2 = await 20; //console.log(res2); //20 //3. 如果promise是失败的状态 try{ let res3 = await p; }catch(e){ console.log(e); //抛出一个错误 使用try...catch } } lala() async与await结合/** * 读取同级目录resource文件夹下 有1.html 2.html 3.html 的文件内容 想去读取到 */ const fs = require('fs'); const util = require('util'); // util里有个方法可以将api转换成一个Promise形态的函数 const mineReadFile = util.promisify(fs.readFile); //回调函数的方式 // fs.readFile('./resource/1.html', (err, data1) =&gt; { // if(err) throw err; // fs.readFile('./resource/2.html', (err, data2) =&gt; { // if(err) throw err; // fs.readFile('./resource/3.html', (err, data3) =&gt; { // if(err) throw err; // console.log(data1 + data2 + data3); //读取到文件信息 // }); // }); // }); //async 与 await方式 就用不到回调函数 // 1.首先写一个async函数 async function main(){ try{ //2.读取第一个文件的内容 let data1 = await mineReadFile('./resource/1x.html'); let data2 = await mineReadFile('./resource/2.html'); let data3 = await mineReadFile('./resource/3.html'); console.log(data1 + data2 + data3); }catch(e){ // console.log(e); // Error: ENOENT: no such file or directory...... console.log(e.code); // ENOENT } } main(); async与await结合发送AJAX&lt;button id=\"btn\"&gt;点击获取段子&lt;/button&gt; &lt;script&gt; //一般使用axios封装好的 function sendAJAX(url){ return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.responseType = 'json'; xhr.open(\"GET\", url); xhr.send(); //处理结果 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ //判断成功 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //成功的结果 resolve(xhr.response); }else{ reject(xhr.status); } } } }); } //段子接口地址 https://api.apiopen.top/getJoke let btn = document.querySelector('#btn'); btn.addEventListener('click',async function(){ //获取段子信息 let duanzi = await sendAJAX('https://api.apiopen.top/getJoke'); //发送ajax请求的函数返回的结果是一个Promise对象 console.log(duanzi); }); &lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"}]},{"title":"Ajax学习","slug":"02-ajax学习","date":"2022-04-14T02:22:11.000Z","updated":"2022-04-15T17:25:48.460Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://wuzimo233.github.io/posts/2.html","excerpt":"","text":"认识 Ajax什么是 Ajax Ajax 是一种异步请求数据的 web 开发技术，对于改善用户的体验和页面性能很有帮助。刚好回顾下什么是异步同步，大部分的请求是同步的，就是说我必须等待后台请求给我返回结果了才能往下操作。通俗讲的话，我要去烧水、水热了后去洗碗、扫地。同步来做的话就是依次等待水烧热后我再去洗碗，洗了碗后我再去扫地。异步做的话我把水壶接通电源（发送请求）、接着水壶它烧它的，我去扫地了，可能扫完地后水热了，再用水壶的水来洗碗。还可以说我今天一天没有逛朋友圈，晚上终于有空翻朋友圈，好不容易翻到了上午的朋友圈，突然觉得某个动态有意思我想评论一下或者点赞，如果页面上有刷新，那我点赞后直接就刷新了朋友圈，我又得从新翻很久才能回到刚才的动态页面。如果是不会刷新，即点赞后马上就显示了点赞记录。这就是无刷新技术通过Dom操作来实现的效果。所以Ajax通常会结合Dom一起操作。简单地说，在不需要重新刷新整个页面的情况下，Ajax 通过异步请求加载后台数据，能在网页的局部更新数据。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax 的目的是提高用户体验，较少网络数据的传输量。同时，由于 AJAX 请求获取的是数据而不是 HTML 文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。AJAX=Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)Ajax 不是一门编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术 传统的网页(即不用 ajax 技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用 ajax 技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用 Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。 增加 B/S 体验性 （B/S 未来的主流，持续增长） Ajax 原理是什么在解释 Ajax 原理之前，我们不妨先举个 “领导想找小李汇报一下工作” 例子，领导想找小李问点事，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作。 Ajax 请求数据流程与“领导想找小李汇报一下工作”类似。其中最核心的依赖是浏览器提供的 XMLHttpRequest 对象，它扮演的角色相当于秘书，使得浏览器可以发出 HTTP 请求与接收 HTTP 响应。浏览器接着做其他事情，等收到 XHR 返回来的数据再渲染页面。 理解了 Ajax 的工作原理后，接下来我们探讨下如何使用 Ajax 利用 AJAX 可以做：注册时，输入用户名自动检测用户已经存在登陆时，提示用户密码错误删除数据时，将行 ID 发送到后台，后台在数据库中删除，数据库删除成功后，在页面 DOM 中将数据行也删除我们可以使用前端的一个标签来伪造一个 ajax 的样子。iframe 标签 &lt;!-- iframe 元素会创建包含另外一个文档的内联框架（即行内框架） --&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function () { var myDate = new Date(); //获取当前时间 并传递给p标签里的span document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage() { var targetUrl = document.getElementById('url').value; //获取input框的网址 console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; //把网址传给内联标签iframe标签的src属性 } &lt;/script&gt; 这里简单的制造了一个在当前页面打开其他页面不刷新整体页面的场景，ajax 可以实现更多更高级的类似功能 Ajax 的使用原生Ajax 的使用1.创建 Ajax 核心对象 XMLHttpRequest(记得考虑兼容性) var xhr=null; if (window.XMLHttpRequest) { // 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr=new XMLHttpRequest(); } else { // 兼容 IE6, IE5 xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 2.向服务器发送请求 xhr.open(method,url,async); send(string);//post请求时才使用字符串参数，否则不用带参数。 。。。太麻烦了 后期再学原生吧 jQuery.ajax 的使用浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery Ajax 本质就是 XMLHttpRequest，对他进行了封装，方便调用！纯 JS 原生实现 Ajax 暂时不去了解了，直接使用 jquery 提供的，方便学习和使用，避免重复造轮子，有空再去了解下 JS 原生 的XMLHttpRequest把···Ajax 的核心是XMLHttpRequest对象(XHR)。XHR 为向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。 使用 jQuery 需要先从官网下载jQuery.js并导入到文件就可以使用$符号，它是jquery中代表jquery对象的引用,“jQuery”是核心对象。通过该对象可以获取jQuery对象，调用jQuery提供的方法等。$ &lt;==&gt; jQuery 通过 jQuery AJAX 方法，能够从远程服务器上请求文本、HTML、XML 或 JSON – 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery 中发起 Ajax 请求最常用的三个方法如下：$.get()$.post()$.ajax() $.get()函数的语法 jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求 将服务器上的资源请求到客户端来进行使用。 $.get(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 $.get()发起不带参数的请求使用 $.get() 函数发起不带参数的请求时，直接提供请求的 URL 地址和请求成功之后的回调函数即可，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', function(res) { console.log(res) // 这里的 res 是服务器返回的数据 }) $.get()发起带参数的请求使用 $.get() 函数发起带参数的请求时，示例代码如下： $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function(res) { console.log(res) }) $.post()函数的语法 jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。 $.post() 函数的语法如下： $.post(url, [data], [callback]) 参数名 参数类型 是否必选 说明 url string 是 提交数据的地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 使用 $post() 向服务器提交数据的示例代码如下： $.post( 'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址 { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据 function(res) { // 回调函数 console.log(res) } ) $.ajax()函数的语法 相比于$.get()和$.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数 它允许我们对 Ajax 请求进行更详细的配置 $.ajax() 函数的基本语法如下： $.ajax({ type: '', // 请求的方式，例如 GET 或 POST url: '', // 请求的 URL 地址 data: { },// 这次请求要携带的数据 success: function(res) { } // 请求成功之后的回调函数 }) 使用$.ajax()发起GET请求使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 ‘GET’ 即可： $.ajax({ type: 'GET', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址 data: { id: 1 },// 这次请求要携带的数据 success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) 使用$.ajax()发起POST请求使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 ‘POST’ 即可： $.ajax({ type: 'POST', // 请求的方式 url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的 URL 地址 data: { // 要提交给服务器的数据 bookname:&nbsp;'水浒传', author:&nbsp;'施耐庵', publisher:&nbsp;'上海图书出版社' }, success: function(res) { // 请求成功之后的回调函数 console.log(res) } }) jQuery.ajax(…) 部分参数： url：请求地址（待载入页面的URL地址） data：要发送的数据（待发送给后台的值key/value参数） success：载入成功之后执行的回调函数(全局) type：请求方式，GET、POST（1.9.0之后用method） // 下边的了解下不常用 headers：请求头 contentType：即将发送信息至服务器的内容编码类型(默认: “application/x-www-form-urlencoded; charset=UTF-8”) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 “xml”: 将服务器端返回的内容转换成xml格式 “text”: 将服务器端返回的内容转换成普通文本格式 “html”: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 “script”: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 “json”: 将服务器端返回的内容转换成相应的JavaScript对象 “jsonp”: JSONP 格式使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 接口相关知识 接口的概念 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。例如：www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求)www.liulongbin.top:3006/api/addbook 添加图书的接口（POST请求） 分析接口的请求过程 通过GET方式请求接口的过程 通过POST方式请求接口的过程 Ajax的优缺点优点1.无刷新更新数据。AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。2.异步与服务器通信。AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。3.前端和后端负载平衡。AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。4.基于标准被广泛支持。AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。 5.界面与应用分离。Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 缺点1.AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。2.AJAX的安全问题。3.因为网络延迟需要给用户提供必要提示","categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-04-12T17:17:00.000Z","updated":"2022-04-15T06:14:16.957Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wuzimo233.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？因为学习一些知识总是学了就忘，或者敲了不复习，记得手写笔记也根本不爱翻动。花了大半天时间搭建个博客来记录未来学到的知识，勤能补拙吧~ 展望博客我会整理一些个人所学的知识（前端方向和一些其它数码、科技、摄影先暂时想这么多）或生活方面有兴趣的事发到博客上。 关于博主普普通通的社畜。。 勇敢就是，在你还没开始的时候就知道自己会输，但依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。 ​ go on！","categories":[{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://wuzimo233.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"感想","slug":"感想","permalink":"https://wuzimo233.github.io/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wuzimo233.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"JS","slug":"JS","permalink":"https://wuzimo233.github.io/tags/JS/"},{"name":"Vue","slug":"Vue","permalink":"https://wuzimo233.github.io/tags/Vue/"},{"name":"Axios","slug":"Axios","permalink":"https://wuzimo233.github.io/tags/Axios/"},{"name":"Promise","slug":"Promise","permalink":"https://wuzimo233.github.io/tags/Promise/"},{"name":"Ajax","slug":"Ajax","permalink":"https://wuzimo233.github.io/tags/Ajax/"},{"name":"生活","slug":"生活","permalink":"https://wuzimo233.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}